<HTML>
<HEAD>
<META NAME="GENERATOR" Content="Microsoft Visual Studio 6.0">
<TITLE></TITLE>
</HEAD>
<BODY>

<P align=center><STRONG><FONT 
size=6>Programming</FONT></STRONG></P>
<P align=center><STRONG><FONT size=6>for CoffeeMud 3.0</FONT></STRONG></P>
<P align=left><FONT size=5><EM>MEMO: How 
to code a non-generic item.&nbsp; How to code a generic item.&nbsp; How to 
properly create and destroy areas, rooms, mobs, items, spells, chants, 
etc.&nbsp; How to invoke abilities and affects.&nbsp; Event model.&nbsp; This 
should be as useful to YOU as to others, Bo.</EM></FONT></P>
<P align=left><FONT size=5><STRONG>
<IMG src="images/mug.jpg">
</STRONG><FONT 
size=3>&nbsp;</FONT></FONT></P>
<P align=left><FONT size=5 color=limegreen><STRONG>Overview:</STRONG></FONT></P>
<P align=left><FONT size=4>The purpose 
of this document is to assist those who wish to add custom Items, MOBs, 
Behaviors, Properties, or other objects to CoffeeMud.&nbsp; The reader should be 
familiar with Java programming, and should be experienced with writing and 
compiling Java classes.&nbsp; The object oriented notions of class inheretance 
and&nbsp;polymorphism, as well as the Java constructs of 
interfaces should be at least vaguely familiar to you before attempting to build classes 
for CoffeeMud.&nbsp; Also, it is expected that all of the ideas 
presented in the Archons Guide (ArchonGuide.html) are completely familiar.&nbsp; The difference 
between a GenItem and a StdItem will not be explained.&nbsp; 
It is not explained in the Archons Guide either, but if you 
have followed the Guide, you have discovered the differences on your 
own.</FONT></P>
<P align=left><FONT size=4>It is not expected that someone would wish to dive in 
and make wholesale changes to the CoffeeMud system right away, but is more 
likely wanting to fill in a functional gap in the system for their own 
needs.&nbsp; For this reason, this document is not organized as a comprehensive 
guide to programming CoffeeMud.&nbsp; Instead, it is designed to be a quick 
reference for those who wish to create the spot MOB, Behavior, Item, or Property 
for use on their maps.</FONT></P>
<P align=left><FONT size=4>With this in mind then, and in no particular order, 
the several essential object types in CoffeeMud are presented.</FONT></P>
<IMG src="images/smurf.jpg">
<P align=left><FONT size=5 color=mediumslateblue><STRONG>MOBs:</STRONG></FONT></P>
<P align=left><FONT size=4>MOBs, or "Moveable OBjects", are the creatures and 
characters which the players fight.&nbsp; In CoffeeMud, they are among the 
simpler objects to code.&nbsp; This is not because they are uncomplex.&nbsp; In 
fact, they are the MOST complex.&nbsp; However, this complexity comes due to the 
myriad of Items, Behaviors, Properties, and Abilities that are added to 
them.&nbsp; Short of these numerous additions, a MOB by himself is rather 
simple!</FONT></P>
<P align=left><FONT size=4>This simplicity is important however, and should be 
carefully considered before you run off to create new MOBs.&nbsp; If you are 
creating a new MOB because you want a creature to have some new kind of ability, 
then are you sure it is not a new Ability you want to write?&nbsp; If the new 
MOBs behavior is complex and unique, are you sure it's not a new Behavior you 
wish to code?</FONT></P>
<P align=left><FONT size=4>If you are sure, then carry on!&nbsp; The directory 
for your custom coded MOB objects should be specified using the "MOBS" entry in 
the coffeemud.ini file.&nbsp; See the Installation Guide for more information on 
your INI file.</FONT></P>
<P align=left><FONT size=4 color=mediumslateblue><STRONG>Coding a new MOB:</STRONG></FONT></P>
<P align=left><FONT size=4>A Custom MOB may or may not belong to any particular 
package, though it is important that the NAME of the MOB be unique in the 
system.&nbsp; A custom MOB must import the following packages:</FONT></P>
<pre>
import java.util.*;
import com.planet_ink.coffee_mud.utils.*;
import com.planet_ink.coffee_mud.interfaces.*;
import com.planet_ink.coffee_mud.MOBS.*;
import com.planet_ink.coffee_mud.common.*;
</pre>
<P><FONT size=4>As well as any other 
java.*,&nbsp;&nbsp;sun.*, or&nbsp;custom&nbsp;packages you may need.&nbsp; No 
other packages in the CoffeeMud system should be imported, other than those 
listed.</FONT> 
<P><FONT size=4>A MOB class must extend 
either <STRONG>StdMOB</STRONG> or GenMob, <STRONG>StdShopKeeper</STRONG> or 
GenShopKeeper, <STRONG>StdRideable</STRONG>          
   or GenRideable depending on the basic 
capabilities, and customizability&nbsp;you would like.&nbsp; Although Generic 
objects are more customizable at run-time, they also take a long time for the 
system to load and build, and take up a lot of database disk space.&nbsp; For 
this reason, using Standard instead of Generic whereever possible is always 
good.&nbsp; </FONT>
<P><FONT size=4>Each MOB must also have a custom "newInstance" method as shown 
below.</FONT><PRE>public class MyNewMOB extends StdMOB <BR>{ <BR>	public MyNewMOB() <BR>	{ <BR>		super(); <BR>	}</PRE><PRE>	public Environmental newInstance() <BR>	{ <BR>		return new MyNewMOB(); <BR>	} <BR>}</PRE>
<P><FONT size=4>     
    All of 
your customizing will be done inside the constructor: name, displayText, description, etc, 
etc.</FONT>
<P><FONT size=4></FONT>&nbsp;</P>
<pre>
	public MyNewMOB()
	{
		super();

		Username="anew mob"; 
		setDescription("It`s furry with 2 legs"); 
		setDisplayText("My new mob is standing here.");
		
		setAlignment(500);
		setMoney(0);
		setWimpHitPoint(2);
		baseEnvStats().setDamage(4);

		baseEnvStats().setAbility(0);
		baseEnvStats().setLevel(1);
		baseEnvStats().setArmor(30);
		baseEnvStats().setSpeed(1.0);
		baseEnvStats().setAttackAdjustment(30);
		baseEnvStats().setWeight(85);
		baseEnvStats().setSensesMask(EnvStats.CAN_SEE_DARK|EnvStats.CAN_SEE_INFRARED); <BR>		baseEnvStats().setDisposition(EnvStats.IS_FLYING);
		baseCharStats().setMyClass(CMClass.getCharClass("Fighter"));
		
		baseCharStats().setMyRace(CMClass.getRace("Dog"));
		baseCharStats().getMyRace().startRacing(this,false);
		baseCharStats().setStat(CharStats.GENDER,(int)'F');
		baseCharStats().setStat(CharStats.STRENGTH,18); <BR>		baseCharStats().setStat(CharStats.INTELLIGENCE,14);
		baseCharStats().setStat(CharStats.WISDOM,13);
		baseCharStats().setStat(CharStats.DEXTERITY,15);
		baseCharStats().setStat(CharStats.CONSTITUTION,12);
		baseCharStats().setStat(CharStats.CHARISMA,13);
		baseCharStats().setStat(CharStats.SAVE_COLD,50);<BR>
		baseState.setHitPoints(Dice.roll(baseEnvStats().level(),20,20));
		baseState.setMana(Dice.roll(baseEnvStats().level(),50,100));
		
		recoverMaxState();
		resetToMaxState();
		recoverEnvStats();
		recoverCharStats();
	}
</pre>
<P><FONT size=4>You can see here that the basic stats have 
been filled out, from level to attack speed, alignment and 
weight.&nbsp;&nbsp;For&nbsp;numeric values, higher is always better, except for 
Armor, which is always best low, and comes down from 100.&nbsp; You'll notice 
above that two commands are required to set the Race of the creature.&nbsp; 
Also, you should realize that the numerous saving throws, and senses as well as 
dispositions (sneaking, hiding) are not represented above, but can easily be 
added using the format shown.</FONT>
<P><FONT size=4>It is very important to note the last four commands.&nbsp; These 
commands "reset" the MOB, and "implement" the scores which are given in the 
several areas.&nbsp; "recoverEnvStats()", for instance, must be called whenever 
a change is made to the "baseEnvStats()" object.&nbsp; Ditto for "CharStats" and 
"MaxState".&nbsp; </FONT>
<P><FONT size=4>Now, suppose we wanted 
to add an "Affect" or "Behavior" or "Ability" to your 
<STRONG>StdMOB</STRONG>              .&nbsp; The 
proper place for such a statement would be in the same above constructor, among 
the other commands.&nbsp; Preferably before the several "recover" commands, but 
after the several stat definitions.  Of course, all of this is unnecesssary for a new GenMOB object.</FONT>
<pre>
		
		addNonUninvokableAffect(CMClass.getAbility("Fighter_Berzerk"));
		addAbility(CMClass.getAbility("Poison"));
		
		addBehavior(CMClass.getBehavior("MudChat"));
		addBehavior(CMClass.getBehavior("Mobile"));
		addBehavior(CMClass.getBehavior("CombatAbilities"));
		
</pre>
<P><FONT size=4></FONT>
<P><FONT size=4>The commands above will 
make the MOB permanently Berzerk, gives it the ability to Poison folks while in 
combat, allows the MOB to Chat with other players, and&nbsp;to walk around 
in its area. The last behavior 
gives the MOB the wisdom to use its Poison ability while in 
combat.</FONT></P>
<P><FONT size=4>If your MOB extends 
<STRONG>StdShopKeeper</STRONG>    , you will need to add your inventory manually.  You will also
need to specify the type of ShopKeeper.
</FONT></P>
<pre>
		setWhatIsSold(ShopKeeper.ONLYBASEINVENTORY);
		
		Weapon sword=(Weapon)CMClass.getWeapon("Longsword");
		addStoreInventory(sword,35);
		Armor mail=(Armor)CMClass.getArmor("FullPlate");
		addStoreInventory(mail,35);
		Item waterskin=(Item)CMClass.getItem("Waterskin");
		addStoreInventory(waterskin,35);
</pre>
<P><FONT size=4>You'll recall from the Archon's Guide that there are many different types of ShopKeepers, 
including trainers, pet sellers, weaponsmiths, and others. </FONT>
<P><FONT size=4><STRONG>StdRideable</STRONG> MOBs will require a few other settings as well!</FONT></P>
<pre>
		setRideBasis(Rideable.RIDEABLE_LAND);
		setMobCapacity(2);
</pre>
<P><FONT size=4>The last thing is to give the MOB equipment, 
armor, and weapons.&nbsp; The following commands will do the trick!</FONT></P>
<pre>
		Weapon sword=(Weapon)CMClass.getWeapon("Longsword");
		addInventory(sword);
		sword.wearIfPossible(this);
		
		Armor mail=(Armor)CMClass.getArmor("FullPlate");
		addInventory(mail);
		mail.wearIfPossible(this);
		
		Item waterskin=(Item)CMClass.getItem("Waterskin");
		addInventory(waterskin);
</pre>
<P><FONT size=4>And THAT's all there is to creating a new MOB.  Easy, huh?  Well, obviously, the real complexity of MOBs
comes when the Behaviors and Abilities are programmed, but that is not covered here, of course.</FONT>
<P><FONT size=4 color=mediumslateblue><STRONG>Bringing MOBs to Life, and Taking That Life 
Away:</STRONG></FONT></P>
<P><FONT color=black size=4>The 
following instructions are supplemental, and unnecessary. Once  you have created your new MOB, modified your INI file, and
rebooted your CoffeeMud server, you need only use the CREATE and other Archon commands to make use of him. If, 
for some reason, you want to know HOW these commands do their work, however, here it is.</FONT></P>
<P><FONT color=black size=4>To bring a MOB into existence, a MOB must have 
somewhere to exist!&nbsp; Presumably, this is some room on your map.&nbsp; Rooms 
on the map are classes which implement the interface "Room".&nbsp; If a MOB is 
to have a permanent existence, it must also have a starting room, or a place to 
rejuvinate into when necessary.&nbsp; If a MOB does not have a starting room, 
then its death, when that death comes, &nbsp;will be forever.</FONT></P>
<pre>
	MOB mob=CMClass.getMOB("MyNewMOB");
	Room room=CMMap.getRoom("Midgaard#3504");
	
	mob.setStartRoom(room); // this mob will rejuvinate into this room.
	mob.baseEnvStats().setRejuv(500); // 30 minutes rejuvination time
	mob.recoverEnvStats(); // remember this command?!
	
	mob.bringToLife(room); // tadah!
</pre>
<P><FONT size=4>And THAT's all there is to bring a mob to life.  Of course, you may want to save this room to the
database to REALLY make the situation permanent, but all of this is usually done from inside CoffeeMud using the
CREATE, MODIFY, and DESTROY commands anyway.  Speaking of destroy, destroying one for good is even easier:</FONT>
<pre>
	Room room=CMMap.getRoom("Midgaard#3504");
	for(int i=0;i&lt;room.numInhabitants();i++)
	{
		MOB mob=room.fetchInhabitant(i);
		mob.destroy();
	}
</pre><PRE>
</PRE><P><P>
<P align=left><FONT size=5><STRONG>
<IMG src="images/sword.jpg">
</STRONG><FONT 
size=3>&nbsp;</FONT></FONT></P>
<P align=left><FONT size=5 color=crimson><STRONG>Items:</STRONG></FONT></P><FONT size=4>
<P align=left><FONT size=4>A Custom MOB may or may not belong to any particular 
package, though it is important that the NAME of the MOB be unique in the 
system.&nbsp; A custom MOB must import the following packages:</FONT></P>
<FONT size=3><PRE>	import java.util.*;
	import com.planet_ink.coffee_mud.utils.*;
	import com.planet_ink.coffee_mud.interfaces.*;
	import com.planet_ink.coffee_mud.Items.*;
	import com.planet_ink.coffee_mud.Items.Armor.*;
	import com.planet_ink.coffee_mud.Items.Weapons.*;
	import com.planet_ink.coffee_mud.Items.MiscMagic.*;
	import com.planet_ink.coffee_mud.common.*;</FONT> 
 </PRE></FONT>
<P><FONT size=4>As well as any other java.*,&nbsp;&nbsp;sun.*, 
or&nbsp;custom&nbsp;packages you may need.&nbsp; No other packages in the 
CoffeeMud system should be imported, other than those listed.</FONT> 
<P><FONT size=4>An Item&nbsp;class must 
extend either <STRONG>StdItem</STRONG> or GenItem, <STRONG>StdWeapon</STRONG> or 
GenWeapon, <STRONG>StdRideable</STRONG> or GenRideable, 
<STRONG>StdArmor</STRONG>           
    or GenArmor&nbsp;depending on the basic 
capabilities, and customizability&nbsp;you would like.&nbsp; Although Generic 
objects are more customizable at run-time, they also take a long time for the 
system to load and build, and take up a lot of database disk space.&nbsp; For 
this reason, using Standard instead of Generic whereever possible is always 
good.&nbsp; </FONT>
<P><FONT size=4>Each MOB must also have a custom "newInstance" method as shown 
below.</FONT><PRE>public class MyNewSword extends StdWeapon <BR>{ <BR>	public MyNewWeapon() <BR>	{ <BR>		super(); <BR>	}</PRE><PRE>	public Environmental newInstance() <BR>	{ <BR>		return new MyNewWeapon(); <BR>	} <BR>}</PRE>
<P><FONT size=4>All of your customizing will be done inside the constructor: name, displayText, description, etc, 
etc.</FONT>
<P><FONT size=4></FONT>&nbsp;</P>
<pre>	
	public MyNewWeapon()
	{
		super();

		Username=	
	 
	
		

		"asuper sword"; setDescription("A
		long super duper sword!"); setDisplayText("Someone 
		left their super sword here."); setSecretIdentity(description());
		setMaterial(EnvResource.RESOURCE_STEEL);
		
		setBaseValue(500);
		baseEnvStats().setDisposition(EnvStats.IS_GLOWING);
		baseEnvStats.setWeight(25);
		baseEnvStats.setAttackAdjustment(10);
		baseEnvStats.setDamage(15);
		recoverEnvStats();
	}
	
</pre>
<P><FONT size=4></FONT>&nbsp;</P>
<P><FONT size=4>What is shown above is 
entirely sufficient for the creation of a <STRONG>StdWeapon</STRONG> . The material, weight, attack and damage 
describe it completely. You'll even notice that            by  setting a disposition flag,
we have made the sword  glow!&nbsp;&nbsp;Now, what if we wanted a missile weapon?</FONT>
<P><FONT size=4></FONT>&nbsp;</P>
<pre>	
	public MyNewBow()
	{
		super();

		Username="a super bow";
		setDescription("A long super duper bow!"); 
		setDisplayText("Someone left their super bow here.");
		setSecretIdentity(description());
		
		setMaterial(EnvResource.RESOURCE_OAK);
		setBaseValue(5000);
		baseEnvStats.setWeight(15);
		baseEnvStats.setAttackAdjustment(20);
		baseEnvStats.setDamage(5);
		setRanges(1,5);
		setAmmunitionType("arrows");
		recoverEnvStats();
	}
	
</pre>
<P><FONT size=4></FONT>&nbsp;</P>
<P><FONT size=4>You'll notice we added 
two new mathods, setRanges, and setAmmunitionType. With the former, we specify 
that this is a ranged-only weapon, usable from range 1 (0=melee) to range 5. The 
ammunition type specifies that it uses arrows. Other classes, however, have 
different requirements altogether. For instance, 
<STRONG>StdArmor</STRONG>     
            
     :</FONT>
<P><FONT size=4></FONT>&nbsp;</P>
<pre>	
	public MyNewArmor()
	{
		super();

		Username="a super bracer";
		setDescription("A super duper bracer"); 
		setDisplayText("Someone left their super bracer here.");
		setSecretIdentity(description());
		
		setMaterial(EnvResource.RESOURCE_STEEL);
		setBaseValue(100);
		baseEnvStats.setWeight(5);
		baseEnvStats.setArmor(5);
		setRawProperLocationBitmap(Item.ON_LEFT_WRIST|Item.ON_RIGHT_WRIST);
		setRawLogicalAnd(false);
		recoverEnvStats();
	}
	
</pre>
<P><FONT size=4></FONT>&nbsp;</P>
<P><FONT size=4>In this case, we made a 
bracer wearable on both left and right wrists. If it were something that could 
only be worn on both wrists at the same time (like handcuffs), then the 
RawLogicalAnd value would have been true. Now, a 
<STRONG>StdContainer</STRONG>                   
                   
    :</FONT>
<P><FONT size=4></FONT>&nbsp;</P>
<pre>	
	public MyNewBag()
	{
		super();

		Username="a super bag";
		setDescription("A super duper bag"); 
		setDisplayText("Someone left their super bag here.");
		setSecretIdentity(description());
		
		setBaseValue(50);
		setLidsNLocks(false,true,false,false);
		setKeyName("");
		setMaterial(EnvResource.RESOURCE_LEATHER);
		baseEnvStats.setWeight(1);
		setCapacity(100);
		recoverEnvStats();
	}
</pre>
<P><FONT size=4></FONT>&nbsp;</P>
<P><FONT size=4>When setting the 
capacity of a container, remember that it must also be able to hold its own 
weight! Also, note the lids and locks flags have made this container lidless and 
lockless and always open.&nbsp; Of course, without a lock, setting a key would 
be silly!&nbsp; Now, a <STRONG>StdDrink</STRONG>   
               
                           
     container:</FONT>
<P><FONT size=4></FONT>&nbsp;</P>
<pre>	
	public MyNewCup()
	{
		super();

		Username="a super cup";
		setDescription("A super duper cup"); 
		setDisplayText("Someone left their super bag here.");
		setSecretIdentity(description());
		
		setMaterial(EnvResource.RESOURCE_LEATHER);
		setBaseValue(5);
		setLiquidHeld(2000);
		setLiquidRemaining(2000);
		setThirstQuenched(500);
		setLiquidType(EnvResource.RESOURCE_MILK);
		baseEnvStats.setWeight(1);
		setCapacity(0);
		recoverEnvStats();
	}
</pre>
<P><FONT size=4></FONT>&nbsp;</P>
<P><FONT size=4>The 
<STRONG>StdDrink</STRONG> created above is an enormous cup of milk! You'll 
notice the capacity is 0, meaning that mundane objects cannot be stored in it. 
Now, a <STRONG>StdFood</STRONG>                  
           :</FONT>
<P><FONT size=4></FONT>&nbsp;</P>
<pre>	
	public MyNewFood()
	{
		super();

		Username="a super crumb";
		setDescription("A super duper crumb");
		setDisplayText("Someone left their super crumbs.");
		setSecretIdentity(description());
		
		setBaseValue(1);
		setMaterial(EnvResource.RESOURCE_MEAT);
		setNourishment(500);
		baseEnvStats.setWeight(1);
		recoverEnvStats();
	}
</pre>
<P><FONT size=4></FONT>&nbsp;</P>
<P><FONT size=4>Now, the 
<STRONG>StdRideable</STRONG>   resembles the MOB of the same name, and thus, has identical modifications.</FONT>
<P><FONT size=4></FONT>&nbsp;</P>
<pre>	
	public MyNewBed()
	{
		super();

		Username="a bed";
		setDescription("A bed");
		setDisplayText("A bed is here");
		setSecretIdentity(description());
		
		setBaseValue(100);
		setMobCapacity(2);
		setRideBasis(Rideable.RIDEABLE_SLEEP);
		baseEnvStats.setWeight(100);
		recoverEnvStats();
	}
</pre>
<P><FONT size=4></FONT>&nbsp;</P>
<P><FONT size=4>A pile of money, aka 
<STRONG>StdCoins</STRONG>     , is simplest of all:</FONT>
<P><FONT size=4></FONT>&nbsp;</P>
<pre>	
	public MyNewMoney()
	{
		super();

		Username="a pile of coins";
		setDescription("A pile of coins");
		setDisplayText("Someone left their money here.");
		setSecretIdentity(description());
		
		setBaseValue(0);
		setMaterial(EnvResource.RESOURCE_GOLD);
		baseEnvstats.setAbility(1000); // 1000 coins!
		baseEnvStats.setWeight(1);
		recoverEnvStats();
	}
</pre>
<P><FONT size=4></FONT>&nbsp;</P>
<P><FONT size=4>    Notice that the base 
value of the coins is 0, it's the Ability score that does all the work.&nbsp; 
Now, to a magical <STRONG>StdPill</STRONG>                  
           :</FONT>
<P><FONT size=4></FONT>&nbsp;</P>
<pre>	
	public MyNewPill()
	{
		super();

		Username="a super pill";
		setDescription("A super duper pill");
		setDisplayText("Someone left their super pill.");
		setSecretIdentity("");
		
		setBaseValue(1);
		setMaterial(EnvResource.RESOURCE_MEAT);
		setNourishment(500);
		baseEnvStats.setWeight(1);
		setSpellList("Spell_Sleep;Prayer_CureLightWounds");
		recoverEnvStats();
	}
</pre>
<P><FONT size=4></FONT>&nbsp;</P>
<P><FONT size=4>The spells cast on the 
eater are listed by their Class names, seperated by semicolons. The secret 
identity is also trimmed out, since the system will handle that automatically. 
Also notice that the <STRONG>StdPill</STRONG> resembles <STRONG>StdFood</STRONG> 
except for the addition of the setSpellList method. In the exact same way, the 
<STRONG>StdPotion</STRONG> class resembles the <STRONG>StdDrink</STRONG> class 
except that it has an identical setSpellList method added to IT. So, in the 
interests of saving a little sand for future generations, I would enumerate the 
<STRONG>StdPotion</STRONG>. We can, however, show off a 
<STRONG>StdScroll</STRONG>            
              
             
              
               
              
        :</FONT>
<P><FONT size=4></FONT>&nbsp;</P>
<pre>	
	public MyNewScroll()
	{
		super();

		Username="a super scroll";
		setDescription("A super duper scroll");
		setDisplayText("Someone left their super scroll.");
		setSecretIdentity("");
		
		setBaseValue(100);
		setMaterial(EnvResource.RESOURCE_PAPER);
		baseEnvStats.setWeight(1);
		setScrollSpells("Spell_Sleep;Prayer_CureLightWounds");
		recoverEnvStats();
	}
</pre>
<P><FONT size=4></FONT>&nbsp;</P>
<P><FONT size=4>Not too difficult, 
right? Looks like the other two, but the spell setting method has a different 
name. Now, let's look at a <STRONG>StdWand</STRONG>             
           :</FONT>
<P><FONT size=4></FONT>&nbsp;</P>
<pre>	
	public MyNewWand()
	{
		super();

		Username="a wand";
		setDescription("A magic wand");
		setDisplayText("Someone left their magic wand.");
		setSecretIdentity("");
		
		setBaseValue(1000);
		setMaterial(EnvResource.RESOURCE_OAK);
		baseEnvStats.setWeight(1);
		setSpell(CMClass.getAbility("Spell_Fireball"));
		setUsesRemaining(50);
		recoverEnvStats();
	}
</pre>
<P><FONT size=4></FONT>&nbsp;</P>
<P><FONT size=4>In this case, we made 
use of the "uses remaining" field to set the number of charges for the wand. The 
way the spell is set is also different. A wand may only have one spell, and the 
actual Ability object for the spell must be passed in, instead of just the class 
name as we did before. You will find that this is also how the 
<STRONG>StdStaff</STRONG> works. The <STRONG>StdStaff</STRONG> resembles the 
<STRONG>StdWeapon</STRONG>              
                    
                
                   
       we did above, except that the additional
setSpell and setUsesRemaining calls become appropriate to the constructor.  </FONT>
<P><FONT size=4>The next thing we will look at is adding 
affects and behaviors to Items.&nbsp; Behavior addition (despite the fact that 
there is really only one behavior that works with Items) will look familiar.  The only
difference between this and the MOB example above is the fact that we are setting a
parameter on the Behavior before adding it. 
</FONT>
<P><FONT size=4></FONT>&nbsp;</P>
<pre>	
		Behavior B=CMClass.getBehavior("Mobile");
		B.setParms("min=1 max=20 chance=75/makes strange sounds");
		addBehavior(B);
		
</pre>
<P><FONT size=4></FONT>&nbsp;</P>
<P><FONT size=4>Adding normal affects as properties is also similar to mobs...</FONT>
<P><FONT size=4></FONT>&nbsp;</P>
<pre>	
		Ability A=CMClass.getAbility("Prop_HaveResister");
		A.setMiscText("fire acid 50%");
		A.addNonUninvokableAffect(A);
</pre>
<P><FONT size=4></FONT>&nbsp;</P>
<P><FONT size=4>The above affect will allow anyone who owns the item to
resist fire and acid at 50%!</FONT></P>
</BODY>
</HTML>
