<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
                                   
  <meta name="GENERATOR" content="Microsoft Visual Studio 6.0">
  <title></title>
</head>
  <body style="background-color: rgb(255,255,255); color: rgb(0,0,0);"
 link="#0000ee" alink="#0000ee" vlink="#551a8b">
                 
<p align="center"><strong><font size="6">Programming</font></strong></p>
                 
<p align="center"><strong><font size="6">for CoffeeMud 5.1</font></strong></p>
                 
<p align="left">         
<table width="100%" bgcolor="yellow" border="1">
           <tbody>
             <tr>
               <td bgcolor="lightgreen"> <font color="black"><b>Quick Reference:</b></font> 
          </td>
               <td> <a href="#BUILD"><font color="black" size="-1"><b>Rebuilding</b></font></a> 
          </td>
               <td><a href="#JSCRIPTS"><font color="black" size="-1"><b>JavaScripting</b></font></a> 
          </td>
               <td> <a href="#DIG1"><font color="black" size="-1"><b>Core 
Topic    1: Message Passing</b></font></a> </td>
               <td> <a href="#DIG2"><font color="black" size="-1"><b>Core 
Topic    2: State Layers</b></font></a> </td>
               <td> <a href="#DIG3"><font color="black" size="-1"><b>Core 
Topic    3: Threading</b></font></a> </td>
             </tr>
             <tr>
               <td> <a href="#DIG3"><font color="black" size="-1"><b>Core 
Topic    4: Core Libraries</b></font></a> </td>
               <td> <a href="#TEXT"><font color="black" size="-1"><b>Text</b></font></a> 
          </td>
               <td> <a href="#CMDS"><font color="black" size="-1"><b>Commands</b></font></a> 
          </td>
               <td> <a href="#MOBS"><font color="black" size="-1"><b>MOBs</b></font></a> 
          </td>
               <td> <a href="#ITEMS"><font color="black" size="-1"><b>Items</b></font></a> 
          </td>
               <td> <a href="#BEHAVS"><font color="black" size="-1"><b>Behaviors</b></font></a> 
          </td>
             </tr>
             <tr>
               <td> <a href="#CLASSES"><font color="black" size="-1"><b>Character 
    Classes</b></font></a> </td>
               <td> <a href="#RACES"><font color="black" size="-1"><b>Races</b></font></a> 
          </td>
               <td><a href="#EXITS"><font color="black" size="-1"><b>Exits</b></font></a> 
          </td>
               <td><a href="#ROOMS"><font color="black" size="-1"><b>Rooms</b></font></a> 
          </td>
               <td><a href="#AREAS"><font color="black" size="-1"><b>Areas</b></font></a> 
          </td>
               <td><a href="#PROPS"><font color="black" size="-1"><b>Properties</b></font></a> 
          </td>
             </tr>
             <tr>
               <td><a href="#SKILLS"><font color="black" size="-1"><b>Skills</b></font></a> 
          </td>
               <td><a href="#SPELLS"><font color="black" size="-1"><b>Spells</b></font></a> 
          </td>
               <td><a href="#SONGS"><font color="black" size="-1"><b>Songs</b></font></a> 
          </td>
               <td><a href="#COMMON"><font color="black" size="-1"><b>Common
  Skills</b></font></a>         </td>
               <td><a href="#POISON"><font color="black" size="-1"><b>Poisons</b></font></a> 
          </td>
               <td><a href="#DISEASE"><font color="black" size="-1"><b>Diseases</b></font></a> 
          </td>
             </tr>
             <tr>
               <td><a href="#TRAPS"><font color="black" size="-1"><b>Traps
 &amp;   Bombs</b></font></a>       </td>
               <td><a href="#LANGS"><font color="black" size="-1"><b>Languages</b></font></a> 
          </td>
             </tr>
                                   
  </tbody>         
</table>
         </p>
                 
<p align="left"><font size="5"><strong><img src="images/mug.jpg">
         </strong><font size="3">&nbsp;</font></font></p>
                 
<p align="left"><font color="limegreen" size="5"><strong>Overview:</strong></font></p>
                 
<p align="left"><font size="4">The purpose of this document is to assist
those who wish to add custom Items, MOBs, Behaviors, Properties, or other
objects to CoffeeMud.&nbsp; The reader should be familiar with Java programming,
and should be experienced with writing and compiling Java classes.&nbsp;
The object oriented notions of class inheretance and&nbsp;polymorphism, as
well as the Java constructs of interfaces should be at least vaguely familiar
to you before attempting to build classes for CoffeeMud.&nbsp; Also, it is
expected that all of the ideas presented in the Archons Guide (ArchonGuide.html)
are completely familiar.&nbsp; The difference between a GenItem and a StdItem,
    or a GenMob and a GenPostman will not be explained in this document.</font></p>
                 
<p align="left"><font size="4">It is not expected that someone would wish
    to dive in and make wholesale changes to the CoffeeMud system right away,
    but is more likely wanting to fill in a functional gap in the system
for    their own needs.&nbsp; For this reason, this document is not organized
as   a comprehensive guide to programming CoffeeMud.&nbsp; Instead, it is
designed   to be a quick reference for those who wish to create the spot
MOB, Behavior,   Item, or Property for use on their maps.</font></p>
                 
<p align="left"><font size="4">With this in mind then, let's start out with
    some brief development instructions, and then and in no particular order,
    discuss the several essential object types in CoffeeMud are presented.</font></p>
                 
<p align="left"><font size="4"><img src="images/sprockets.jpg">
         <font size="3"> </font></font></p>
                 
<p align="left"><font size="4"><a name="BUILD"><font size="5"><strong>Rebuilding 
    CoffeeMud:</strong></font></a></font></p>
                 
<p><font size="4">In Microsoft Windows:</font></p>
                 
<ul>
           <font size="4"> <li>Go to your coffeemud directory and edit the
 make.bat,    the first line will be something like: SET JAVACPATH= C:\jdk1.5.0_05\bin\javac
    This might be different for you depending on where your java development
   package is installed.&nbsp; </li>
           <li>Save the bat file. </li>
           <li>Run the bat file by double clicking on it. This will compile 
 the   mud, making all the .class files.</li>
           </font>         
</ul>
                 
<p><font size="4">In Unix:</font></p>
                 
<ul>
           <font size="4"> <li>Go to your coffeemud directory and edit the
 makeUNIX.sh,    the first line will be something like: Java_Home=/home/knoppix/j2sdk1.4.2&nbsp;
    This might be different for you depending on where your java development
   package is installed.&nbsp; </li>
           <li>Save the shell script. </li>
           <li>Issue this command: chmod 755 makeUNIX.sh </li>
           <li>Execute&nbsp;the shell script. This will compile the mud,
making    all the .class files.</li>
           </font>         
</ul>
                 
<p><font size="4"><strong>Introducing External Components:</strong></font></p>
                 
<p><font size="4">If you perused the coffeemud.ini file as mentioned in the
    Installation Guide, you may have noticed and wondered about the section
  at  the end which&nbsp;lists the default load paths for the several CoffeeMud
    objects.</font></p>
                 
<p><font size="4">By default, the CoffeeMud engine dynamically loads the
vast majority of its object code at boot time by referring to the paths specified
    in the coffeemud.ini file.&nbsp; The value %DEFAULT% is always used as
 a  substitute for the default CoffeeMud object path.&nbsp; For instance,
if you installed CoffeeMud at "C:\CoffeeMud\", then "BEHAVIORS=%DEFAULT%"
in the ini file would load "C:\CoffeeMud\com\planet_ink\coffee_mud\Behaviors\*.class"
   into its behavior set.</font></p>
                 
<p><font size="4">This default object boot paths may be removed&nbsp;or&nbsp;added-to
    using semicolon delimited paths, or even replaced with your own object
 boot   directories.&nbsp; In fact, when adding objects to your CoffeeMud
boot sequence,   it is recommended that you place your objects in a separate
directory path   inside your CoffeeMud folder and add its path to the coffeemud.ini
  file under  the proper setting.&nbsp; The order in which you place multiple
  paths in a single entry is also significant, as the CoffeeMud ClassLoader
  will load the files in the order in which they appear listed.&nbsp; For
instance:</font></p>
                 
<p><font size="4">MOBS=%DEFAULT%;/resources/examples/MyClass.class;/resources/otherclasses</font></p>
                 
<p><font size="4">Will cause the default CoffeeMud versions of the mob classes
    to be loaded first, followed by MyClass.class, followed by all the class
   files in the resources/otherclasses folder in your CoffeeMud package.&nbsp;
   Also notice that the ClassLoader follows the rules of the CMFS described
  in the Archons Guide, meaning that the forward slash is always the proper
  path separator, and that no folder outside of your CoffeeMud package may
 be referenced.&nbsp; Also bear in mind that case is sensitive when naming
 Java class files, even in these boot paths.</font></p>
                 
<p><font size="4">When writing these custom classes for your special object
    boot directory(s), it is important to keep a number of things in mind.</font></p>
                 
<p><font size="4">1. Do not mix your object types in the same directory!
Never try to boot custom items from the same directory&nbsp;from which you
boot your custom mobs.&nbsp; It will only confuse you and CoffeeMud.</font></p>
                 
<p><font size="4">2. Java Packaging is irrelevant, you may package your classes
    or not.</font></p>
                 
<p><font size="4">3. Implement or extend a class that implements the proper
    interfaces.&nbsp; If you are coding mobs, this would mean the MOB interface.&nbsp;
    If you are coding locales, the Room interface, etc, etc.&nbsp; See the
 section   on the object type you are coding for the proper interface to
implement.&nbsp;     You may get around this requirement by extending one
of the base classes,     such as StdItem, StdMOB, StdContainer, StdRoom,
StdAbility, GenMob, GenItem,     GenContainer, etc.</font></p>
                 
<p><font size="4">4. Make sure the ID() method in your classes always matches
    the name of your class.&nbsp; You will understand this better as you
reference     the object sections below.</font></p>
                 
<p><font size="4">5. Try to make the name() methods in your classes return
    name values unique among all objects, especially objects of that type.&nbsp;
    This is not a hard fast rule,&nbsp;and breaking it will not cause malfunction
    in the system, but breaking this rule WILL make writing help files impossible.</font></p>
                 
<p><font size="4">6. Class files loaded directly in the CoffeeMud classpath
    can not be reloaded at run-time using the UNLOAD and LOAD commands. &nbsp;If
    you plan on making changes to your classes during run-time, place them
 in   their own directories.</font></p>
                 
<p><font size="4">7. As a general rule, you may import any "interfaces.*"
    packages in the base CoffeeMud structure, any core Java packages, the
CoffeeMud    "core.*" package, and any single base CoffeeMud class you may
be extending.&nbsp;&nbsp;Do    not import more than that.&nbsp; Use the CMClass
getter methods if you need   to create new instances of CoffeeMud classes,
and use the CMLib methods  to  access her code libraries. &nbsp;<br>
         </font></p>
                 
<p><font color="#990000"><b><big><font size="4"><big><a name="IMPORTS"></a>Complete 
    Default Import List:</big></font></big></b></font></p>
                 
<p><font size="4" color="#990000"> </font><font color="#ff6666"><font
 color="#990000">import com.planet_ink.coffee_mud.core.*;<br>
         import com.planet_ink.coffee_mud.core.interfaces.*;<br>
         import com.planet_ink.coffee_mud.Abilities.interfaces.*;<br>
         import com.planet_ink.coffee_mud.Areas.interfaces.*;<br>
         import com.planet_ink.coffee_mud.Behaviors.interfaces.*;<br>
         import com.planet_ink.coffee_mud.CharClasses.interfaces.*;<br>
         import com.planet_ink.coffee_mud.Commands.interfaces.*;<br>
         import com.planet_ink.coffee_mud.Common.interfaces.*;<br>
         import com.planet_ink.coffee_mud.Exits.interfaces.*;<br>
         import com.planet_ink.coffee_mud.Items.interfaces.*;<br>
         import com.planet_ink.coffee_mud.Locales.interfaces.*;<br>
         import com.planet_ink.coffee_mud.MOBS.interfaces.*;<br>
         import com.planet_ink.coffee_mud.Races.interfaces.*;<br>
         import com.planet_ink.coffee_mud.Libraries.interfaces.*;<br>
         import java.io.IOException;<br>
         import java.util.*</font>;</font><br>
         </p>
         <img src="images/rainbow.jpg">
                 
<p align="left"><a name="TEXT"><font color="gray" size="5"><strong>Text:</strong></font></a></p>
                 
<p align="left"><font size="4">Before we get started with objects, needs
must the topic of text display be covered. Throughout the system you will
see text being sent to the user. Since a mud is a text producing engine,
this should be no great surprise. However, within that text you will often
see different kinds of codes and tags which affect the output. For instance,
consider the following lines:</font></p>
                 
<pre>msg=CMClass.newMsg(mob,target,this,affectType,"&lt;S-NAME&gt; reach(es) for &lt;T-NAMESELF&gt;.");<br>mob.location().show(mob,null,CMMsg.MSG_OK_ACTION,<br>				"&lt;S-NAME&gt; regain(s) &lt;S-HIS-HER&gt; feet.");<br></pre>
                 
<p align="left"><font size="4">Focusing only on the text for a moment, you
    will notice that special tags are used to designate a player name, or
the    name of the target of a spell. You will also notice that (s) and (es)
is   used to modify the proper form of a verb. These are key features of
the CoffeeMud   text engine. Here is a more complete list of available tage:</font>&nbsp;</p>
                 
<table width="100%" border="1" bgcolor="#ffffcc">
           <tbody>
             <tr>
               <td width="20%"><big><tt><b>&lt;S-HIS-HER&gt;</b></tt></big></td>
               <td>Outputs 'Your' if Observer=Source, otherwise 'His'/'Her'.</td>
             </tr>
             <tr>
               <td width="20%"><big><tt><b>&lt;S-HIM-HER&gt;</b></tt></big></td>
               <td>Outputs 'You' if Observer=Source, otherwise 'Him'/'Her'.</td>
             </tr>
             <tr>
               <td width="20%"><big><tt><b>&lt;S-NAME&gt;</b></tt></big></td>
               <td>Outputs 'You' if Observer=Source, otherwise the Name.</td>
             </tr>
             <tr>
               <td width="20%"><big><tt><b>&lt;S-NAMESELF&gt;</b></tt></big></td>
               <td>Outputs 'Yourself' if Observer=Source, otherwise the Name</td>
             </tr>
             <tr>
               <td width="20%"><big><tt><b>&lt;S-NAMENOART&gt;</b></tt></big></td>
               <td>Outputs 'You' if Observer=Source, otherwise the Name minus 
  any  prefix articles (a, an, some, etc..).</td>
             </tr>
             <tr>
               <td width="20%"><big><tt><b>&lt;S-HE-SHE&gt;</b></tt></big></td>
               <td>Outputs 'You' if Observer=Source, otherwise 'He'/'She'</td>
             </tr>
             <tr>
               <td width="20%"><big><tt><b>&lt;S-SIRMADAM&gt;</b></tt></big></td>
               <td>Outputs 'Sir'/'Madam'</td>
             </tr>
             <tr>
               <td width="20%"><big><tt><b>&lt;S-IS-ARE&gt;</b></tt></big></td>
               <td>Outputs 'Are' if Observer=Source, otherwise 'Is'.</td>
             </tr>
             <tr>
               <td width="20%"><big><tt><b>&lt;S-HAS-HAVE&gt;</b></tt></big></td>
               <td>Outputs 'Have' if Observer=Source, otherwise 'Has'.</td>
             </tr>
             <tr>
               <td width="20%"><big><tt><b>&lt;S-YOUPOSS&gt;</b></tt></big></td>
               <td>Outputs 'Your' if Observer=Source, otherwise the Name`s</td>
             </tr>
             <tr>
               <td width="20%"><big><tt><b>&lt;S-HIM-HERSELF&gt;</b></tt></big></td>
               <td>Outputs 'Yourself' if Observer=Source, otherwise the 'Himself'/'Herself'</td>
             </tr>
             <tr>
               <td width="20%"><big><tt><b>&lt;S-HIS-HERSELF&gt;</b></tt></big></td>
               <td>Outputs 'Yourself' if Observer=Source, otherwise the 'Hisself'/'Herself'</td>
             </tr>
             <tr>
               <td width="20%"><big><tt><b>&lt;T-HIS-HER&gt;</b></tt></big></td>
               <td>Outputs 'You' if Observer=Target, otherwise 'His'/'Her'.</td>
             </tr>
             <tr>
               <td width="20%"><big><tt><b>&lt;T-HIM-HER&gt;</b></tt></big></td>
               <td>Outputs 'You' if Observer=Target, otherwise 'Him'/'Her'.</td>
             </tr>
             <tr>
               <td width="20%"><big><tt><b>&lt;T-NAME&gt;</b></tt></big></td>
               <td>Outputs 'You' if Observer=Target, otherwise the Name.</td>
             </tr>
             <tr>
               <td width="20%"><big><tt><b>&lt;T-NAMESELF&gt;</b></tt></big></td>
               <td>Outputs 'Yourself' if Observer=Target, otherwise the Name</td>
             </tr>
             <tr>
               <td width="20%"><big><tt><b>&lt;T-NAMENOART&gt;</b></tt></big></td>
               <td>Outputs 'You' if Observer=Target, otherwise the Name minus 
  any  prefix articles (a, an, some, etc..).</td>
             </tr>
             <tr>
               <td width="20%"><big><tt><b>&lt;T-HE-SHE&gt;</b></tt></big></td>
               <td>Outputs 'You' if Observer=Target, otherwise 'He'/'She'</td>
             </tr>
             <tr>
               <td width="20%"><big><tt><b>&lt;T-SIRMADAM&gt;</b></tt></big></td>
               <td>Outputs 'Sir'/'Madam'</td>
             </tr>
             <tr>
               <td width="20%"><big><tt><b>&lt;T-IS-ARE&gt;</b></tt></big></td>
               <td>Outputs 'Are' if Observer=Target, otherwise 'Is'.</td>
             </tr>
             <tr>
               <td width="20%"><big><tt><b>&lt;T-HAS-HAVE&gt;</b></tt></big></td>
               <td>Outputs 'Have' if Observer=Target, otherwise 'Has'.</td>
             </tr>
             <tr>
               <td width="20%"><big><tt><b>&lt;T-YOUPOSS&gt;</b></tt></big></td>
               <td>Outputs 'Your' if Observer=Target, otherwise the Name
with   an  '`s'</td>
             </tr>
             <tr>
               <td width="20%"><big><tt><b>&lt;T-HIM-HERSELF&gt;</b></tt></big></td>
               <td>Outputs 'Yourself' if Observer=Source, otherwise the 'Himself'/'Herself'</td>
             </tr>
             <tr>
               <td width="20%"><big><tt><b>&lt;T-HIS-HERSELF&gt;</b></tt></big></td>
               <td>Outputs 'Yourself' if Observer=Source, otherwise the 'Hisself'/'Herself'</td>
             </tr>
                                   
  </tbody>         
</table>
                 
<p align="left"><font size="4">Occasionally, you will find color/font codes
    embedded in system strings. For instance: </font>&nbsp;</p>
                 
<pre>			msg.append("^!You are thirsty.^?\n\r");<br></pre>
                 
<p align="left"><font size="4">These codes are as follows: </font>&nbsp;</p>
                 
<table width="50%" border="1" bgcolor="#ccffff">
           <tbody>
             <tr>
               <td width="10%"><big><tt><b>^N</b></tt></big></td>
               <td>Normal</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^!</b></tt></big></td>
               <td>Bold</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^H</b></tt></big></td>
               <td>Highlight</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^_</b></tt></big></td>
               <td>Underline</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^*</b></tt></big></td>
               <td>Blink</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^/</b></tt></big></td>
               <td>Italics</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^.</b></tt></big></td>
               <td>Reset (turns off reverse)</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^^</b></tt></big></td>
               <td>Generates an untranslated "^" character</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^?</b></tt></big></td>
               <td>Restores previous color</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^f</b></tt></big></td>
               <td>You-Fight</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^e</b></tt></big></td>
               <td>Fight-You</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^F</b></tt></big></td>
               <td>Fight</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^S</b></tt></big></td>
               <td>Spell</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^E</b></tt></big></td>
               <td>Emote</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^T</b></tt></big></td>
               <td>Talk</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^Q</b></tt></big></td>
               <td>Channel Background</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^q</b></tt></big></td>
               <td>Channel Foreground</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^x</b></tt></big></td>
               <td>Important message 1</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^X</b></tt></big></td>
               <td>Important message 2</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^Z</b></tt></big></td>
               <td>Important message 3</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^O</b></tt></big></td>
               <td>Room Title</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^L</b></tt></big></td>
               <td>Room Description</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^J</b></tt></big></td>
               <td>Weather</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^D</b></tt></big></td>
               <td>Direction</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^d</b></tt></big></td>
               <td>Door</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^I</b></tt></big></td>
               <td>Item</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^M</b></tt></big></td>
               <td>MOB</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^U</b></tt></big></td>
               <td>Unexplored Direction</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^u</b></tt></big></td>
               <td>Unexplored Door</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^w</b></tt></big></td>
               <td>White</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^g</b></tt></big></td>
               <td>Green</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^b</b></tt></big></td>
               <td>Blue</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^r</b></tt></big></td>
               <td>Red</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^y</b></tt></big></td>
               <td>Yellow</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^c</b></tt></big></td>
               <td>Cyan</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^p</b></tt></big></td>
               <td>Purple</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^W</b></tt></big></td>
               <td>Dark White</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^G</b></tt></big></td>
               <td>Dark Green</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^B</b></tt></big></td>
               <td>Dark Blue</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^R</b></tt></big></td>
               <td>Dark Red</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^Y</b></tt></big></td>
               <td>Dark Yellow</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^C</b></tt></big></td>
               <td>Dark Cyan</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^P</b></tt></big></td>
               <td>Dark Purple</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^&lt;</b></tt></big></td>
               <td>&lt; character. Used for MXP tags only.</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^&gt;</b></tt></big></td>
               <td>&gt; character. Used for MXP tags only.</td>
             </tr>
             <tr>
               <td width="10%"><big><tt><b>^&amp;</b></tt></big></td>
               <td>&amp; character. Used for MXP tags only.</td>
             </tr>
                                   
  </tbody>         
</table>
                 
<p align="left"><font size="4">As you might have guessed, it is preferred
    that the system colors (the last 16 codes) be used sparingly, in favor
 of   the more customizable codes above. </font>&nbsp; </p>
         <img src="images/mozilla.jpg">
                 
<p align="left"><font color="blue" size="5"><strong>JavaScripting:</strong></font> 
    </p>
                 
<p align="left"><font size="4">JavaScript is an interpreted scripting language
    which is used in various parts of CoffeeMud.&nbsp; The CoffeeMud engine
  integrates  the Rhino Javascript interpretor package from Mozilla in such
  places as the  Scriptable behavior, the JRun command, the ClassLoader,
the   Quest engine,  and the web server.</font></p>
                 
<p align="left"><font size="4">In lieu of a complete write up on the syntax
    of this language, it is suggested that you read the documentation available
    from the authors of the interpretor here:<strong> </strong></font><a
 href="http://www.mozilla.org/js/"><font size="4">http://www.mozilla.org/js/</font></a><font
 size="4">&nbsp; and </font><a href="http://www.mozilla.org/rhino/"><font
 size="4">http://www.mozilla.org/rhino/</font></a>&nbsp;<font size="4">.</font></p>
                 
<p align="left"><font size="4">If you are familiar with writing Javascript
    for web browsers, there are several differences you will need to adjust
  to  when using Javascript in CoffeeMud.&nbsp; </font><font size="4">A minor 
   difference&nbsp;is  that the Rhino interpretor requires that all variables 
   be declared before  use.&nbsp; A more important difference is that Javascript 
   Strings are not  the same as Java String objects, and that confusing them 
   can lead to errors.&nbsp;  To get around this problem, all of the implementations 
   of Javascript in Coffeemud, with the exception of the ClassLoader,&nbsp;provide 
   a special method to convert Javascript strings into Java Strings before 
 passing  them to Java methods or objects which will require them.&nbsp; An
 example  is below:</font></p>
                 
<p align="left"><font size="4"><font face="Courier New" size="2">var javascriptstring='
    this is a javascript string ';<br>
         </font></font><font size="4"><font face="Courier New" size="2">var 
 javastring=toJavaString(javascriptstring);<br>
         // and now javastring is a real-live Java-compliant and Java-friendly
   string</font></font></p>
                 
<p align="left"><font size="4">When writing Java classes in JavaScript, however,
    this method is only available through the CMLib object in the core package.&nbsp;
    This is how you would access the toJavaString() method from a class written
    in JavaScript:</font></p>
         <font size="4">         
<p align="left"><font size="4"><font face="Courier New" size="2">var javascriptstring='
    this is a javascript string ';<br>
         </font></font><font size="4"><font face="Courier New" size="2">var 
 javastring=Packages.com.planet_ink.coffee_mud.core.CMLib.toJavaString(javascriptstring);<br>
         // and now javastring is a real-live Java-compliant and Java-friendly
   string</font></font></p>
         </font>         
<p align="left"><font size="4">The most important difference between coding
    Javascript for CoffeeMud and for&nbsp;browsers&nbsp;is that there is
no   HTML  DOM (Document Object Model), and therefore several of the libraries
  you are  used to are probably missing, such as Math.&nbsp; For this reason,
  it is necessary for you to learn the CoffeeMud object packages&nbsp;in
order    to get access to useful data and useful libraries.&nbsp; And now
you understand    why the JavaScripting notes are kept in the Programming
guide. :)</font></p>
                 
<p align="left"><font size="4">To access the CoffeeMud object packages, you
    will need to make use of the Packages object&nbsp;to reference external
  packages.&nbsp;  So long as the imported objects are in your CoffeeMud
classpath,   they can  be accessed and used.&nbsp; For instance, to use the
CoffeeMud  pow(x,y)&nbsp;function  in CMParms.java:</font></p>
                 
<p align="left"><font face="Courier New" size="2">var lib=Packages.com.planet_ink.coffee_mud.core.CMLib;
    <br>
         // the above creates a reference to the CoffeeMud Library as a shortcut<br>
         var value=lib.math().pow(4,2);<br>
         // now we can access the math() library from our shortcut.</font></p>
                 
<p align="left"><font size="4">Depending upon the context from which your
    script runs (the Scriptable behavior, JRun command,&nbsp;the Quest engine,
    or&nbsp;the http/web server), certain other objects are made available
 to   assist scripts in properly interacting with their environment.&nbsp;
 When   writing Java classes in JavaScript for the ClassLoader, however,
you  must   always use the Packages.com.planet_ink.coffee_mud.core.CMLib
reference  to   access special methods such as the toJavaString method discussed
above.</font></p>
                 
<p align="left"><font size="4">In the Scriptable behavior, several methods
    are made available to access objects which are related to the event which
    triggered the scripted code.&nbsp; These methods include <font
 face="Courier New" size="2">MOB source(), Environmental target(), Environmental
    host(), Item item1(), Item item2(), String message(), <font
 face="Times New Roman" size="4">and </font>MOB monster()</font>.&nbsp;&nbsp;The 
    JRun command provides&nbsp;the methods&nbsp;<font face="Courier New"
 size="2">MOB mob(), int numParms(), String getParm(int i), <font
 face="Times New Roman" size="4">and </font>String getParms()</font>.&nbsp; 
    The web server makes the <font face="Courier New" size="2">ExternalHTTPRequests 
    request()</font> object available, as well as the method <font
 face="Courier New" size="2">void write(String s)</font>.&nbsp;&nbsp;</font><font
 size="4">&nbsp;The quest engine makes the current running Quest object available&nbsp;from
    the method&nbsp;</font><font face="Courier New" size="2">Quest quest()
 <font face="Times New Roman" size="4">and the current state of the quest
setup   script available in a custom QuestState object referencing method
called  <font face="Courier New" size="2">QuestState setupState()</font></font></font></p>
                 
<p align="left"><font size="4">The last piece of general information about
    JavaScript in CoffeeMud concerns writing Java classes for the CoffeeMud
  ClassLoader.&nbsp;  Any JavaScript file *.js included in the ClassLoader
 boot paths (see the previous section) will be loaded and treated just like
 any Java compiled *.class file.&nbsp; The JavaScript file&nbsp;would be&nbsp;parsed,
  compiled, and loaded at boot time.&nbsp; For the most part, writing Java
 Classes in JavaScript is extremely similar to writing Java Classes in Java.&nbsp;
  Base classes may be extended (using the special CoffeeMud <font
 face="Courier New" size="2">//extends</font> command in your JavaScript),
   interfaces may be implemented (using the special CoffeeMud <font
 face="Courier New" size="2">//implements</font> command in your JavaScript),
   super class variables and methods may be accessed (using the <font
 face="Courier New" size="2">this.variableName <font
 face="Times New Roman" size="4">and</font> this.super$methodname()</font> 
    syntax), and super class methods may be overridden by JavaScript functions
    of the same name and number of parameters. Class files written in Javascript
    *.js files may also be loaded and unloaded at runtime using the LOAD
and    UNLOAD Archon commands, which gives them a step up on native Java
classes    in the JVM classpath.</font></p>
                 
<p align="left"><strong><font color="#7b68ee" size="4">Writing your first
    JavaScript:</font></strong></p>
                 
<p align="left"><font color="black" size="4">Below&nbsp;is an&nbsp;example
    of a Java Class written in JavaScript.&nbsp; Examples of Embedded JavaScript
    in CoffeeMud Virtual Pages (cmvp) web files can be found in the Web Server
    Guide.&nbsp; Examples of Embedded JavaScript in a Scriptable MOBPROG
script     can be found in the Scripting Guide.</font></p>
                 
<p align="left"><font size="4">Our Java Class example is called GenLemming.js.&nbsp;
    It is a sample MOB class to demonstrate extending the GenMob class to
create    a type of modifiable mob for your maps.&nbsp; In this example,
we add functionality    to make all mobs in the world created from the GenLemming
 base suicidal.&nbsp;    To use this class, save the code somewhere in our
 CoffeeMud folder under   the name "GenLemming.js", and add an object path
 reference to it in the MOBS   entry in your coffeemud.ini file, as described
 in section one.&nbsp;</font></p>
                 
<p align="left"><font face="Courier New" size="2">//extends com.planet_ink.coffee_mud.MOBS.GenMob<br>
         <br>
         function ID(){return "GenLemming";}</font></p>
                 
<p align="left"><font face="Courier New" size="2"><font
 face="Times New Roman" size="4"><font face="Courier New" size="2">var lib=Packages.com.planet_ink.coffee_mud.core.CMLib;
    <br>
         </font></font></font><font face="Courier New" size="2"><font
 face="Times New Roman" size="4"><br>
         The first lines of our class include the special //extends command 
 which   informs the CoffeeMud ClassLoader that this JavaScript class will 
 extend  GenMob, thereby inhereting all functionality of the maleable GenMob.&nbsp;&nbsp;
   </font></font></p>
                 
<p align="left"><font face="Courier New" size="2"><font
 face="Times New Roman" size="4">The ID() method is required in all CoffeeMud
    classes.&nbsp; It must be the simple name of the class, and must match
 the   name of the JavaScript file containing it.&nbsp; For example, GenLemming.js
    contains class GenLemming and returns an ID of "GenLemming".&nbsp; They
  all  match exactly.</font></font></p>
                 
<p align="left"><font size="4">Lastly, we define the variable "lib" to act
    as a shortcut to the CoffeeMud core Libraries.</font></p>
                 
<p align="left"><font face="Courier New" size="2"><font
 face="Times New Roman" size="4">Now, moving on; since we don't have the
ability to write constructors in JavaScript, any initial fields we need to
set whenever a new instance of our class is created must be done in the CoffeeMud
newInstance() method as shown here:</font><br>
         <br>
         function newInstance() <br>
         { <br>
         &nbsp;&nbsp;&nbsp; var lemm=this.super$newInstance(); <br>
         &nbsp;&nbsp;&nbsp; lemm.setName("a generic lemming"); <br>
         &nbsp;&nbsp;&nbsp; lemm.setDisplayText("a generic lemming is waiting 
  to  commit suicide"); <br>
         &nbsp;&nbsp;&nbsp; return lemm; <br>
         } </font></p>
                 
<p align="left"><font face="Courier New" size="2"><font
 face="Times New Roman" size="4">There are several interesting points to make
here.&nbsp; One is to notice that the function has no explicit return type,
which is part of the JavaScript standard of being "weakly typed".&nbsp; Also
notice the syntax for calling the SuperClass version of the newInstance()
    method -- this.super$newInstance().&nbsp; This is very different from
Java    syntax and should be noted.</font></font></p>
                 
<p align="left"><font size="4">And now we move on to overriding our first
    GenMob method, tick:</font></p>
                 
<p align="left"><font face="Courier New" size="2">var countdown=10; <br>
         <br>
         function tick(host,tickID) <br>
         </font><font face="Courier New" size="2">{ <br>
         &nbsp;&nbsp;&nbsp; if(!this.amDead()) <br>
         &nbsp;&nbsp;&nbsp; { <br>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; countdown--; <br>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(countdown&lt;=0) <br>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { <br>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 lib.combat().postDeath(null,this,null);&nbsp;<br>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;countdown=10;&nbsp;<br>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br>
         &nbsp;&nbsp;&nbsp;&nbsp; } <br>
         &nbsp;&nbsp;&nbsp;&nbsp; return this.super$tick(host,tickID); <br>
         }</font></p>
                 
<p align="left"><font face="Courier New" size="2"><font
 face="Times New Roman" size="4">The public boolean tick(Tickable host, int
    tickID) method from the standard MOB interface is designed to be called
  every  CoffeeMud tick (about 4 seconds).&nbsp;&nbsp;</font></font><font
 face="Courier New" size="2"><font face="Times New Roman" size="4">Now, the 
    tick method in StdMOB, which is extended by GenMob, handles things like 
  recovering hit points, automatic combat rounds, and other important periodic 
  activities.&nbsp; It is explained further in Core Topic 3. </font></font></p>
                 
<p align="left"><font face="Courier New" size="2"><font
 face="Times New Roman" size="4">For our GenLemming, we create a variable
    to count down the ticks from 10 to 0.&nbsp; When the countdown variable
  reaches  0, we call the </font></font><font size="2"><font size="4"><small><tt>postDeath(MOB 
    killer, MOB killed, CMMsg msg)</tt></small> method, which is part of the
   CombatLibrary in the core libraries.&nbsp; "lib" is the variable we defined
   above as a shortcut to our core libraries.&nbsp; The last thing we do
is   return control to the SuperClass version of the tick method.</font></font></p>
                 
<p align="left"><font face="Courier New" size="2"><font
 face="Times New Roman" size="4">Now we'll get creative and implement a message
    previewer (see the Core Topic 1 below for more information on message
previewing    and handling).&nbsp; This method will be called when any event
happens in   the same room as the GenLemming mob.&nbsp; We will use this
fact to look  for, capture, and modify the message string which will inform
the room of  our impending death.&nbsp; Since it is the previewing method,
it will be called BEFORE the activity actually takes place, giving us a chance
to make our modifications before anyone actually sees the message strings.&nbsp;
 </font><br>
         <br>
         function okMessage(host,msg) <br>
         </font><font face="Courier New" size="2">{ <br>
         &nbsp;&nbsp;&nbsp; if((msg.isSource(this))<br>
         &nbsp;&nbsp;&nbsp; &amp;&amp;(msg.isOthers("DEATH"))<br>
         &nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;(msg.othersMessage()!=null))<br>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg.setOthersMessage("&lt;S-NAME&gt;
    jumps off a cliff!!!");<br>
         </font><font face="Courier New" size="2"><br>
         </font><font face="Courier New" size="2">&nbsp;&nbsp;&nbsp; return 
 this.super$okMessage(host,msg);   <br>
         </font><font face="Courier New" size="2">} </font></p>
                 
<p align="left"><font size="4">In our message previewing method, we will
check every message that comes our way, acting only if this particular GenLemming
    is the source of the message, that he appears to be dying to others in
 the   room </font><font size="4"><small><tt>(isOthers("DEATH"))</tt></small>
 and   that the message being given to others in the room is a non-null string.&nbsp;
    In these conditions, we modify the message which others in the room see.&nbsp;
    When our condition is not met, we return control to the SuperClass-GenMob
    version of okMessage.</font><br>
         </p>
                 
<p align="left"><font size="5"><strong><img
 src="file:///C:/dev/CoffeeMud/guides/images/kiss.jpg">
         </strong></font><font size="3">&nbsp;</font></p>
                 
<p align="left"><a name="DIG1"><font size="5"><strong><font color="red">Core 
    Topic 1: Getting the Message:</font></strong></font></a></p>
                 
<p align="left"><font size="4">CoffeeMud&nbsp;is essentially a distributed
    message passing and handling system, where the actions and <small><b><big>events 
    </big></b></small>that occur in the system are represented as <b>messages 
    </b>(Common.interfaces.CMMsg) which are then previewed, modified, cancelled,
    and/or reacted to by handlers.&nbsp;&nbsp; Understanding this idea is
key    to fully understanding how CoffeeMud really works, so let's take a
second    and peruse this concept in more detail.</font></p>
                 
<p align="left"><font size="4">Messages in CoffeeMud, at least as we are
talking about them here, always represent Events.&nbsp; Events such as a
mob picking up an item, swinging a sword at an opponent, taking damage from
a fireball, or getting pricked by a poisonous needle.&nbsp; These events
can never actually occur in CoffeeMud unless a proper message is generated
for them first.&nbsp; These messages, in the code, implement the interface
</font><font size="4">Common.interfaces.</font><font size="4">CMMsg, and
are typically an instance of the class Common.DefaultMessage.&nbsp;</font></p>
                 
<p align="left"><font size="4">Messages are created at the moment that the
    event needs to occur.&nbsp; This moment can be triggered by the player
 entering   a command into their telnet client and pressing Enter.&nbsp;
It  can also  by triggered by the mindless algorithms which animate the mobs.&nbsp;
 Either   way, when the moment has come, a message is created, and it looks
 like this:</font></p>
                 
<pre>	<br>CMMsg msg=CMClass.getMsg(mob,targetMOB,this,<br>	CMMsg.MSG_CAST_ATTACK_VERBAL_SPELL,"^S&lt;S-NAME&gt; invoke a spell at &lt;T-NAME&gt;s feet..^?",<br>	CMMsg.MSG_CAST_ATTACK_VERBAL_SPELL,"^S&lt;S-NAME&gt; invoke(s) a spell at your feet.^?",<br>	CMMsg.MSG_CAST_ATTACK_VERBAL_SPELL,"^S&lt;S-NAME&gt; invokes a spell at &lt;T-NAME&gt;s feet.^?");<br></pre>
                 
<p align="left"><font size="4">The above message was taken from the code
for the Grease&nbsp;spell, which calls the core.CMClass.getMsg method to
construct a CMMsg object. &nbsp;Constructing the CMMsg object does not actually
make anything happen, but it is the vital first step. &nbsp;The message we
constructed here, in this case, utilizes every major component of a message.&nbsp;&nbsp;These
    components&nbsp;are, in order:</font></p>
                 
<p align="left"><font size="4"> </font></p>
                 
<ul>
           <font size="4"> <li>Source - The source of any message must always 
  be  a valid reference to an instance of the MOB interface.&nbsp; In short, 
  all  events that occur in the system are a direct result of the activity 
 of a MOB.&nbsp; This is on the theory that the universe is controlled and 
 governed by sentience.&nbsp; In the extremely rare instances where a mob 
is not readily available to provide a message source, one should be instantiated 
 -- even if it is just a blank, new StdMOB. </li>
           <li>Target - The target of a message may be null, or any valid 
reference&nbsp;to    an instance of&nbsp;the Environmental interface, which 
includes Items, MOBs,   Rooms, Exits, etc.&nbsp; The type and context of message
you wish to generate   will typically tell you intuitively whether the source
is doing something   to someone or something else, or is acting independently.&nbsp;
This is usually  another mob or an item, but you will find examples of all
kinds of targets  in the code </li>
           <li>Tool - The tool of a message may be null, or any valid reference 
   to an instance of&nbsp;the Environmental interface, which includes Items, 
   Abilities, MOBs, Rooms, Exits, etc.&nbsp; The tool represents something 
 which  the source is utilizing to accomplish the task or generate the event.&nbsp; 
   This is typically either an Ability object (like a Spell or Skill being 
 used),  or an Item object (like a weapon in an attack event). </li>
           <li>Source Code - This is an encoded integer which represents
what   the  source MOB is actually doing.&nbsp; We'll break down this code
below.     </li>
           <li>Source Message - This is the string which the source MOB will
  see   should the event occur successfully.&nbsp; </li>
           <li>Target Code - This is an encoded integer which represents
what   is  happening to the target.&nbsp; If there is no target, this number
will   typically  have the value of 0 (CMMsg.NOEFFECT). </li>
           <li>Target Message - This is the string which the target MOB (if 
 it  is  a MOB) will see should the event occur successfully.&nbsp; If there
  is  no  target, this string is null. </li>
           <li>Others Code - This is an encoded integer which represents
how   any   other objects (such as MOBs, Items, Rooms, Exits) other than
the source   and  target, in the same room, perceive the event.&nbsp; If
the event is  completely  imperceptable by anything other than the source,
it may be 0 (CMMsg.NOEFFECT)    </li>
           <li>Others Message - This is the string which other MOBs in the
 same   room as the source and target MOBs will see should the event occur
 successfully.&nbsp;    If the event is completely imperceptable by other
MOBs, it may be null.</li>
           </font>         
</ul>
                 
<p><font size="4">The Source Code, Target Code, and Others Code is easily
    the most complicated aspect of a Message.&nbsp; For this reason, numerous
    pre-configured message codes have been created in the CMMsg interface,
 all   of which begin with the characters MSG_.&nbsp; Although we will not
 go into   the meaning of each of these messages (that will be left to the
 reader to   search the code for instances of messages which use the codes,
 and learn  from the context in which they are used), we can at least break
 down these  codes so that they can be better understood.</font></p>
                 
<p><font size="4">These coded integers all have two parts, the Major aspect
    (or the Major Code) and the Minor aspect (or the Minor Code).&nbsp; They
   may be referenced off of an already constructed&nbsp;CMMsg object using
 such  methods as sourceMajor() and sourceMinor().&nbsp; These methods will
 automatically   break down a sourceCode() into the components we will discuss.</font></p>
                 
<p><font size="4">The Major code is a series of significant bits in the integer, 
    each of which gives some new meaning to the message.&nbsp; These bits 
are    as follows:</font></p>
                 
<p>         
<table cellspacing="1" cellpadding="1" width="75%" border="1"
 bgcolor="#ffccff">
           <tbody>
             <tr>
               <td width="15%"><strong>Bit mask</strong> </td>
               <td width="35%" bgcolor="#ffccff"><b>CMMsg Equate Variable(s)</b></td>
               <td width="50%"><strong>Meaning</strong></td>
             </tr>
             <tr>
               <td width="15%">1024 + 65536</td>
               <td width="35%">                                         
                     
      <p>MASK_HURT</p>
               </td>
               <td width="50%">*Special* Damage message.</td>
             </tr>
             <tr>
               <td width="15%">2048</td>
               <td width="35%">                                         
                     
      <p>MASK_HANDS</p>
               </td>
               <td width="50%">Message includes small movements.</td>
             </tr>
             <tr>
               <td width="15%">4096</td>
               <td width="35%">                                         
                     
      <p>MASK_MOVE</p>
               </td>
               <td width="50%">Message includes large, full-body movements.</td>
             </tr>
             <tr>
               <td width="15%">8192</td>
               <td width="35%">MASK_EYES</td>
               <td width="50%">Message includes visual information.</td>
             </tr>
             <tr>
               <td width="15%">16384</td>
               <td width="35%">MASK_MOUTH</td>
               <td width="50%">Message include mouth movement, or consumption.</td>
             </tr>
             <tr>
               <td width="15%">32768</td>
               <td width="35%">MASK_SOUND,<br>
         MASK_SOUNDEDAT<br>
               </td>
               <td width="50%">Message includes auditory information.</td>
             </tr>
             <tr>
               <td width="15%">65536</td>
               <td width="35%">MASK_ALWAYS</td>
               <td width="50%">Override mask which flags the message as something
    which Must occur, regardless of the state of the source or target.</td>
             </tr>
             <tr>
               <td width="15%">131072</td>
               <td width="35%">MASK_MAGIC</td>
               <td width="50%">Message has a magical nature.</td>
             </tr>
             <tr>
               <td width="15%">262144</td>
               <td width="35%">MASK_DELICATE</td>
               <td width="50%">Message includes very fine, delicate movements,
   such  as thief skills.</td>
             </tr>
             <tr>
               <td width="15%">1048576</td>
               <td width="35%">MASK_CHANNEL</td>
               <td width="50%">Message is&nbsp;part of public&nbsp;channel
 conversation.</td>
             </tr>
             <tr>
               <td width="15%">2097152</td>
               <td width="35%">MASK_OPTIMIZE</td>
               <td width="50%">Message implementation should be optomized 
for   repetition.</td>
             </tr>
                                   
  </tbody>         
</table>
         </p>
                 
<p align="left"><font size="4">The above masks can be quite confusing.&nbsp;
    It is best to examine the several MSG_ equates in the CMMsg interface
to   see how they are properly or improperly used.&nbsp; Remember a MSG_
equate   is a completely constructed Code, complete with the appropriate
Major and   Minor aspects.</font></p>
                 
<p align="left"><font size="4">The Minor Code&nbsp;represents the more specific
    activity being performed, and is a simple integer ranging from&nbsp;0
(NO    EFFECT) to 2047.&nbsp; The officially recognized Minor codes are exhaustively
    listed in the CMMsg interface, and all begin with the prefix TYP_.&nbsp;
   These types cover every sort of major event which occurs in the CoffeeMud
   engine, including getting items, casting spells, entering or leaving rooms,
   etc, etc..</font></p>
                 
<pre>	<br>CMMsg msg=CMClass.getMsg(attacker,target,weapon,CMMsg.MSG_WEAPONATTACK,<br>						"&lt;S-NAME&gt;attack(s) &lt;T-NAME&gt;!");<br></pre>
                 
<p align="left"><font size="4">The core.CMClass has many different getMsg
    signitures to make message construction quick and painless.&nbsp; The
above    is an example where only a single Code and a single message text
are provided.&nbsp;    In constructors where only one Code or message text
field are provided,  it  is assumed that the code and message texts will
be the same for source,   target (if any) and others.</font></p>
                 
<p align="left"><font size="4">CMMsg objects also have value() and setValue(int)
    methods for modifying an integer not found in the constructor.&nbsp;&nbsp;
    This number is used for several different purposes in message construction,
    from the amount of damage in a TYP_DAMAGE message, to the amount of experience
    in a TYP_EXPCHANGE message.&nbsp; This number is also used to determine
  whether  or not a standard saving throw was made.&nbsp; Value defaults
to   0, but, after running through a message which contains a savable event,
the  value will be &gt;0 if the save was made.</font></p>
                 
<p align="left"><font color="red" size="4">Message Previewing</font></p>
                 
<p align="left"><font color="black"><font size="4">Once a Message has been
    constructed, it is time to actually put the message out into the system.&nbsp;
    There is a standard form for the sending of almost all messages.&nbsp;
 If   the source of the message is a MOB called "SourceMOB", this standard
 form   looks like this:</font></font></p>
                 
<pre>	<br>CMMsg msg=CMClass.getMsg(SourceMOB,TargetMOB,weapon,CMMsg.MSG_WEAPONATTACK,<br>						"&lt;S-NAME&gt;attack(s) &lt;T-NAME&gt;!");<br>						<br>if(SourceMOB.location().okMessage(SourceMOB,msg))<br>	SourceMOB.location().send(SourceMOB,msg);<br></pre>
                 
<p align="left"><font size="4">The location() field on a MOB refers to the
    Room in which the mob is. Room's are always the top level at which messages
    are <b>previewed</b>, and then <b>executed </b>or sent.&nbsp; The first
  line  (where the message is constructed) has already been examined.&nbsp;
  The second  line, in which the Room method "okMessage" is called, is&nbsp;the
   <b>preview  </b>step.&nbsp; In this step, the message is evaluated before
   it actually  happens.&nbsp; The first parameter to "okMessage" is called
  the "host" object,  and it refers to the object to which the one you are
 sending the message should refer back to.&nbsp; This parameter is rarely
used, except by Behaviors, and it is always safe to use the source of your
message as this value.&nbsp; The second parameter to "okMessage"&nbsp;is
the message we constructed.&nbsp;  The third line, where the Room "send"
method is called, is the <b>execution  </b>step. </font></p>
                 
<p align="left"><font size="4">In the preview step, the room object will examine
the message to see if there is anything which it might&nbsp;not like, wish
to modify, or wish to flag about the Message it has been handed.&nbsp; If
the Room object does not like the message, it will return false.&nbsp; Returning
false from "okMessage" is always an order to cancel, and not execute the
message.&nbsp; Under any other circumstances, true may be returned to allow
the message to go forward.&nbsp; The Room will also make calls to the "okMessage"
methods on every other MOB in the room, Exit from the Room, Item in the room,
spell effects which may be on the room, and behaviors of the room.&nbsp;
The MOB who receives the "okMessage" call will, in turn, pass the Message
to the "okMessage" methods in every Item the&nbsp;MOB is carrying or wearing,
every spell effect on the MOB, and every behavior of the MOB.&nbsp; Items
wills also make "okMessage" calls on their spell effects.&nbsp; Any of these
calls may modify or flag the message they receive.&nbsp; Any of these calls
may also return false.&nbsp; If any object which previews a message returns
false, the Room okMessage method will also return false, ordering the message
to be totally canceled.&nbsp; For this reason, okMessage methods are careful
about returning true unless they have a really good reason not to.</font></p>
                 
<p align="left"><font size="4">Inside the "okMessage" methods of every Item,
    MOB, Behavior, Ability (spell effect), Exit, and Room, the Messages may
  (as  we mentioned) be examined and modified, flagged, or cancelled.&nbsp;
  As we  have already covered how Messages are cancelled (by returning false).&nbsp;
    Let us turn now to the manner in which Messages are modified or flagged.</font></p>
                 
<p align="left"><font color="#ff0000" size="4">Message Flagging and Modification</font></p>
                 
<p align="left"><font size="4">Message modification is very rare.&nbsp; When
    it happens though, it is done by calling one of the several "modify"
methods     on the Common.interfaces.CMMsg object.&nbsp; These methods allow
the source,     target, and all other fields to be updated. &nbsp;Message
modification  should   also happen during the preview step so that any changes
made to the message   are made before the message is executed. &nbsp;It is
also often  wise, after   making a change to a message, to recursively call
the okMessage  method on   the room again so that the modifications can be
previewed, but  this is not   always necessary.</font></p>
                 
<p align="left"><font size="4">Message flagging is somewhat less rare.&nbsp;
    Messages may be flagged when a combat strike is successful, or when a
saving    throw is made against a spell Effect, or for any other reason the
Message    constructing code may wish.&nbsp; Flagging is done by calling&nbsp;
the  aforementioned  </font><font size="4"><small><tt>CMMsg.setValue(int)</tt></small>
  method,  and using it to change the value to something other than the default
  of 0.&nbsp;&nbsp;  Flagging using the setValue method lets the code which
  constructed the Messsage  know that something significant with relation
to  the Message has occurred.  &nbsp; The meaning of this value will vary
depending  upon the type of message  being generated, and upon the purpose
to which the creator of the message  wishes to put it. &nbsp;The value is
read using the </font><font size="4"><small><tt>int value()</tt></small>
method on CMMsg.</font></p>
                 
<p align="left"><font color="#ff0000" size="4">Message Execution</font></p>
                 
<p align="left"><font color="black" size="4">Once the "okMessage" method on
a Room object has returned true, and any code which may need to check or
handle modifications to the Message have executed, the Message is sent.&nbsp;&nbsp;
    The proper way to send a Message is through the Room objects, by calling
   one of the following Messages: </font><font color="black" size="4"><small><tt>Room.send(MOB
    SourceMOB, CMMsg msg) </tt></small>or&nbsp;</font><font
 color="black" size="4"><small><tt>Room.sendOthers(MOB SourceMOB, CMMsg msg).</tt></small>&nbsp;
    The first method handles a standard Execution, while the second allows
 every   relevant object except the SourceMOB to handle Execution.&nbsp;
The  first   method should almost always be called.&nbsp; </font></p>
                 
<p align="left"><font color="black" size="4">The "send" methods will then
    begin calling other methods in other objects.&nbsp; These other methods
  are  called the "executeMsg" methods, and are usually of the form public
 void </font><font color="black" size="4"><small><tt>executeMsg(Environmental
 myHost, CMMsg msg);</tt></small>.&nbsp; These methods are responsible for
 Executing the contents of the message.&nbsp; The Room method will make "executeMsg"
   method calls on itself, and on every Exit, Item, MOB, spell effects (Ability
   object), and Behavior associated with that Room.&nbsp; As in the "okMessage"
   case, the MOBs will in turn call the "executeMsg()" methods on their own
  Items and spell effects.&nbsp; Items will then call the&nbsp;"executeMsg"
  methods on their own spell effects, and so on.&nbsp; </font></p>
                 
<p align="left"><font size="4">Of course, not every object in your game will 
    handle and react to the Execution of every Message sent.&nbsp; Most of 
 the   time, a given object will be ignoring the Message altogether.&nbsp; 
 However,  each object knows precisely which Messages are important for it, 
 and watch  carefully for them in both their "okMessage" and "executeMsg" 
methods.&nbsp;   In general, every Message which is previewed in an objects 
"okMessage" method   is handled in the "executeMsg"&nbsp; method of the same 
object, though this   is by no means always true.&nbsp; In general, the following 
  object types  handle the following types of Messages:</font></p>
                 
<p align="left"><font size="4">MOBs - Any Message which has the mob instance
    as a target is both Previewed and Executed.&nbsp; Any Message which has
  the  mob as a source is typically Previewed, and (lacking a target) may
also  be  Executed.&nbsp; </font></p>
                 
<p align="left"><font size="4">Items - Any Message which has the item instance
    as a target.</font></p>
                 
<p align="left"><font size="4">Exits - Any Message which has the exit instance
    as a target or tool.</font></p>
                 
<p align="left"><font size="4">Rooms - Any Message which has the room instance
    as a target.</font></p>
                 
<p align="left"><font size="4">Ability (spell effects) - Any Message pertaining
    to the MOB or Item which is affected by the spell or&nbsp;skill.</font></p>
                 
<p align="left"><font size="4">Behavior - Any Message pertaining to the object
    instance which has this behavior.</font></p>
                 
<p align="left"><font size="4">Now that you are completely confused, it will
    make you at least a bit happier to know that Room objects have several
 short-cut   methods for creating, previewing, and executing messages.&nbsp;
 They include   the following:<br>
         </font><br>
         public boolean show(MOB source, Environmental target, int allCode, 
 String   allMessage);<br>
         public boolean show(MOB source, Environmental target, Environmental
  tool,   int allCode, String allMessage);<br>
         public boolean show(MOB source, Environmental target, Environmental
  tool,   int srcCode, int tarCode, int othCode, String allMessage);<br>
         public boolean show(MOB source, Environmental target, Environmental
  tool,   int srcCode,&nbsp;&nbsp;&nbsp; <br>
         &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
    &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
    &nbsp;&nbsp;&nbsp; &nbsp;String srcMessage, int tarCode, String tarMessage,
    int othCode, String othMessage);<br>
         public boolean show(MOB source, Environmental target, Environmental
  tool,   int allCode, String srcMessage, String tarMessage, String othMessage);</p>
                 
<p align="left">public boolean showOthers(MOB source, Environmental target,
    int allCode, String allMessage);<br>
         public boolean showOthers(MOB source, Environmental target, Environmental
    tool, int allCode, String allMessage);</p>
                 
<p align="left">public boolean showSource(MOB source, Environmental target,
    int allCode, String allMessage);<br>
         public boolean showSource(MOB source, Environmental target, Environmental
    tool, int allCode, String allMessage);<big><br>
         </big><br>
         public void showHappens(int allCode, String allMessage);<br>
         public void showHappens(int allCode, Environmental like, String
allMessage);     <br>
         </p>
                 
<p align="left"><font size="4">The first methods (show) is very commonly
used; it constructs a message with the given source and target (no tool),
and with the given Code and text message applying to source, target, and
others.  The showHappens methods will do the same, but will also construct
a blank  MOB object to act as the source, for those instances where a source
MOB is  not readily available. The showOthers methods behave like the first,
but do not allow the source MOB to preview or execute the message, while
the showSource  methods ONLY allows the source MOB to preview and execute
the message.</font></p>
                 
<p align="left"><font size="4">All four of those methods will construct a
    CMMsg object, give the Message to the Room object for previewing ("okMessage"),
    and then, if the Message is not cancelled, will call the Room "send"
method     for execution and return true.&nbsp; If the Message was cancelled,
false    will be returned.</font></p>
                 
<p align="left"><font color="#ff0000" size="4">Message Trailers</font></p>
                 
<p align="left"><font color="black" size="4">The final subject we will discuss
    in the area of Messages and Message handling regards another rare technique
    called Message Trailer adding.&nbsp; Message Trailers are CMMsg objects
  which  have been added to another CMMsg instance using the </font><font
 color="black" size="4"><small><tt>CMMsg.addTrailerMsg(CMMsg msg)</tt></small>
    method.&nbsp; The Message passed to this method is constructed in the
usual    way.&nbsp; </font><font color="black" size="4">This&nbsp;method
may be properly   called&nbsp;at any point during the Preview or Execution
stage of Message   handling, by any Previewing or Executing object.&nbsp;
When it is performed   is not important, because any Messages added using
this method are not Previewed   or Executed until after the Room object has
completely finished sending the host Message to all interested objects.&nbsp;<br>
         </font></p>
                 
<p align="left"><font color="black" size="4">Constructing and adding messages
    which act as message trailers can serve many purposes, but the most important
    of which is that the trailer messages only happen IF the host message
also    happens, and only happen AFTER the host message happens. &nbsp;This
can  be  useful for the timing of subsequent messages which are dependent
on others.<br>
         </font></p>
                 
<p align="left"><font size="5"><strong><img
 src="file:///C:/dev/CoffeeMud/guides/images/temple.jpg">
         </strong></font><font size="3">&nbsp;</font></p>
                 
<p align="left"><a name="DIG2"><font size="5"><strong><font color="red">Core 
    Topic</font></strong></font><font size="5"><strong><font color="red">&nbsp;2: 
    The State of Things:</font></strong></font></a></p>
                 
<p align="left"><font size="4">In most systems, it is typical for all of
the data variables which describe a particular object to be coded directly
 inside that object. &nbsp;While this is also true in CoffeeMud, many important
 data fields, along with the appropriate "getter" and "setter" methods, are
    stored in separate special data-storage, or <b>state </b>objects. &nbsp;These
   data-storage objects provide access to numerous important properties for
  those objects.&nbsp; These storage/state objects are routinely copied and
  then the copies are modified by other objects which have a spacial relationship
   with them.&nbsp; For instance, a MOB object may copy one or more of its
 state  objects, and then allow the local Room object, or his inventory Item
 objects,  or spell Effect objects to modify the copy, &nbsp; The copied
state  object   modifications are stacked on each other. Confused?&nbsp;
Well, keep  reading!</font></p>
                 
<p align="left"><font size="4">Each instance of the several&nbsp;Environmental
    objects (MOBs, Items, Exits, Rooms) have a particular storage/state object
    called their Environmental Stats.&nbsp; This object implements the Common.interfaces.EnvStats
    interface, and is typically an instance of the Common.DefaultEnvStats
class.&nbsp;    Access to this state object is available through each core.interfaces.Environmental
    objects </font><font size="4"><small><tt>EnvStats baseEnvStats()</tt></small>
    and </font><font size="4"><small><tt>EnvStats envStats()</tt></small>
method    calls. &nbsp; Since Rooms, MOBS, Items, Exits, and Areas are all
Environmental    objects, that means that they all have baseEnvStats and
envStats methods   as well. </font></p>
                 
<p align="left"><font size="4">The fields available through the EnvStats
state object include the following:</font></p>
                 
<table cellspacing="1" cellpadding="1" width="75%" border="1"
 bgcolor="#ccccff">
           <tbody>
             <tr>
               <td width="25%"><strong>Field name</strong> </td>
               <td width="25%"><strong>Relevant objects</strong></td>
               <td width="50%"><strong>Meaning</strong></td>
             </tr>
             <tr>
               <td>level</td>
               <td>Item, MOB, Exit</td>
               <td>Experience level (see Archon's Guide)</td>
             </tr>
             <tr>
               <td>ability</td>
               <td>Item, MOB </td>
               <td>Magical level (see Archon's Guide) </td>
             </tr>
             <tr>
               <td>rejuv</td>
               <td>Item, MOB </td>
               <td>Rejuvination rate (see Archon's Guide) </td>
             </tr>
             <tr>
               <td>weight</td>
               <td>Item, MOB </td>
               <td>Weight of the object </td>
             </tr>
             <tr>
               <td>height</td>
               <td>Armor, MOB </td>
               <td>Size of the object </td>
             </tr>
             <tr>
               <td>armor</td>
               <td>Item, MOB </td>
               <td>Protection level (see Archon's Guide) </td>
             </tr>
             <tr>
               <td>damage</td>
               <td>Item, MOB </td>
               <td>Damaging ability </td>
             </tr>
             <tr>
               <td>speed</td>
               <td>Item, MOB </td>
               <td>Attack speed </td>
             </tr>
             <tr>
               <td>attackAdjustment</td>
               <td>Item, MOB </td>
               <td>Attack level </td>
             </tr>
             <tr>
               <td>replacementName</td>
               <td>Item, MOB, Exit </td>
               <td>New displayable name of the object </td>
             </tr>
             <tr>
               <td>sensesMask</td>
               <td>Item, MOB, Exit, Room&nbsp; </td>
               <td>Bit mask of relevant sensory abilities. </td>
             </tr>
             <tr>
               <td>disposition</td>
               <td>Item, MOB, Exit, Room&nbsp; </td>
               <td>Bit mask of relevant disposition state </td>
             </tr>
                                   
  </tbody>         
</table>
                 
<p align="left"><font size="4">Although most of these fields are better described
    in the Archon's Guide, there are two whose nature may not be readily
apparant:     the sensesMask and the disposition.&nbsp; These two integers
are bitmaps.&nbsp;     The value of each bit is defined by equates in the
Common.interfaces.EnvStats     interface.&nbsp; The equates which refer to
the bits for sensesMask all   begin  with "CAN_", while the equates which
refer to the bits for disposition   all  begin with "IS_".</font> </p>
                 
<p align="left"><font size="4">Now, as mentioned previously, all Environmental
    objects have two methods for accessing their EnvStats. One is </font><font
 size="4">core.interfaces.Environmental.baseEnvStats()</font><font
 size="4"> and the other is&nbsp;</font><font size="4">core.interfaces.Environmental.envStats()</font><font
 size="4">.&nbsp; The difference between these two methods is very significant.&nbsp;
    </font><font size="4">The EnvStats state object returned by the "baseEnvStats"
    method refers to the permanent, unmodified, "base" state of the Environmental
    object.&nbsp; The "envStats" method, however, returns the modified, less
   permanent, "current" state of the Environmental object.&nbsp;&nbsp; The
 EnvStats   object returned by the "envStats" method is always copied and
derived from   the "baseEnvStats" values, after all relevant modifications
have been made   to it.&nbsp; How the current state object goes from its
base values (baseEnvStats)   to its current values (envStats) is our next
topic.</font></p>
                 
<p align="left"><font size="4">We must now introduce&nbsp;two other Environmental
    interface methods significant to this topic.&nbsp; One is the </font><font
 size="4"><small><tt>recoverEnvStats()</tt></small> method, while the other
    is the </font><font size="4"><small><tt>affectEnvStats(Environmental
affected,     EnvStats affectableStats)</tt></small> method.&nbsp; The "recoverEnvStats"
    method is also located on&nbsp;every Environmental (Item, MOB, Exit,
etc)     object and is the method which turns the baseEnvStats() values into
their     current envStats() values.&nbsp; This method call works by <b>copying
</b>the    base values into the current values and then allowing certain
other objects    to have an opportunity to affect the copy.&nbsp; Only after
all opportunities    to modify the copied values have been exhausted, does
the recoverEnvStats()    method return. &nbsp;In essence, recoverEnvStats()
allows the Environmental    objects baseEnvStats() to be updated, with that
updated state object made    available through envStats().</font></p>
                 
<p align="left"><font size="4">The way in which&nbsp;the current&nbsp;EnvStats
    state object is modified by the "recoverEnvStats" method call is by making
    repeated internal calls to the </font><font size="4"><small><tt>affectEnvStats(Environmental
    affected, EnvStats affectedStats)</tt></small> methods on other relevant
   objects.&nbsp; These methods will then have the opportunity to change
the    values in the current state object (affectedStats parameter) however
they     wish.&nbsp; The relevant objects which may change the state of an
Environmental    are as follows:</font></p>
                 
<p align="left"><font size="4">MOBs - Room object being occupied, something
    being Ridden, the MOBs Character Class object, the MOBs Race object,
the    Items in the MOBs inventory, and finally the Ability objects which
are affecting    the MOB (spell effects).</font></p>
                 
<p align="left"><font size="4">Items, Exits, Areas&nbsp;- Ability objects
    which are affecting&nbsp;it (spell effects).</font></p>
                 
<p align="left"><font size="4">Rooms - Area object which this room is a part
    of, Ability objects which are affecting it (spell effects), Items in
the    Room, and MOBs in the Room.</font></p>
                 
<p align="left"><font size="4">Here is an example:</font></p>
                 
<p align="left"><font size="4">Gunker the Thief wears Full Plate Armor (Item),
    and has the Shield spell cast on him.&nbsp; His base Armor rating is
100.&nbsp;     When he puts on the Plate Armor, the "recoverEnvStats" method
is called   on  Gunker's MOB object.&nbsp; That method in turn calls the
"affectEnvStats"     method on the Plate Armor and the Shield spell Effect.&nbsp;
Both of those     methods improve the Armor rating on Gunker's MOB's current
EnvStats by  some   number.&nbsp; Thus, Gunker becomes harder to hit in combat.&nbsp;
Also, when  Gunker picked up the Plate armor, the weight of the armor was
added to Gunker's  overall carried weight by increasing the weight value
in&nbsp;Gunker</font><font size="4">'s EnvStats object.</font></p>
                 
<p align="left"><font size="4">I know, this is probably still confusing.&nbsp;</font></p>
                 
<p align="left"><font size="4">Confusing or not, however, we still have to
    consider two other state objects, both of which are only available from
  the  MOB object.&nbsp; One of which is the CharStats object, and the other
  of which is the CharState object.</font></p>
                 
<p align="left"><font size="4">The CharStats objects are most closely analogous
    to the EnvStats objects.&nbsp; For instance, there are </font><font
 size="4"><small><tt>CharStats baseCharStats()</tt></small> and </font><font
 size="4"><small><tt>CharStats charStats()</tt></small> method calls from
    a MOB object, as well as a </font><font size="4"><small><tt>recoverCharStats()</tt></small> 
    method call.&nbsp; All of these work similarly to the ones described above
   for EnvStats.&nbsp; The fields on a Common.interfaces.CharStats object
are   somewhat more straight forward however.&nbsp; Most of the fields of
a CharStats   object are referenced using the int </font><font size="4"><small><tt>getStat(int)</tt></small>
   and </font><font size="4"><small><tt>setStat(int,int)</tt></small> methods
   on a CharStats object.&nbsp; Both of these methods require, as their first
    parameter, an integer code which corresponds to the specific stat being
  set  or read.&nbsp; These stat parameters are defined as equates within
the  CharStats  interface, and include: </font>STAT_STRENGTH, STAT_INTELLIGENCE,
  STAT_DEXTERITY,  STAT_CONSTITUTION, STAT_CHARISMA, STAT_WISDOM, STAT_GENDER,
  STAT_SAVE_PARALYSIS,  STAT_SAVE_FIRE, STAT_SAVE_COLD, STAT_SAVE_WATER,
STAT_SAVE_GAS,   STAT_SAVE_MIND,  STAT_SAVE_GENERAL, STAT_SAVE_JUSTICE, STAT_SAVE_ACID,
STAT_SAVE_ELECTRIC,     STAT_SAVE_POISON, STAT_SAVE_UNDEAD, STAT_SAVE_MAGIC,
STAT_SAVE_DISEASE,   STAT_SAVE_TRAPS,  STAT_MAX_STRENGTH_ADJ, STAT_MAX_INTELLIGENCE_ADJ,
STAT_MAX_DEXTERITY_ADJ,     STAT_MAX_CONSTITUTION_ADJ, STAT_MAX_CHARISMA_ADJ,
STAT_MAX_WISDOM_ADJ,  STAT_AGE,   STAT_SAVE_DETECTION, STAT_SAVE_OVERLOOKING<font
 size="3">. </font><font size="4">In addition to these equates defined and
read&nbsp;through the "getStat" and "setStat" methods, there is also the
Race object available through "getMyRace" and "setMyRace" methods, as well
as Character Class and Character Class level methods. &nbsp;See the Common.interfaces.CharStats
java file for more information on those methods and how they work.</font></p>
                 
<p align="left"><font size="4">Like the EnvStats above, those objects listed
    as able to modify the EnvStats current state object are the same objects
   which are able to modify the CharStats state objects.&nbsp; Rereading
the    section on EnvStats will make clear how the CharStats objects are
modified    in the same analogous manner, using repeated calls to </font><font
 size="4"><small><tt>affectCharStats(MOB affected, CharStats affectedStats)</tt></small>
   methods on related objects.</font></p>
                 
<p align="left"><font size="4">The last state object to consider is the Common.interfaces.CharState
    objects on MOBs.&nbsp; The CharState object represents those fields which
    are constantly in flux: Hit Points, Mana, Movement, Hunger, Fatigue,
and    Thirst.</font></p>
                 
<p align="left"><font size="4">Unlike EnvStats and CharStats, there are three
    CharState objects to consider for MOBs: the base CharState object&nbsp;(available
    through </font><font size="4"><small><tt>CharState baseState()</tt></small>
    method, the adjusted base&nbsp;CharState (or max state) object available
   through the </font><font size="4"><tt><small>CharState maxState()</small></tt>
   &nbsp;method and modified by </font><font size="4"><small><tt>recoverMaxState(MOB
   affected, CharState affectedState)</tt></small> methods on related objects,
   and lastly the current CharState object available through the </font><font
 size="4"><small><tt>CharState curState()</tt></small> and refreshed or reset
    to maximums using the MOBs </font><font size="4"><small><tt>resetToMaxState()</tt></small>
    method.</font></p>
                 
<p align="left"><font size="4">The relationship between the above objects
    is as follows: The base CharState object represents the maximum values
 for   the state variables BEFORE modification by magical armor or spells.&nbsp;
    The adjusted base CharState object (Max State) represents the maximum
values    for the state variables AFTER modification by magical armor or
spells.&nbsp;    The current CharState object (curState) represents the current
hit points,    mana points, etc available to the MOB.</font></p>
                 
<p align="left"><font size="4">In the case of the CharState objects, adjustment
    by relevant objects is initiated by calling the MOBs </font><font
 size="4"><small><tt>recoverMaxState()</tt></small> method.&nbsp; This method
    allows the same objects who modify the EnvStats and CharStats above to
 modify   the maximum CharState values as well.&nbsp; </font></p>
                 
<p align="left"><font size="4">Once again, to understand one of them fully
    is to understand them all.</font></p>
                 
<p align="left"><font size="5"><strong><img
 src="file:///C:/dev/CoffeeMud/guides/images/time.jpg">
         </strong></font><font size="3">&nbsp;</font></p>
                 
<p align="left"><a name="DIG3"><font size="5"><strong><font color="red">Core 
    Topic</font></strong></font><font size="5"><strong><font color="red">&nbsp;3: 
    Tick Tock:</font></strong></font></a></p>
                 
<p align="left"><font size="4">Our last Core Topic will cover the ability
    of the mobs, items, exits, abilities, spell effects, behaviors, and other
    objects to perform tasks on a regular, timed, basis.&nbsp;The tasks to
 be   performed are always located within an method called </font><font
 size="3">boolean tick(Tickable ticking, int tickID)</font><font
 size="4">.&nbsp; All Environmental objects&nbsp;define this method, and
Behavior objects do as well.</font> .</p>
                 
<p align="left"><font size="4">These methods are called on a regular, timed
    basis whenever the object instance in question has been properly set
up   to  do so, and at a defined frequency and interval.&nbsp; The "ticking"
parameter    is usually a reference to the object itself, or to the host
object in the    case of Behaviors. &nbsp;The "tickID" parameter describes
what sort of regular   timed event is occurring.&nbsp; These events are defined
as equates in the   core.interfaces.Tickable interface, and include IDs such
 as TICKID_MOB,  </font><font size="4">TICKID_</font><font size="4">AREA,
</font><font size="4">TICKID_</font><font size="4">EXIT_REOPEN and others.
&nbsp;See the java file of that interface  for more defined tickID values.</font></p>
                 
<p align="left"><font size="4">Before we get into the methods by which an
    object instance are properly set up for regular calls to its "tick" method,
    it may be worthwhile to discuss which regular ticks are setup by the
system     by default.&nbsp; These tick events cover the most commonly used
objects    under the most common circumstances, and so may be just the events
you already   needed!&nbsp; They include:</font></p>
                 
<p align="left"><font size="4">MOBs - All MOBs have their "tick" method called
    once per core.interfaces.MudHost.TIME_TICK (4 seconds), with the "tickID"
    defined by Host.MOB_TICK.&nbsp;&nbsp;&nbsp; MOBs will, in turn, call
the    "tick" methods on their own Behaviors, and Ability objects affecting
them.&nbsp;     If any of these dependent objects return "false" from their
own tick methods,     then the object will cease to receive any further tick
method calls.&nbsp;</font></p>
                 
<p align="left"><font size="4">Exits, Items, Rooms - Whenever a Behavior
is added to any of these objects, they will begin to have their tick methods
    called once per MudHost.TIME_TICK (4 seconds), with the tickID defined
 by   Tickable.</font><font size="4">TICKID_</font><font size="4">ITEM_BEHAVIOR, 
    </font><font size="4">TICKID_</font><font size="4">EXIT_BEHAVIOR, or </font><font
 size="4">TICKID_</font><font size="4">ROOM_BEHAVIOR.&nbsp; Deletion of the
   last behavior from the host object will stop this tick event from occurring
   again.</font></p>
                 
<p align="left"><font size="4">Areas - All Area objects have their tick methods
    called once per&nbsp;</font><font size="4">core.interfaces.MudHost</font><font
 size="4">.TIME_TICK, with the tickID defined by Tickable.TICKID_AREA.</font></p>
                 
<p align="left"><font size="4">Ability - Whenever an Ability object is added
    as an Effect (using the addEffect() Environmental method) to a non-MOB
 object   by using the proper Ability invoke procedure (see below), then
the  Ability   object itself will gain it's own regular calls to its tick
method.&nbsp;    The tickID for this call is also Tickable.TICKID_MOB, so
as to make consistant     the tickID for all spell and similar effects.</font></p>
                 
<p align="left"><font size="4">To sum up, MOBs have regular tick calls which
    they use to perform their own periodic tasks, as well as to allow their
  Behavior  and spell effects to perform tasks.&nbsp; The other objects have
  circumstantial  ticks in certain instances.</font></p>
                 
<p align="left"><font size="4">Now, to add a new periodic call to the "tick"
    method on an Environmental object, one needs only to make a method call
  like  this:</font></p>
                 
<pre>	<br>	CMClass.threads().startTickDown(theEnvObject,Tickable.MY_TICK_ID,TIME_TICK,NUM_TICKS);<br></pre>
                 
<p align="left"><font size="4">The second parameter is the tickID which will
    be used when the "tick" method on the "theEnvObject" object is called.
 The   third parameter is the time interval, in milliseconds, between each
 event.   The fourth parameter is the number of time intervals between each
 call to   the "tick" method.&nbsp; The total time between each call to the
 "tick" method,  therefore, will be TIME_TICK * NUM_TICKS.</font></p>
                 
<p align="left"><font size="4">Now, the above version of startTickDown can
    be used to create timed events of any duration. However, all objects
in   the  base distribution of CoffeeMud operate on a single default time
interval    of 4000 miliseconds as defined by Tickable.TIME_TICK. For this
reason, a  different version of the startTickDown method is called which
does not include  the TIME_TICK parameter, utilitizing the standard 4 second
delay instead:</font></p>
                 
<pre>	<br>	CMClass.ThreadEngine().startTickDown(theEnvObject,Host.MY_TICK_ID,NUM_TICKS);<br></pre>
                 
<p align="left"><font size="4">Stopping any of these tick calls can be done
    by simply returning "false" from the tick method itself, or manually
using     the following:</font></p>
                 
<pre>	<br>	CMClass.ThreadEngine().deleteTick(theEnvObject,Host.MY_TICK_ID);<br><br></pre>
                 
<p align="left"><font size="4">You may also stop tick calls to an object
by using the Environmental objects </font><font size="4"><small><tt>destroy()</tt></small> 
    method</font><font size="4">.</font><br>
                     </p>
     
<p align="left"><font size="5"><strong><img src="images/books.jpg"
 alt="" width="87" height="71" border="0">
         </strong></font><font size="3">&nbsp;</font></p>
                  
<p align="left"><a name="DIG4"><font size="5"><strong><font color="red">Core 
    Topic 4: Core Libraries:</font></strong></font></a></p>
                  
<p align="left"><font size="4">The CoffeeMud engine contains numerous Java 
 classes whose purpose is to perform much of the underlying game functionality. 
 &nbsp;Some of these Java classes are <b>Core </b>classes, some are <b>Library 
 </b>classes, and some are <b>Common </b>classes. &nbsp;</font></p>
     
<p align="left"><font size="4">Core classes are those classes found in the 
 com.planet_ink.coffee_mud.core package. &nbsp;Like the interfaces, they may
 not be extended or overwritten without risking problems. &nbsp;The core classes,
 and their general purpose is:<br>
   </font></p>
     
<table cellpadding="1" cellspacing="1" border="1" width="100%"
 bgcolor="#ffffcc">
     <tbody>
       <tr>
         <td valign="top" bgcolor="#ffffcc" width="30%"><b><big>Core Class
 Name</big></b></td>
         <td valign="top"><b><big>Purpose</big><br>
         </b></td>
       </tr>
       <tr>
       <td valign="top">B64Encoder<br>
       </td>
       <td valign="top">Encode and decode text&lt;-&gt;binary using Base64<br>
       </td>
     </tr>
     <tr>
         <td valign="top">CMath<br>
         </td>
         <td valign="top">Converting strings to numbers, performing bit-wise 
 and other arithmetic operations<br>
         </td>
       </tr>
       <tr>
         <td valign="top">CMClass<br>
         </td>
         <td valign="top">Main ClassLoader -- get all your objects from methods 
 here!<br>
         </td>
       </tr>
       <tr>
         <td valign="top">CMFile<br>
         </td>
         <td valign="top">System manager, get all your file data from this
 class<br>
         </td>
       </tr>
       <tr>
         <td valign="top">CMLib<br>
         </td>
         <td valign="top">The non-core library reference object <small><small><small><big>*</big>&nbsp;</small></small></small>. 
 &nbsp;See below for more information.<br>
         </td>
       </tr>
       <tr>
         <td valign="top">CMParms<br>
         </td>
         <td valign="top">Methods for parsing strings and determining parameter 
 values in many different ways.<br>
         </td>
       </tr>
       <tr>
         <td valign="top">CMProps<br>
         </td>
         <td valign="top">Properties manager, for reading INI file values 
from  coffeemud.ini and other places.<br>
         </td>
       </tr>
       <tr>
         <td valign="top">CMSecurity<br>
         </td>
         <td valign="top">The security manager, for evaluating player and 
system  security flags.<br>
         </td>
       </tr>
       <tr>
         <td valign="top">CMStrings<br>
         </td>
         <td valign="top">Methods to manipulate, pad, and filter strings.<br>
         </td>
       </tr>
       <tr>
         <td valign="top">Directions<br>
         </td>
         <td valign="top">Methods to handle the different compas directions.<br>
         </td>
       </tr>
       <tr>
         <td valign="top">DVector<br>
         </td>
         <td valign="top">A multi-dimensional version of java.util.Vector<br>
         </td>
       </tr>
       <tr>
         <td valign="top">Log<br>
         </td>
         <td valign="top">The file and console logging manager.<br>
         </td>
       </tr>
       <tr>
         <td valign="top">Resources<br>
         </td>
         <td valign="top">The object-resource manager, usually with lots
of  StringBuffers keyed by String names.<br>
         </td>
       </tr>
       <tr>
         <td valign="top">Scripts<br>
         </td>
         <td valign="top">The human-language readable strings loader.<br>
         </td>
       </tr>
           
  </tbody>   
</table>
     
<p align="left"><font size="4">You should check out the javadocs for those 
 classes for more information on the core classes.</font></p>
     
<p align="left"><font size="4">* CMLib also refers to some of the sub-core 
 classes, such as the Database access objects, and the Threading engine. &nbsp;While
 they are considered core, they are accessed through CMLib as if they were
 non-core libraries. &nbsp;Most core classes can also be accessed through
CMLib methods, making it a one-stop shop.<br>
   </font></p>
     
<p align="left"><font size="4">Now, non-core libraries, or Libraries proper, 
 are located in the com.planet_ink.coffee_mud.Libraries package, and each 
one implements a unique interface from the com.planet_ink.coffee_mud.Libraries.interfaces 
 package. &nbsp;This is unique, that each class in the Libraries package implements
 a unique interface all its own, but that is not the only unique thing about
 this package. &nbsp;Libraries are also singletons -- there is never more
than 1 instance of each Library. &nbsp;Moreoever, these singletons are all
accessed from a single accessor class, CMLib, which we mentioned earlier.
&nbsp;<br>
   </font></p>
     
<p align="left"><font size="4">Here is a map of how the classes, interfaces, 
 and CMLib methods are all mapped together:<br>
   </font></p>
     
<table cellpadding="1" cellspacing="1" border="1" width="100%"
 bgcolor="#99ff99">
     <tbody>
       <tr>
         <td valign="top" width="20%"><b>Library class name<br>
         <small><tt>...Libraries.*</tt></small></b><br>
         </td>
         <td valign="top" width="20%"><b>Library interface name<br>
    <small><tt>...Libraries.interfaces.*</tt></small></b><br>
         </td>
         <td valign="top" width="20%"><b>CMLib method name<br>
    <small><tt>...core.CMLib</tt></small></b><br>
         </td>
         <td valign="top" width="40%"><b>Purpose of the Library</b><br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">BeanCounter<br>
         </td>
         <td valign="top" width="20%">MoneyLibrary<br>
         </td>
         <td valign="top" width="20%"><tt>beanCounter()<br>
        </tt>       </td>
         <td valign="top" width="40%">Handle money and currency.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">CharCreation<br>
         </td>
         <td valign="top" width="20%">CharCreationLibrary<br>
         </td>
         <td valign="top" width="20%"><tt>login()<br>
        </tt>       </td>
         <td valign="top" width="40%">Login and create new players.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">Clans<br>
         </td>
         <td valign="top" width="20%">ClanManager<br>
         </td>
         <td valign="top" width="20%"><tt>clans()<br>
        </tt>       </td>
         <td valign="top" width="40%">Handle all clans.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">CMAble<br>
         </td>
         <td valign="top" width="20%">AbilityMapper<br>
         </td>
         <td valign="top" width="20%"><tt>ableMapper()<br>
        </tt>       </td>
         <td valign="top" width="40%">Maps CharClasses to Skills/Abilities.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">CMChannels<br>
         </td>
         <td valign="top" width="20%">ChannelsLibrary<br>
         </td>
         <td valign="top" width="20%"><tt>channels()<br>
        </tt>       </td>
         <td valign="top" width="40%">Handles public channels.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">CMColor<br>
         </td>
         <td valign="top" width="20%">ColorLibrary<br>
         </td>
         <td valign="top" width="20%"><tt>color()<br>
        </tt>       </td>
         <td valign="top" width="40%">ANSI and color code conversions.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">CMEncoder<br>
         </td>
         <td valign="top" width="20%">TextEncoders<br>
         </td>
         <td valign="top" width="20%"><tt>encoder()<br>
        </tt>       </td>
         <td valign="top" width="40%">Compression library.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">CMJournals<br>
         </td>
         <td valign="top" width="20%">JournalsLibrary<br>
         </td>
         <td valign="top" width="20%"><tt>journals()<br>
        </tt>       </td>
         <td valign="top" width="40%">Handles public journal commands.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">CMLister<br>
         </td>
         <td valign="top" width="20%">ListingLibrary<br>
         </td>
         <td valign="top" width="20%"><tt>lister()<br>
        </tt>       </td>
         <td valign="top" width="40%">Handles listing tables nicely.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">CMMap<br>
         </td>
         <td valign="top" width="20%">WorldMap<br>
         </td>
         <td valign="top" width="20%"><tt>map()<br>
        </tt>       </td>
         <td valign="top" width="40%">Find areas and rooms.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">CoffeeFilter<br>
         </td>
         <td valign="top" width="20%">TelnetFilter<br>
         </td>
         <td valign="top" width="20%"><tt>coffeeFilter()<br>
        </tt>       </td>
         <td valign="top" width="40%">Filters/transforms text going to and
 from a player.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">CoffeeLevels<br>
         </td>
         <td valign="top" width="20%">ExpLevelLibrary<br>
         </td>
         <td valign="top" width="20%"><tt>leveler()<br>
        </tt>       </td>
         <td valign="top" width="40%">Leveling and Experience gaining functionality.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">CoffeeMaker<br>
         </td>
         <td valign="top" width="20%">CMObjectBuilder<br>
         </td>
         <td valign="top" width="20%"><tt>coffeeMaker()<br>
        </tt>       </td>
         <td valign="top" width="40%">Generic Mob/Item and CoffeeXML generators.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">CoffeeShops<br>
         </td>
         <td valign="top" width="20%">ShoppingLibrary<br>
         </td>
         <td valign="top" width="20%"><tt>coffeeShops()<br>
        </tt>       </td>
         <td valign="top" width="40%">Handles manipulation of &nbsp;shop
inventories.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">CoffeeTables<br>
         </td>
         <td valign="top" width="20%">StatisticsLibrary<br>
         </td>
         <td valign="top" width="20%"><tt>coffeeTables()<br>
        </tt>       </td>
         <td valign="top" width="40%">Maintains player usage stats.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">CoffeeTime<br>
         </td>
         <td valign="top" width="20%">TimeManager<br>
         </td>
         <td valign="top" width="20%"><tt>time()<br>
        </tt>       </td>
         <td valign="top" width="40%">Real-life data/time display.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">CoffeeUtensils<br>
         </td>
         <td valign="top" width="20%">CMMiscUtils<br>
         </td>
         <td valign="top" width="20%"><tt>utensils()<br>
        </tt>       </td>
         <td valign="top" width="40%">Misc stuff-- law, traps, titles, resets.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">CommonMsgs<br>
         </td>
         <td valign="top" width="20%">CommonCommands<br>
         </td>
         <td valign="top" width="20%"><tt>commands()<br>
        </tt>       </td>
         <td valign="top" width="40%">Methods for getting, talking, common-stuff<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">Dice<br>
         </td>
         <td valign="top" width="20%">DiceLibrary<br>
         </td>
         <td valign="top" width="20%"><tt>dice()<br>
        </tt>       </td>
         <td valign="top" width="40%">Random number generator.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">EnglishParser<br>
         </td>
         <td valign="top" width="20%">EnglishParsing<br>
         </td>
         <td valign="top" width="20%"><tt>english()<br>
        </tt>       </td>
         <td valign="top" width="40%">Player command line parsing helpers.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">Factions<br>
         </td>
         <td valign="top" width="20%">FactionManager<br>
         </td>
         <td valign="top" width="20%"><tt>factions()<br>
        </tt>       </td>
         <td valign="top" width="40%">Handles the factions and faction system.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">MUDFight<br>
         </td>
         <td valign="top" width="20%">CombatLibrary<br>
         </td>
         <td valign="top" width="20%"><tt>combat()<br>
        </tt>       </td>
         <td valign="top" width="40%">Combat and Death routines.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">MUDHelp<br>
         </td>
         <td valign="top" width="20%">HelpLibrary<br>
         </td>
         <td valign="top" width="20%"><tt>help()<br>
        </tt>       </td>
         <td valign="top" width="40%">Handling help-file entries.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">MUDTracker<br>
         </td>
         <td valign="top" width="20%">TrackingLibrary<br>
         </td>
         <td valign="top" width="20%"><tt>tracking()<br>
        </tt>       </td>
         <td valign="top" width="40%">Methods for NPC movement, and for tracking.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">MUDZapper<br>
         </td>
         <td valign="top" width="20%">MaskingLibrary<br>
         </td>
         <td valign="top" width="20%"><tt>masking()<br>
        </tt>       </td>
         <td valign="top" width="40%">Zapper-mask parsing and evaluation.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">Polls<br>
         </td>
         <td valign="top" width="20%">PollManager<br>
         </td>
         <td valign="top" width="20%"><tt>polls()<br>
        </tt>       </td>
         <td valign="top" width="40%">Handle the public polls.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">Quests<br>
         </td>
         <td valign="top" width="20%">QuestManager<br>
         </td>
         <td valign="top" width="20%"><tt>quests()<br>
        </tt>       </td>
         <td valign="top" width="40%">Quest Manager system.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">Sense<br>
         </td>
         <td valign="top" width="20%">CMFlagLibrary<br>
         </td>
         <td valign="top" width="20%"><tt>flags()<br>
        </tt>       </td>
         <td valign="top" width="40%">Sensory and Disposition bitmap/flag 
handling.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">Sessions<br>
         </td>
         <td valign="top" width="20%">SessionsList<br>
         </td>
         <td valign="top" width="20%"><tt>sessions()<br>
        </tt>       </td>
         <td valign="top" width="40%">Container for player connection objects.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">SlaveryParser<br>
         </td>
         <td valign="top" width="20%">SlaveryLibrary<br>
         </td>
         <td valign="top" width="20%"><tt>slavery()<br>
        </tt>       </td>
         <td valign="top" width="40%">Geas and Slavery order parsing and
execution.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">SMTPclient<br>
         </td>
         <td valign="top" width="20%">SMTPLibrary<br>
         </td>
         <td valign="top" width="20%"><tt>smtp()<br>
        </tt>       </td>
         <td valign="top" width="40%">E-Mail sending routines.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">Socials<br>
         </td>
         <td valign="top" width="20%">SocialsList<br>
         </td>
         <td valign="top" width="20%"><tt>socials()<br>
        </tt>       </td>
         <td valign="top" width="40%">Socials container and parser.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">StdLibrary<br>
         </td>
         <td valign="top" width="20%">NONE<br>
         </td>
         <td valign="top" width="20%">NONE<tt><br>
        </tt>       </td>
         <td valign="top" width="40%">SuperClass of other libraries.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">TimsLibrary<br>
         </td>
         <td valign="top" width="20%">ItemBuilderLibrary<br>
         </td>
         <td valign="top" width="20%"><tt>itemBuilder()<br>
        </tt>       </td>
         <td valign="top" width="40%">Methods for normalized item evaluation.<br>
         </td>
       </tr>
       <tr>
         <td valign="top" width="20%">XMLManager<br>
         </td>
         <td valign="top" width="20%">XMLLibrary<br>
         </td>
         <td valign="top" width="20%"><tt>xml()<br>
        </tt>       </td>
         <td valign="top" width="40%">General XML parsing.<br>
         </td>
       </tr>
           
  </tbody>   
</table>
     
<p align="left"><font size="4"><br>
  </font><font size="4">Libraries are lastly unique in that it is almost
useless  to write new ones, unless you are doing the most serious additions
and enhancements  to your system. &nbsp;However,&nbsp; they are designed
especially so they  they can be extended and overridden. &nbsp;They have
their own entry in the  coffeemud.ini file called LIBRARY. By writing classes
that extend the base  CoffeeMud library classes, and overriding their methods,
you can make changes  to the most basic CoffeeMud algorithms, even at run-time!
Libraries also have an entry in the coffeemud.ini file, LIBRARY, so that
you can specify your custom extended versions of them after the %DEFAULT%
string, thus allowing  your changes to be loaded at boot-time.<br>
  </font></p>
   
<p align="left"><font size="4">The last set of classes to discuss under this
 topic are neither Core class or Libraries, but form parts of the cores of
 other classes, including many of the Libraries. &nbsp;These are the Common
 classes. &nbsp;They are part of the com.planet_ink.coffee_mud.Common package.
 &nbsp;Like the Libraries, they each implement their own unique interface
from the com.planet_ink.coffee_mud.Common.interfaces package. &nbsp;However,
unlike the Libraries, numerous instances of each class will exist in your
mud, and they are created from the core CMClass loader, much like MOBs, Items,
Rooms, and so forth. &nbsp;The javadocs are also a good place to learn about
these classes, but here is a brief list of them to wrap up our last Core
Topic.<br>
  </font></p>
   
<table cellpadding="1" cellspacing="1" border="1" width="100%"
 bgcolor="#ccccff">
    <tbody>
      <tr>
        <td valign="top" width="25%"><b><big>Common Class</big></b><br>
        </td>
        <td valign="top" width="75%"><b><big>Description</big></b><br>
        </td>
      </tr>
      <tr>
        <td valign="top" width="25%">DefaultArrestWarrant<br>
        </td>
        <td valign="top" width="75%">An object created every time a law is
 broken.<br>
        </td>
      </tr>
      <tr>
        <td valign="top" width="25%">DefaultCharState<br>
        </td>
        <td valign="top" width="75%">Contains a mobs hit points, mana, movement,
 fatigue, hunger, and thirst.<br>
        </td>
      </tr>
      <tr>
        <td valign="top" width="25%">DefaultCharStats<br>
        </td>
        <td valign="top" width="75%">Contains a mobs class, race, saving
throws,  and basic stat scores.<br>
        </td>
      </tr>
      <tr>
        <td valign="top" width="25%">DefaultClan<br>
        </td>
        <td valign="top" width="75%">Represents a single Clan.<br>
        </td>
      </tr>
      <tr>
        <td valign="top" width="25%">DefaultClimate<br>
        </td>
        <td valign="top" width="75%">A single climatary system for a given
 area.<br>
        </td>
      </tr>
      <tr>
        <td valign="top" width="25%">DefaultCMIntegerGrouper<br>
        </td>
        <td valign="top" width="75%">An object for maintaining a players
room  visitation memory.<br>
        </td>
      </tr>
      <tr>
        <td valign="top" width="25%">DefaultCoffeeShop<br>
        </td>
        <td valign="top" width="75%">Represents a single shop store inventory.<br>
        </td>
      </tr>
      <tr>
        <td valign="top" width="25%">DefaultCoffeeTableRow<br>
        </td>
        <td valign="top" width="75%">Represents a days worth of game player
 usage statistics.<br>
        </td>
      </tr>
      <tr>
        <td valign="top" width="25%">DefaultEnvStats<br>
        </td>
        <td valign="top" width="75%">Contains an objects attack bonus, armor
 bonus, weight, height, rejuv rate.<br>
        </td>
      </tr>
      <tr>
        <td valign="top">DefaultFaction<br>
        </td>
        <td valign="top">Represents a single faction.<br>
        </td>
      </tr>
      <tr>
        <td valign="top">DefaultLawSet<br>
        </td>
        <td valign="top">Represents a single set of laws and legal policies.<br>
        </td>
      </tr>
      <tr>
        <td valign="top">DefaultMessage<br>
        </td>
        <td valign="top">A CoffeeMud event message (CMMsg).<br>
        </td>
      </tr>
      <tr>
        <td valign="top">DefaultPlayerStats<br>
        </td>
        <td valign="top">Represents player-specific fields like prompts,
friends,  alias, etc.<br>
        </td>
      </tr>
      <tr>
        <td valign="top">DefaultPoll<br>
        </td>
        <td valign="top">A single poll object.<br>
        </td>
      </tr>
      <tr>
        <td valign="top">DefaultQuest<br>
        </td>
        <td valign="top">Container for a single timed quest.<br>
        </td>
      </tr>
      <tr>
        <td valign="top">DefaultRoomnumberSet<br>
        </td>
        <td valign="top">Container for a players area visitation memory.<br>
        </td>
      </tr>
      <tr>
        <td valign="top">DefaultSession<br>
        </td>
        <td valign="top">Connection object for handling a players telnet
session  with the mud<br>
        </td>
      </tr>
      <tr>
        <td valign="top">DefaultSocial<br>
        </td>
        <td valign="top">Object for a single social command.<br>
        </td>
      </tr>
      <tr>
        <td valign="top">DefaultTimeClock<br>
        </td>
        <td valign="top">Object representing a single calendar/time system
 that spans areas, possibly the whole world.<br>
        </td>
      </tr>
       
  </tbody>  
</table>
   
<p align="left"><font size="4"> </font><br>
  </p>
     
<p align="left"><font size="4"><br>
         </font></p>
         &nbsp; <img src="images/pencil.jpg">
                 
<p align="left"><a name="MOBS"><font color="blue" size="5"><strong>Commands:</strong></font></a></p>
                 
<p align="left"><font size="4">Commands are exactly what they sound like:
    LOOK, QUIT, KILL, GET, and all the other things you type into the mud
are    handled by CoffeeMud Commands. </font></p>
                 
<p><font size="4">A Custom Command may or may not belong to any particular 
    package, though it is important that the ID() of the Command be unique 
 in  the system.&nbsp; A custom Command imports the same packages mentioned 
 in  the first section of this document under Complete Default Import List 
 as well as com.planet_ink.coffee_mud.Commands.StdCommand.</font> </p>
                 
<pre>public class DoNothing extends com.planet_ink.coffee_mud.Commands.StdCommand<br>{<br>	public DoNothing(){}<br><br>	private String[] access={"DONOTHING"};<br>	public String[] getAccessWords(){return access;}<br>	<br></pre>
                 
<p><font size="4">All Commands should extend StdCommand for conformity's
sake, though it is not required so long as your class implements the com.planet_ink.coffee_mud.core.interfaces.Command 
    interface.&nbsp; In our example above, we have an empty constructor, but
   we do&nbsp;define some access words.</font> </p>
                 
<p><font size="4">Access words are what you think they are: the words which,
    when typed, allow the users to&nbsp;activate the command.&nbsp;&nbsp;We
  define  a string array containing one such access word in this case, and
 then define  our Command interface method getAccessWords() to return that
 array.&nbsp;&nbsp;Our  String array may contain as many strings as&nbsp;you
 would&nbsp;need to provide  sufficient words to activate this command.</font>&nbsp;</p>
                 
<pre>	public double actionsCost(){return 1.0;}<br>	public double combatActionsCost(){return 1.0;}<br>	<br>	public boolean canBeOrdered(){return true;}<br></pre>
                 
<p><font size="4">The next two&nbsp;methods, <font size="3">actionsCost</font>() 
    and <font size="3">combatActionsCost</font>(),&nbsp;designate how LONG 
 it  takes to execute this command.&nbsp; A value of 0 means that the command
   always happens instantly.&nbsp; A value greater than&nbsp;0 will always
 take  that many&nbsp;free actions&nbsp;to complete.&nbsp; A standard player
 may  perform&nbsp;1 action in a given 4 second period, or 2 actions during
 combat  in the default combat system -- they retain their 1 action per tick
 in other  combat systems).&nbsp; Action costs may be partial as well, costing
 0.5 (1/2  action) or other values.</font></p>
                 
<p><font size="4">The canBeOrdered() command designates whether this command
    represents an action which a creature or player might reasonably be ordered
    to do by another player.&nbsp; Archons and those with the "ORDER" security
    code are exempt from this flag.</font></p>
                 
<pre>	public boolean securityCheck(MOB mob)<br>	{<br>		return CMSecurity.isAllowed(mob,mob.location(),"IMMORT");<br>	}<br></pre>
                 
<p><font size="4">And speaking of security, this method returns whether or
    not the given mob may&nbsp;even have access to this command.&nbsp; If
the    securityCheck method returns false, the command&nbsp;and its access
words    will&nbsp;behave as if they do not even exist, returning "Huh?"&nbsp;should&nbsp;a
    player attempt to use it.&nbsp; Returning true, however, means only that
   the execute method below may be accessed.&nbsp; Any further security would
   have to be implemented there.</font> </p>
                 
<p><font size="4">In the above example, we call the isAllowed method in CMSecurity
    with the mob reference, the room in which the mob is located, and the
security    code "IMMORT".&nbsp; This asks the Security module whether this
mob, at  this  location, is authorized to perform functions designated by
the "IMMORT"  security  code.</font></p>
                 
<pre>	public boolean preExecute(MOB mob, Vector commands, int secondsElapsed, double actionsRemaining)<br>	   throws java.io.IOException;<br>	{<br>		if(secondsElapsed==0)<br>			mob.tell("You are preparing to do nothing.");<br>		if(secondsElapsed==3)<br>			mob.tell("You almost ready to do nothing.");<br>	}<br><br><br></pre>
                 
<p><font size="4">The preExecute method is very rarely implemented, but it
    is important to mention in light of the actionsCost() and combatActionsCost()
    values above. The purpose of the method is to give the player or the
room     status messages when the player does not yet have enough actions
to execute     the command.&nbsp; The method will be called immediately if
a player does     not&nbsp; have enough actions to execute the command, and
will present  a  secondsElapsed value of 0.&nbsp; It will then be called
again every second    or so with updated values until the player has enough
actions to proceed.</font><br>
         </p>
                 
<pre>	public boolean execute(MOB mob, Vector commands)<br>		throws java.io.IOException<br>	{<br>		String parameters=CMParms.combine(commands,1);<br>		if(parameters.length()==0)<br>			mob.tell("Nothing done.");<br>		else<br>			mob.tell("Nothing, not even '"+parameters+"', done.");<br>		return false;<br>	}<br>}<br></pre>
                 
<p><font size="4">Our last method is where the command actually does its
work.&nbsp; The mob given would be the MOB object trying to execute this
command, while commands is a Vector of parameters.&nbsp;</font> </p>
                 
<p><font size="4">The parameter commands is never null, and by convention
    is a Vector of strings starting with the access word used to execute
the    command.&nbsp; For instance, if the user entered:<br>
         <br>
         <em>donothing&nbsp;never "and always" never</em></font></p>
                 
<p><font size="4">The commands Vector would be size 4, and contain "donothing",
    "never", "and always", and "never" respectively.&nbsp; In the case of
this    command, we use one of the String utilities to recombine the last
3 parameters    back into one string "never and always never", and then issue
a message  to  the mob depending upon whether there were any parameters at
all.&nbsp;  Since  this command requires a command word to access it, it
is reasonable  to assume  that the 0th element in the commands vector is
the word "donothing",  which  means we can safely ignore it.</font></p>
                 
<p><font size="4">&nbsp;</font></p>
         <img src="images/smurf.jpg">
                 
<p align="left"><a name="MOBS"><font color="mediumslateblue" size="5"><strong>MOBs:</strong></font></a></p>
                 
<p align="left"><font size="4">MOBs, or "Moveable OBjects", are the creatures
    and characters which the players fight.&nbsp; In CoffeeMud, they are
among     the simpler objects to code.&nbsp; This is not because they are
uncomplex.&nbsp;     In fact, they are MOST complex.&nbsp; However, this
complexity comes due    to the myriad of Items, Behaviors, Properties, and
Abilities that are added    to them.&nbsp; Short of these numerous additions,
a MOB by himself is rather     simple!</font></p>
                 
<p align="left"><font size="4">This simplicity is important however, and
should be carefully considered before you run off to create new MOBs.&nbsp;
If you are creating a new MOB because you want a creature to have some new
kind of ability, then are you sure it is not a new Ability you want to write?&nbsp;
    If the new MOBs behavior is complex and unique, are you sure it's not
a  new  Behavior you wish to code? Otherwise, the best reasons to be coding
 MOBs are actually three: because you have a particular kind of monster that
 is used prolifically in your world, and you want to save memory by coding
 him as a special mob that extends StdMOB, or because you want to code special
   player capabilities by creating your own class that both extends StdMOB
 and  has an ID() of "StdMOB", or because you want to add special NPC monster
 capabilities   by creating your own class that extends GenMob and has an
ID() of "GenMob".</font></p>
                 
<p align="left"><font size="4">So, if you are sure this is what you want
to do, carry on!&nbsp; The directory for your custom coded MOB objects should
    be specified using the "MOBS" entry in the coffeemud.ini file.&nbsp;
See    the section above on Rebuilding CoffeeMud for more information on
this feature.</font></p>
                 
<p align="left"><font color="mediumslateblue" size="4"><strong>Coding a new
    MOB:</strong></font></p>
                 
<p><font size="4">A Custom MOB may or may not belong to any particular package,
    though it is important that the ID() of the MOB be unique in the system.&nbsp;
    A custom MOB&nbsp;<font size="4">imports the same packages mentioned
in   the  first section of this document under Complete Default Import List
as   well  as (in this case) com.planet_ink.coffee_mud.MOBS.StdMOB because
our   sample  mob extends it.</font> </font> </p>
                 
<p><font size="4">A MOB class must extend either <strong>StdMOB</strong> or
GenMob, <strong>StdShopKeeper</strong> or GenShopKeeper, <strong>StdRideable</strong> 
    or GenRideable depending on the basic capabilities, and customizability&nbsp;you
    would like.&nbsp; Although Generic objects are more customizable at run-time,
    they also take a long time for the system to load and build, and take
up   a lot of database disk space, and more memory.&nbsp; For this reason,
using    Standard instead of Generic whereever possible is always good. &nbsp;Another
    reason for extending StdMOB is because all players in the game use the
 "StdMOB"   class as a basis, which means that special player fields and
capabilities     can be coded by both extending the StdMOB class, and also
giving your custom    class an ID() of "StdMOB". &nbsp;If you do this, however,
make sure your   class is loaded after the %DEFAULT% list in your coffeemud.ini
file.&nbsp;   </font></p>
                 
<p><font size="4">As was stated, each unique MOB must also have a custom
"ID()" method as shown below.&nbsp; Notice that the ID() is the same as the
name of the class.&nbsp; This is no accident -- this is required!</font></p>
                 
<pre>public class MyNewMOB extends com.planet_ink.coffee_mud.MOBS.StdMOB <br>{ <br>	public String ID(){ return "MyNewMOB";}<br><br></pre>
                 
<p><font size="4">All of your customizing will be done inside the constructor:
    name, displayText, description, etc, etc.</font> <br>
         </p>
                 
<pre>public MyNewMOB()<br>{<br>	super();<br><br>	setName("a new mob"); <br>	setDescription("It`s furry with 2 legs"); <br>	setDisplayText("My new mob is standing here.");<br>		<br>	Factions.setAlignment(this,Faction.ALIGN_NEUTRAL);<br>	setMoney(0);<br>	setWimpHitPoint(2);<br>	baseEnvStats().setDamage(4);<br><br>	baseEnvStats().setAbility(0);<br>	baseEnvStats().setLevel(1);<br>	baseEnvStats().setArmor(30);<br>	baseEnvStats().setSpeed(1.0);<br>	baseEnvStats().setAttackAdjustment(30);<br>	baseEnvStats().setWeight(85);<br>	baseEnvStats().setSensesMask(EnvStats.CAN_SEE_DARK|EnvStats.CAN_SEE_INFRARED); <br>	baseEnvStats().setDisposition(EnvStats.IS_FLYING);<br>	baseCharStats().setCurrentClass(CMClass.getCharClass("Fighter"));<br>		<br>	baseCharStats().setMyRace(CMClass.getRace("Dog"));<br>	baseCharStats().getMyRace().startRacing(this,false);<br>	baseCharStats().setStat(CharStats.STAT_GENDER,(int)'F');<br>	baseCharStats().setStat(CharStats.STAT_STRENGTH,18); <br>	baseCharStats().setStat(CharStats.STAT_INTELLIGENCE,14);<br>	baseCharStats().setStat(CharStats.STAT_WISDOM,13);<br>	baseCharStats().setStat(CharStats.STAT_DEXTERITY,15);<br>	baseCharStats().setStat(CharStats.STAT_CONSTITUTION,12);<br>	baseCharStats().setStat(CharStats.STAT_CHARISMA,13);<br>	baseCharStats().setStat(CharStats.STAT_SAVE_COLD,50);<br><br>	baseState.setHitPoints(CMLib.dice().roll(baseEnvStats().level(),20,20));<br>	baseState.setMana(CMLib.dice().roll(baseEnvStats().level(),50,100));<br>		<br>	recoverMaxState();<br>	resetToMaxState();<br>	recoverEnvStats();<br>	recoverCharStats();<br>}<br></pre>
                 
<p><font size="4">You can see here that the basic stats have been filled
out, from level to attack speed, alignment and weight.&nbsp;&nbsp;For&nbsp;numeric
    values, higher is always better, except for Armor, which is always best
  low,  and comes down from 100.&nbsp; You'll notice above that two commands
  are required to set the Race of the creature.&nbsp; Also, you should realize
  that the numerous saving throws, and senses as well as dispositions (sneaking,
   hiding) are not represented above, but can easily be added using the format
   shown.</font></p>
                 
<p><font size="4">It is very important to note the last four commands.&nbsp;
    These commands "reset" the MOB, and "implement" the scores which are
given     in the several areas.&nbsp; "recoverEnvStats()", for instance,
must be  called   whenever a change is made to the "baseEnvStats()" object.&nbsp;
Ditto for   "CharStats" and "MaxState".&nbsp; </font></p>
                 
<p><font size="4">Now, suppose we wanted to add an Effect or Behavior or
Ability to your <strong style="font-weight: normal;">MOB</strong>.&nbsp;
The  proper place for such a statement would be in the same above constructor,
among the other commands.&nbsp; Preferably before the several "recover" commands,
    but after the several stat definitions. Of course, all of this is unnecesssary 
    for a new GenMOB object.</font></p>
                 
<pre>		<br>addNonUninvokableEffect(CMClass.getAbility("Fighter_Berzerk"));<br><br>Ability A=CMClass.getAbility("Prop_Resistance"); <br>if(A!=null) <br>{ <br>	A.setMiscText( "Fire 200%" ); <br>	addNonUninvokableEffect(A); <br>} <br>addAbility(CMClass.getAbility("Poison"));<br>	<br>addBehavior(CMClass.getBehavior("MudChat"));<br>addBehavior(CMClass.getBehavior("Mobile"));<br>addBehavior(CMClass.getBehavior("CombatAbilities"));<br></pre>
                 
<p><font size="4">The commands above will make the MOB permanently Berzerk,
    gives it the ability to Poison folks while in combat, allows the MOB
to   Chat  with other players, and&nbsp;to walk around in its area. The last
behavior    gives the MOB the wisdom to use its Poison ability while in combat.</font></p>
                 
<p><font size="4">If your MOB extends <strong>StdShopKeeper</strong> , you
    will need to add your inventory manually through the getShop() object
access    method as shown below. The getShop() method returns an instance
of the com.planet_ink.coffee_mud.Common.interfaces.CoffeeShop   interface,
which stores inventory for the shopkeepers.&nbsp; In creating   the shopkeepers,
 you will also need to specify the type of ShopKeeper. </font></p>
                 
<pre>setWhatIsSold(ShopKeeper.ONLYBASEINVENTORY);<br>		<br>Weapon sword=(Weapon)CMClass.getWeapon("Longsword");<br>getShop().addStoreInventory(sword,35,-1,this);<br>Armor mail=(Armor)CMClass.getArmor("FullPlate");<br>getShop().addStoreInventory(mail,35,-1,this);<br>Item waterskin=CMClass.getItem("Waterskin");<br>getShop().addStoreInventory(waterskin,35,-1,this);<br></pre>
                 
<p><font size="4">You'll recall from the Archon's Guide that there are many
    different types of ShopKeepers, including trainers, pet sellers, weaponsmiths,
    and others. </font></p>
                 
<p><font size="4"><strong>StdRideable</strong> MOBs will require a few other
    settings as well!</font></p>
                 
<pre>setRideBasis(Rideable.RIDEABLE_LAND);<br>setMobCapacity(2);<br></pre>
                 
<p><font size="4">The last thing is to give the MOB equipment, armor, and
    weapons.&nbsp; The following commands will do the trick!</font></p>
                 
<pre>Weapon sword=(Weapon)CMClass.getWeapon("Longsword");<br>addInventory(sword);<br>sword.wearIfPossible(this);<br>		<br>Armor mail=(Armor)CMClass.getArmor("FullPlate");<br>addInventory(mail);<br>mail.wearIfPossible(this);<br>		<br>Item sack=(Item)CMClass.getItem("StdContainer");<br>addInventory(sack);<br>		<br>Item waterskin=(Item)CMClass.getItem("Waterskin");<br>addInventory(waterskin);<br>waterskin.setContainer(sack);<br></pre>
                 
<p><font size="4">And THAT's all there is to creating a new standard MOB.
    Easy, huh? Well, obviously, the real complexity of MOBs comes when the
 Behaviors   and Abilities are programmed, but that is not covered here,
of  course. &nbsp;<br>
        </font></p>
               
<p><font size="4">There is also the advanced topic of extending the capabilities
    of the existing MOB classes. &nbsp;As mentioned previously, this consists
    in creating your own java classes with the same class name and ID() string
    methods as the base CoffeeMud MOB classes, and the adding the reference
  to  your custom class to the coffeemud.ini file's MOBS enter after the
%DEFAULT%     entry. &nbsp;Now, adding or extending the capabilities of these
classes   typically  means both adding your own methods, and extending the
importing   existing methods in those classes. &nbsp;The most important of
those existing   methods are discussed above in the Core Topics, namely okMessage,
executeMsg,   and tick. &nbsp;However, there are many other methods which
might be extended    to the end of altering or enhancing basic aspects of
the mud. &nbsp;Those    are numerated both in the classes you are extending,
and in com.planet_ink.coffee_mud.MOBS.interfaces.MOB.java.     &nbsp;Consult
the CoffeeMud java docs for more information.</font></p>
                 
<p><font color="mediumslateblue" size="4"><strong>Bringing MOBs to Life, and
Taking That Life Away:</strong></font></p>
                 
<p><font color="black" size="4">The following instructions are supplemental,
    and unnecessary. Once you have created your new MOB, modified your INI
 file,   and rebooted your CoffeeMud server, you need only use the CREATE
and other   Archon commands to make use of him. If, for some reason, you
want to know   HOW these commands do their work, however, here it is.</font></p>
                 
<p><font color="black" size="4">To bring a MOB into existence, a MOB must
    have somewhere to exist!&nbsp; Presumably, this is some room on your
map.&nbsp;     Rooms on the map are classes which implement the interface
com.planet_ink.coffee_mud.Locales.interfaces.Room.&nbsp;     If a MOB is
to have a permanent existence, it must also have a starting   room,  or a
place to rejuvinate into when necessary.&nbsp; If a MOB does  not have  a
starting room, then its death, when that death comes, &nbsp;will  be forever.</font></p>
                 
<pre>MOB mob=CMClass.getMOB("MyNewMOB");<br>Room room=CMLib.map().getRoom("Midgaard#3504");<br>	<br>mob.setStartRoom(room); // this mob will rejuvinate into this room.<br>mob.baseEnvStats().setRejuv(500); // 30 minutes rejuvination time<br>mob.recoverEnvStats(); // remember this command?!<br>	<br>mob.bringToLife(room,true); // tadah!<br></pre>
                 
<p><font size="4">And THAT's all there is to bring a standard mob to life.
    Now, generic items require an additional step: </font></p>
                 
<pre>Item item=CMClass.getItem("GenItem");<br>Room room=CMLib.map().getRoom("Midgaard#3504");<br>	<br>item.text();<br>item.recoverEnvStats();<br>room.addItem(item);<br>room.recoverRoomStats();<br></pre>
                 
<p><font size="4">The call to the text() method and the seemingly redundant
    call to Item.recoverEnvStats() (which we know is already in the item
constructor),     ensures that some of the internal structures of the Generic
MOB are properly     set. Of course, you may want to save this room to the
database to make  the   situation permanent, but all of this is usually done
from inside CoffeeMud     using the CREATE, MODIFY, and DESTROY commands
anyway. Speaking of destroy,     destroying a mob for good is even easier
than creating one: </font></p>
                 
<pre>Room room=CMLib.map().getRoom("Midgaard#3504");<br>for(int i=0;i&lt;room.numInhabitants();i++)<br>{<br>	MOB mob=room.fetchInhabitant(i);<br>	mob.destroy();<br>}<br></pre>
                 
<p align="left"><font size="5"><strong><img src="images/sword.jpg">
         </strong></font><font size="3">&nbsp;</font></p>
                 
<p align="left"><a name="ITEMS"><font color="orange" size="5"><strong>Items:</strong></font></a></p>
                 
<p><font size="4">A Custom Item may or may not belong to any particular package,
    though it is important that the ID() of the Item be unique in the system.&nbsp;
    A custom Item&nbsp;</font><font size="4"><font size="4">imports the same
   packages mentioned in the first section of this document under Complete
 Default  Import List as well as (in this case) com.planet_ink.coffee_mud.Items.Weapons.StdWeapon 
    because our first sample item extends it.</font></font> </p>
                 
<p><font size="4">An Item&nbsp;class must extend either <strong>StdItem</strong> 
    or GenItem, <strong>StdWeapon</strong> or GenWeapon, <strong>StdRideable</strong> 
    or GenRideable, <strong>StdArmor</strong> or GenArmor&nbsp;depending on
  the basic capabilities, and customizability&nbsp;you would like.&nbsp; Although
   Generic objects are more customizable at run-time, they also take a long
  time for the system to load and build, and take up a lot of database disk
  space.&nbsp; For this reason, using Standard instead of Generic whereever
  possible is always good. T</font><font size="4">here are generally two
good   reasons to be coding your own Items: because you have a particular
 kind of  item that is used prolifically in your world, and you want to save
 memory   by coding it as a special item that extends StdItem or StdWand,
or because   you want to code special item capabilities by creating your
own class that   both extends one of the base item classes and has the same
ID() string of   that class. &nbsp;&nbsp;</font><font size="4">The directory
for your custom   coded Item objects should be specified using the "ITEMS",
"WEAPONS", "ARMOR",   "CLANITEMS",&nbsp; or "MISCMAGIC" entries in the coffeemud.ini
 file.&nbsp;   See the section above on Rebuilding CoffeeMud for more information
 on this   feature.</font></p>
                 
<p><font size="4">Each Item must also have a custom ID() method as shown
below.&nbsp; Notice that the ID() is the same as the name of the class.&nbsp;
This is no accident -- this is required!</font></p>
                 
<pre>public class MyNewSword extends com.planet_ink.coffee_mud.Items.Weapons.StdWeapon <br>{ <br>	public String ID(){ return "MyNewSword";}<br>	public MyNewSword() <br>	{ <br>		super(); <br>	}<br>}<br></pre>
                 
<p><font size="4">All of your customizing will be done inside the constructor:
    name, displayText, description, etc, etc.</font></p>
                 
<pre>	<br>public MyNewSword()<br>{<br>	super();<br><br>	setName("a super sword"); <br>	setDescription("A long super duper sword!"); <br>	setDisplayText("Someone left their super sword here."); <br>	setSecretIdentity("");<br>	setMaterial(RawMaterial.RESOURCE_STEEL);<br>	setWeaponType(Weapon.TYPE_SLASHING);<br>	setWeaponClassigication(Weapon.CLASS_SWORD);<br>		<br>	setBaseValue(500);<br>	baseEnvStats().setDisposition(EnvStats.IS_GLOWING);<br>	baseEnvStats.setWeight(25);<br>	baseEnvStats.setAttackAdjustment(10);<br>	baseEnvStats.setDamage(15);<br>	recoverEnvStats();<br>}<br></pre>
                 
<p><font size="4">What is shown above is entirely sufficient for the creation
    of a normal <strong>StdWeapon</strong> . The material, weight, attack
and    damage describe it completely. You'll even notice that by setting
a disposition    flag, we have made the sword glow!&nbsp;&nbsp;Now, what
if we wanted a missile   weapon?</font></p>
                 
<pre>	<br>public MyNewBow()<br>{<br>	super();<br><br>	setName("a super bow");<br>	setDescription("A long super duper bow!"); <br>	setDisplayText("Someone left their super bow here.");<br>	setSecretIdentity("");<br>		<br>	setMaterial(RawMaterial.RESOURCE_OAK);<br>	setBaseValue(5000);<br>	baseEnvStats.setWeight(15);<br>	baseEnvStats.setAttackAdjustment(20);<br>	baseEnvStats.setDamage(5);<br>	setWeaponType(Weapon.TYPE_PIERCING);<br>	setWeaponClassigication(Weapon.CLASS_RANGED);<br>	setRanges(1,5);<br>	setAmmunitionType("arrows");<br>	recoverEnvStats();<br>}<br></pre>
                 
<p><font size="4">You'll notice we added two new methods, setRanges, and
setAmmunitionType. With the former, we specify that this is a ranged-only
weapon, usable from range 1 (0=melee) to range 5. The ammunition type specifies
that it uses arrows. Other classes, however, have different requirements
altogether. For instance, if class extends <span
 style="font-weight: bold;">com.planet_ink.coffee_mud.Items.Armor.</span><strong
 style="font-weight: bold;">StdArmor</strong>:</font> </p>
                 
<pre>public MyNewArmor()<br>{<br>	super();<br><br>	setName("a super bracer");<br>	setDescription("A super duper bracer"); <br>	setDisplayText("Someone left their super bracer here.");<br>	setSecretIdentity("");<br><br>	setMaterial(RawMaterial.RESOURCE_STEEL);<br>	setBaseValue(100);<br>	baseEnvStats.setWeight(5);<br>	baseEnvStats.setArmor(5);<br>	setRawProperLocationBitmap(Item.WORN_LEFT_WRIST|Item.WORN_RIGHT_WRIST);<br>	setRawLogicalAnd(false);<br>	recoverEnvStats();<br>}<br></pre>
                 
<p><font size="4">In this case, we made a bracer wearable on both left and
    right wrists. If it were something that could only be worn on both wrists
    at the same time (like handcuffs), then the RawLogicalAnd value would
have    been true. Now, a class extending <strong>com.planet_ink.coffee_mud.Items.Basic.StdContainer</strong>:</font></p>
                 
<pre>public MyNewBag()<br>{<br>	super();<br><br>	setName("a super bag");<br>	setDescription("A super duper bag"); <br>	setDisplayText("Someone left their super bag here.");<br>	setSecretIdentity("");<br>		<br>	setBaseValue(50);<br>	setLidsNLocks(false,true,false,false);<br>	setKeyName("");<br>	setMaterial(RawMaterial.RESOURCE_LEATHER);<br>	baseEnvStats.setWeight(1);<br>	setCapacity(100);<br>	recoverEnvStats();<br>}<br></pre>
                 
<p><font size="4">When setting the capacity of a container, remember that
    it must also be able to hold its own weight! Also, note the lids and
locks     flags have made this container lidless and lockless and always
open.&nbsp;     Of course, without a lock, setting a key would be silly!&nbsp;
Now, a&nbsp;     class extending&nbsp; <strong></strong></font><font
 size="4"><strong>com.planet_ink.coffee_mud.Items.Basic.</strong></font><font
 size="4"><strong>StdDrink</strong> will create a drinkable container:</font></p>
                 
<pre>public MyNewCup()<br>{<br>	super();<br><br>	setName("a super cup");<br>	setDescription("A super duper cup"); <br>	setDisplayText("Someone left their super bag here.");<br>	setSecretIdentity("");<br>		<br>	setMaterial(RawMaterial.RESOURCE_LEATHER);<br>	setBaseValue(5);<br>	setLiquidHeld(2000);<br>	setLiquidRemaining(2000);<br>	setThirstQuenched(500);<br>	setLiquidType(RawMaterial.RESOURCE_MILK);<br>	baseEnvStats.setWeight(1);<br>	setCapacity(0);<br>	recoverEnvStats();<br>}<br></pre>
                 
<p><font size="4">The <strong>StdDrink</strong> created above is an enormous
    cup of milk! You'll notice the capacity is 0, meaning that mundane objects
    cannot be stored in it. Now, a class extending <strong></strong></font><font
 size="4"><strong>com.planet_ink.coffee_mud.Items.Basic.</strong></font><font
 size="4"><strong>StdFood</strong>:</font></p>
                 
<pre>	<br>public MyNewFood()<br>{<br>	super();<br><br>	setName("a super crumb");<br>	setDescription("A super duper crumb");<br>	setDisplayText("Someone left their super crumbs.");<br>	setSecretIdentity("");<br>		<br>	setBaseValue(1);<br>	setMaterial(RawMaterial.RESOURCE_MEAT);<br>	setNourishment(500);<br>	baseEnvStats.setWeight(1);<br>	recoverEnvStats();<br>}<br></pre>
                 
<p><font size="4">Now, the items extending <strong></strong></font><font
 size="4"><strong>com.planet_ink.coffee_mud.Items.Basic.</strong></font><font
 size="4"><strong>StdRideable</strong> resemble the MOB of the same name,
    and thus, have identical modifications.</font></p>
                 
<pre>	<br>public MyNewBed()<br>{<br>	super();<br><br>	setName("a bed");<br>	setDescription("A bed");<br>	setDisplayText("A bed is here");<br>	setSecretIdentity("");<br>		<br>	setBaseValue(100);<br>	setMobCapacity(2);<br>	setRideBasis(Rideable.RIDEABLE_SLEEP);<br>	baseEnvStats.setWeight(100);<br>	recoverEnvStats();<br>}<br></pre>
                 
<p><font size="4">A pile of money extends class <strong></strong></font><font
 size="4"><strong>com.planet_ink.coffee_mud.Items.Basic.</strong></font><font
 size="4"><strong>StdCoins</strong>, and is simplest of all:</font></p>
                 
<pre>	<br>public MyNewMoney()<br>{<br>	super();<br><br>	setName("a pile of coins");<br>	setDescription("A pile of coins");<br>	setDisplayText("Someone left their money here.");<br>	setSecretIdentity("");<br>		<br>	setBaseValue(0);<br>	setMaterial(RawMaterial.RESOURCE_GOLD);<br>	setNumberOfCoins(1000); // 1000 coins!<br>	setDenomination(1.0); // each coin worth 1.0 basic gold<br>	baseEnvStats.setWeight(1);<br>	recoverEnvStats();<br>}<br></pre>
                 
<p><font size="4">Notice that the base value of the coins is 0, it's the
other methods that truely determine its value.&nbsp; Now, to make a magical
pill, our class should&nbsp; extend </font><font size="4"><strong>com.planet_ink.coffee_mud.Items.MiscMagic.</strong></font><font
 size="4"><strong>StdPill</strong>:</font></p>
                 
<pre>public MyNewPill()<br>{<br>	super();<br><br>	setName("a super pill");<br>	setDescription("A super duper pill");<br>	setDisplayText("Someone left their super pill.");<br>	setSecretIdentity("");<br>		<br>	setBaseValue(1);<br>	setMaterial(RawMaterial.RESOURCE_MEAT);<br>	setNourishment(500);<br>	baseEnvStats.setWeight(1);<br>	setSpellList("Spell_Sleep;Prayer_CureLightWounds");<br>	recoverEnvStats();<br>}<br></pre>
                 
<p><font size="4">The spells cast on the eater are listed by their Class
names, separated by semicolons. The secret identity is also trimmed out,
since the system will handle that automatically. Also notice that the <strong>StdPill</strong>
    resembles <strong>StdFood</strong> except for the addition of the setSpellList
    method. In the exact same way, the </font><font size="4"><strong>com.planet_ink.coffee_mud.Items.MiscMagic.</strong></font><font
 size="4"><strong>StdPotion</strong> class resembles the <strong>StdDrink</strong> 
    class except that it has an identical setSpellList method added to IT. 
 So,  in the interests of saving a little sand for future generations, I would
  enumerate the <strong>StdPotion</strong>. We can, however, show off another
  class which extends </font><font size="4"><strong>com.planet_ink.coffee_mud.Items.MiscMagic.</strong></font><font
 size="4"><strong>StdScroll</strong>:</font></p>
                 
<pre>	<br>public MyNewScroll()<br>{<br>	super();<br><br>	setName("a super scroll");<br>	setDescription("A super duper scroll"); <br>	setDisplayText("Someone	left their super scroll."); <br>	setSecretIdentity("");<br>	setBaseValue(100);<br>		<br>	setMaterial(RawMaterial.RESOURCE_PAPER);<br>	setUsesRemaining(50);<br>	baseEnvStats.setWeight(1);<br>	setScrollSpells("Spell_Sleep;Prayer_CureLightWounds");<br>	recoverEnvStats();<br>}<br></pre>
                 
<p><font size="4">Not too difficult, right? Looks like the other two, but
    the spell setting method has a different name. Now, let's look at a sample
    of a class extending </font><font size="4"><strong>com.planet_ink.coffee_mud.Items.MiscMagic.</strong></font><font
 size="4"><strong>StdWand</strong>:</font></p>
                 
<pre>	<br>public MyNewWand()<br>{<br>	super();<br><br>	setName("a wand");<br>	setDescription("A magic wand");<br>	setDisplayText("Someone left their magic wand.");<br>	setSecretIdentity("");<br>		<br>	setBaseValue(1000);<br>	setMaterial(RawMaterial.RESOURCE_OAK);<br>	baseEnvStats.setWeight(1);<br>	setSpell(CMClass.getAbility("Spell_Fireball"));<br>	setUsesRemaining(50);<br>	recoverEnvStats();<br>}<br></pre>
                 
<p><font size="4">In this case, we made use of the "uses remaining" field
    to set the number of charges for the wand. The way the spell is set is
 also   different. A wand may only have one spell, and the actual Ability
object  for the spell must be passed in, instead of just the class name as
we did  before. You will find that this is also how the classes extending
</font><font size="4"><strong>com.planet_ink.coffee_mud.Items.MiscMagic.</strong></font><font
 size="4"><strong>StdStaff</strong> work. The <strong>StdStaff</strong> resembles
    the <strong>StdWeapon</strong> we did above, except that the additional
  setSpell  and setUsesRemaining calls become appropriate to the constructor.
  </font></p>
                 
<p><font size="4">The next thing we will look at is adding effects and behaviors
    to Items.&nbsp; Behavior addition (despite the fact that there is really
   only one behavior that works with Items) will look familiar. The only
difference     between this and the MOB example above is the fact that we
are setting  a  parameter on the Behavior before adding it. </font></p>
                 
<pre>	<br>Behavior B=CMClass.getBehavior("Emoter");<br>B.setParms("min=1 max=20 chance=75;makes strange sounds");<br>addBehavior(B);<br></pre>
                 
<p><font size="4">Adding normal effects as properties is also similar to
mobs...</font></p>
                 
<pre>	<br>Ability A=CMClass.getAbility("Prop_HaveResister");<br>A.setMiscText("fire acid 50%");<br>A.addNonUninvokableEffect(A);<br></pre>
                  
<p><font size="4">The above Effect will allow anyone who owns the item to
    resist fire and acid at 50%!&nbsp; And again, as with mobs, these commands
    are best put in the constructor of the item before the recoverEnvStats()
   call.</font></p>
               
<p><font size="4">There is also the advanced topic of extending the capabilities 
    of the existing Item classes. &nbsp;As mentioned previously, this consists
    in creating your own java classes with the same class name and ID() string
    methods as the base CoffeeMud Item classes, and the adding the reference
   to your custom class to the relevant coffeemud.ini file's entries after
 the  %DEFAULT% string. &nbsp;Now, adding or extending the capabilities of
 these  classes typically means both adding your own methods, and extending
 the importing   existing methods in those classes. &nbsp;The most important
 of those existing   methods are discussed above in the Core Topics, namely
 okMessage and executeMsg.   &nbsp;However, there are many other methods
which  might be extended to the   end of altering or enhancing basic aspects
of the mud. &nbsp;Those are numerated   both in the classes you are extending,
in com.planet_ink.coffee_mud.Items.interfaces.Item.java,   and in other interface
 files in that directory. &nbsp;Consult the CoffeeMud   java docs for more
 information.</font></p>
               
<p><font color="orange" size="4"><strong>Creating and Destroying Items:</strong></font></p>
                 
<p><font color="black" size="4">As with mobs, the following instructions
are supplemental, and unnecessary. Once you have created your new Item, modified
    your INI file, and rebooted your CoffeeMud server, you need only use
the    CREATE and other Archon commands to make use of it. If, for some reason,
  you want to know HOW these commands do their work, however, here it is.</font></p>
                 
<p><font color="black" size="4">To bring an&nbsp;Item into existence, an
item&nbsp;must have somewhere to exist!&nbsp; Items can belong to either
Rooms, as mobs are, or they can belong to mobs themselves.&nbsp; This means
that Items actually have two different creation mechanisms.&nbsp; Here is
an example of each, starting with the creation of an Item in a Room:</font></p>
                 
<pre>Item item=CMClass.getItem("MyNewItem");<br>Room room=CMLib.map().getRoom("Midgaard#3504");<br>	<br>room.addItem(item);<br>room.recoverRoomStats();<br></pre>
                 
<p><font size="4">A room is grabbed off the map, and the item is added to
    the room using the addItem() method. Then the room recover is called
to   make  the room react to the addition of the item.&nbsp;&nbsp; Now, generic
  items  require an additional step: </font></p>
                 
<pre>Item item=CMClass.getItem("GenItem");<br>Room room=CMLib.map().getRoom("Midgaard#3504");<br>	<br>item.text();<br>item.recoverEnvStats();<br>room.addItem(item);<br>room.recoverRoomStats();<br></pre>
                 
<p><font size="4">The call to the text() method and the seemingly redundant
    call to Item.recoverEnvStats() (which we know is already in the item
constructor),     ensures that some of the internal structures of the Generic
Item are properly     set. Of course, these items are one-shot items, meaning
that they are not    generated to exist on the map forever and ever. </font></p>
                 
<pre>Item item=CMClass.getItem("MyNewItem");<br>Room room=CMLib.map().getRoom("Midgaard#3504");<br>	<br>item.baseEnvStats().setRejuv(500); // 30 minutes rejuvination time<br>item.recoverEnvStats();<br>room.addItem(item);<br>room.recoverRoomStats();<br>room.startItemRejuv();<br></pre>
                 
<p><font size="4">In this case, we wanted the item to be rejuvinating. That
    means that, when the item is removed from the room by a player, the item
   will reset at some point in the future. If the rejuv ticks count is set
 to  0, the item will not reset. In the example above, the count is set to
 500  so that the item will reset. However, the rejuvination is not actually
 activated   until the room item rejuvs are set. This is done with the last
 method call   to startItemRejuv(), which handles the rejuv resets on all
items in the room.</font>  </p>
                 
<p><font size="4">In the previous section, we saw how items are given to
mobs by simply calling the addInventory() method, so this will not be repeated.
    Regardless of where or how the item is created, however, it is destroyed
   the same way. With a simple call to the destroy() method on the item.
Here    is an example of destroying all the items in a room. </font></p>
                 
<pre>Room room=CMLib.map().getRoom("Midgaard#3504");<br><br>for(int i=room.numItems()-1;i&gt;=0;i--)<br>{<br>	Item item=room.fetchItem(i);<br>	item.destroy();<br>}<br><br></pre>
                 
<p align="left"><font size="5"><strong><img src="images/clown.jpg">
         </strong></font><font size="3">&nbsp;</font></p>
                 
<p align="left"><a name="BEHAVS"><font size="5"><strong><font
 color="blue">Behaviors:</font></strong></font></a></p>
                 
<p align="left"><font size="4">A Behavior is defined as a property of an
item, mob, exit, or room which takes proactive (as opposed to REactive) steps
on behalf of its host.&nbsp; Examples of Behaviors include aggressiveness,
mobility, auto-emoting, and scripting.&nbsp; </font><font size="4"><font
 size="4">Behaviors import the same packages mentioned in the first section
 of this document under Complete Default Import List as well as (in this
case)  com.planet_ink.coffee_mud.Behaviors.StdBehavior because our sample
behavior  extends it</font></font><font size="4">. &nbsp;Custom behaviors
are loaded at boot-time by adding references to them to the BEHAVIORS entry
in your coffeemud.ini file. &nbsp;Let's take a look at a sample Behavior and
see how they are put together:</font></p>
                 
<pre><br>public class Ravenous extends com.planet_ink.coffee_mud.Behaviors.StdBehavior<br>{<br>	public String ID(){return "Ravenous";}<br>	public String name(){return "Ravenous Eater";}<br>	<br></pre>
                 
<p align="left"><font size="4">Our first step, as seen above, is to make
sure we define an ID() method with the classes name, just as we do in other
CoffeeMud objects.&nbsp; Notice that the ID() is the same as the name of
the class.&nbsp; This is no accident -- this is required!&nbsp; The next
step is to give the Behavior a name, which is entirely unimportant to players,
but helpful for Archons.&nbsp; </font></p>
                 
<pre>	protected int canImproveCode(){return Behavior.CAN_MOBS;}<br>	public long flags(){return 0;}<br>	public boolean grantsAggressivenessTo(MOB M){return false;}<br></pre>
                 
<p align="left"><font size="4">Next are some important flags that tell the
    CoffeeMud system some important things about your behavior.&nbsp; The
first    method (<font size="3"><font size="4">canImproveCode)</font> </font>tells 
    the behavior whether it is properly used on Mobs, or Items, Rooms, Exits,
    or all of these.&nbsp; In this case, our behavior only affects mobs.&nbsp;
    The next method (flags) tells the system certain things about the behavior
    by returning values such as Behavior.FLAG_MOBILITY, or Behavior.FLAG_TROUBLEMAKING.&nbsp;
    The last method (grantsAggressivenessTo) says whether or not this method
   would necessary cause the host mob to attack the mob (M) in the parameter.</font></p>
                 
<pre>	public void startBehavior(Environmental forMe) <br>	{}<br></pre>
                 
<p align="left"><font size="4">The next method, seldom used, is still quite
    important.&nbsp; startBehavior receives as its parameter the brand new
 host   of this behavior.&nbsp; If the behavior instance needs to do any
variable     or other preparation to either the behaving object host (forMe)
or itself,     it should do so here.&nbsp; <br>
         </font></p>
                 
<pre>	public String getParms(){return super.getParms();}<br>	public void setParms(String parameters)<br>	{super.setParms(parameters);}<br></pre>
                 
<p align="left"><font size="4">These methods, part of the StdBehavior and
    Behavior interface, are shown here just to make you aware of how parameter
    strings passed to behaviors are accessed. Sometimes prepatory code is
also    executed inside a setParms method, for instance.&nbsp; Normally these
methods    would not appear in your own instance of a Behavior.</font><br>
         </p>
                 
<pre>	public boolean tick(Tickable ticking, int tickID)<br>	{<br>		MOB mob=getBehaversMOB(ticking); // returns mob, if ticking is a mob. Returns mob owner, if ticking is an item<br>		Room room=getBehaversRoom(ticking); // whatever the ticking object is, this will return its location<br>		if((mob==null)||(room==null)||(tickID!=Host.MOB_TICK))<br>			return super.tick(ticking,tickID);<br></pre>
                 
<p align="left"><font size="4">Now we get to the nitty gritty of the Behaviors
    work.&nbsp; A behavior gets all or almost all of its work done in a tick
   method.&nbsp; If you have not read the Core Topic above about the tick
method,   you should definitely do so!&nbsp; In this example, we call two
internal  StdBehavior methods to get some important starting information
about the behaving object host of the behavior.&nbsp; In this example, our&nbsp;behaving
 object&nbsp;host&nbsp;will be a mob.&nbsp; However, these methods may still
 intelligently return Item owners, or Exit rooms if the host is other than
 a mob.&nbsp; The ticking parameter will always be the behaving object host.</font></p>
                 
<p align="left"><font size="4">The next line checks to see if our host mob
    exists, and is in a room.&nbsp; We also check to see if the tickID is
the    valid mob ticking id.&nbsp; If our host had been an Item, Exit, or
Room,   this tickID would no longer be Tickable.TICKID_MOB, but would be
Tickable.TICKID_ITEM_BEHAVIOR,&nbsp;    Tickable.TICKID_ROOM_BEHAVIOR, or
Tickable.TICKID_EXIT_BEHAVIOR.&nbsp; Since   our host, in this case, is a
Mob, we check for Tickable.TICKID_MOB.</font></p>
                 
<pre>		if((!canActAtAll(mob))<br>		||(!canFreelyBehaveNormal(mob)))<br>			return super.tick(ticking,tickID);<br>			<br></pre>
                 
<p align="left"><font size="4">Our next step is to call a couple more internal
    StdBehavior methods.&nbsp; The first (canActAtAll) returns true if the
 mob   is alive, awake, and mobile.&nbsp; The second method (canFreelyBehaveNormal)
    returns true if the mob is not currently in combat, not charmed or following
    anyone, and is not severely injured.&nbsp; We want our ravenous mob to
 follow   this behavior only in the best of health and mood.</font></p>
                 
<pre>		Item eatible=null;<br>		for(int i=0;i&lt;mob.inventorySize();i++)<br>		{<br>			Item I=mob.fetchInventory(i);<br>			if((I!=null)&amp;&amp;(I instanceof Food))<br>				eatible=I;<br>		}<br></pre>
                 
<p align="left"><font size="4">Next, we iterate through the mob's inventory
    to find the last instance of a piece of food.</font></p>
                 
<pre>		if(eatible!=null)<br>		{<br>			room.show(mob,eatible,null,"&lt;S-NAME&gt; gobble(s) up &lt;T-NAMESELF&gt;.");<br>			return true;<br>		}<br></pre>
                 
<p align="left"><font size="4">If some food was found, the mob will eat it.&nbsp;
    Now, practically speaking, the mob will quickly devour and use up any
and    all food which it may have had to begin with.&nbsp; What we decide
to do   when the mob does NOT have food, therefore, is just as important.</font></p>
                 
<pre>		int randMob=CMLib.dice().roll(1,room.numInhabitants(),-1);<br>		MOB mobToHitUp=room.fetchInhabitant(randMob);<br>		if((mobToHitUp==null)<br>		||(mobToHitUp==mob)<br>		||(CMLib.dice().rollPercentage()&gt;75))<br>			return true;<br></pre>
                 
<p align="left"><font size="4">Since our mob is hungry, and another mob is
    the most likely source of food, we will pick a random inhabitant of the
  room,  which is not ourselves, 25% of the time. Otherwise, we just return
  true, and try again on the next tick.</font></p>
                 
<pre>		<br>		int randItem=CMLib.dice().roll(1,mobToHitUp.inventorySize(),-1);<br>		Item I=mobToHitUp.fetchInventory(randItem);<br>		if((I!=null)&amp;&amp;(I instanceof Food))<br>			eatible=I;<br>		<br>		if(eatible==null) return true;<br></pre>
                 
<p align="left"><font size="4">Next we will pick a random piece of inventory
    from that mob, and see if it is food.&nbsp; If not, we return true and
 try   again on the next tick.</font></p>
                 
<pre>		CMLib.commands().postSay(mob,mobToHitUp,"May I have some of your "+eatible.name()+"?",false,false);<br>				  <br>		return true;<br>	}<br></pre>
                 
<p align="left"><font size="4">And lastly, since we have picked a random
mob in the room, and seen that he has food, we will ask him for it!&nbsp;
If it's a player, then perhaps he might even give us some.&nbsp; If we are
given food, we will eat it on the next tick for sure!</font></p>
                 
<pre>	public void executeMsg(Environmental affecting, CMMsg msg)<br>	{}<br>	public boolean okMessage(Environmental oking, CMMsg msg)<br>	{	return true; }<br>}<br></pre>
         <font size="4"> </font>         
<p align="left"><font size="4">The above two methods are shown here just to
remind you that, although a behavior's PRIMARY purpose is to be proactive
    in a tick method, a behavior also has the ability to preview and respond
   to messages affecting the host behaving object. That object will always
 be  identified in the affecting and oking parameters respectively. If these
 two  methods mean nothing to you, you should definitely go back and read
the Core  Topic on message passing. </font></p>
                 
<p align="left"><font size="5"><strong><img src="images/cloak.jpg">
         </strong></font><font size="3">&nbsp;</font></p>
                 
<p align="left"><a name="CLASSES"><font color="purple" size="5"><strong>Character 
    Classes:</strong></font></a></p>
                 
<p align="left"><font size="4">A Character Class, in CoffeeMud, is the carreer
    being followed by the player.&nbsp;&nbsp; Armor and weapon choices, skill
    and spell access, as well as score advancements all depend on the Character
    Class chosen by the player.&nbsp; Thankfully,&nbsp;despite all this weighty
    responsibility, Character Classes are not difficult to code.&nbsp; CharClasses 
    </font><font size="4"><font size="4">import the same packages mentioned 
  in  the first section of this document under Complete Default Import List 
  as well as (in this case) com.planet_ink.coffee_mud.CharClasses.StdCharClass 
   because our sample class extends it</font></font><font size="4">. &nbsp;Your 
   custom classes need to be listed in your coffeemud.ini file under the CHARCLASSES
   entry. &nbsp;Aside from making custom classes, you can also extend an
existing    class, return an identical ID() string, and then list it at the
end of the   aforementioned entry in the coffeemud.ini file. &nbsp; Now,
let's take a  look at a simple one here:</font></p>
                 
<pre><br>public class NormalGuy extends com.planet_ink.coffee_mud.CharClasses.StdCharClass<br>{<br></pre>
                 
<p align="left"><font size="4">Our Normal Guy character class will define
    all of the basic elements of a filled-out character class.&nbsp;</font></p>
                 
<pre>public String ID(){return "NormalGuy";}<br>public String baseClass(){return ID();}<br></pre>
                 
<p align="left"><font size="4">The first methods above are the unique Character
    Class ID and the Base Class ID of the class. The Class ID must be a unique
    identifier. The baseClass method takes a bit of explaining. If your CoffeeMud
    system is using the default SubClassing system, the baseClass will define
    which classes may be switched between by a player, as well as which classes
    are available to choose from when a new player is created. Fighter, Monk,
    Paladin, Ranger, and Barbarian, for instance, all have a baseClass of
"Fighter".    This means that the Fighter class is one of the classes which
may be chosen    by a new player (since it's ID() and baseClass() are the
same), and that   any of the baseClass() "Fighter" classes may switch amongst
each other. If  your CoffeeMud system is using the multi-class or single
classing system,   this method is irrelevant.</font></p>
                 
<pre>public String name(){return "Normal Guy";}<br>public String name(int classLevel){return name();}<br><br></pre>
             
<p align="left"><font size="4">Our next method, name(), is the default displayable
    name of your class.&nbsp; The next method name(int classLevel) is, in
this    case, simply returning the default name again.&nbsp; However, if
you like,    your&nbsp;character classes may have different names at different
class  levels.&nbsp;&nbsp;  Simply check the classLevel and return a different
string!&nbsp;  As standard  practice, however, class level 0 should always
return the default  name.&nbsp;  Remember that Class Levels are different
from Player Levels.&nbsp;  A Player  may, in a multi-classing system, have
numerous levels in numerous  classes.&nbsp;  The Class Level represents how
many levels the player has  gained in this character class ONLY!</font></p>
                 
<pre>protected String[] names=null;<br><br>public String[] nameSet()<br>{<br>    if(names!=null) return names;<br>    names=new String[1];<br>    names[0]=name();<br>    return names;<br>}<br><br></pre>
             
<p align="left"><font size="4">The nameSet method really only needs to be 
   extended and re-impemented when there are more than 1 available names for
   your class. &nbsp;Its purpose is to return a string list of all the names
   that this class may go by. &nbsp; As you can see from the above code,
by   default, the StdCharClass will nicely handle classes with just one name.
 &nbsp;However, the code above will need to be altered in your own character
 class if you choose to make one with multiple names.</font></p>
             
<pre>public int getHPDivisor(){return 3;}<br>public int getHPDice(){return 1;}<br>public int getHPDie(){return 6;}<br></pre>
                 
<p align="left"><font size="4">Next come the hit point ranges.&nbsp;&nbsp;When
    a player with this class gains a level,these values will determine hit
 points   gained based on class and constitution.</font></p>
                 
<pre>public int getPracsFirstLevel(){return 3;}<br>public int getTrainsFirstLevel(){return 1;}<br>public int getBonusPracLevel(){return 0;}<br></pre>
                 
<p align="left"><font size="4">The next two methods define the starting Training
    and Practice points for this Character Class. The BonusPracLevel method
  tells  us how many bonus practices (above the number determined the WISDOM/4
  formula)  which the player will receive every level.</font></p>
                 
<pre>public int getAttackAttribute(){return CharStats.STAT_STRENGTH;}<br>public int getBonusAttackLevel(){return 1;}<br></pre>
                 
<p align="left"><font size="4">And here is an method defining which of the
    6 primary Character Attributes (Strength, Intelligence, Wisdom, Dexterity,
    Constitution, or Charisma) are used to determine any attack bonuses whenever
    the player gains a level.&nbsp; Usually this is Strength. The number
of   bonus  attack points received by a player when a level is gained is
determined   by  dividing the players score in this attribute by 6, and then
adding the   value  returned by getBonusAttackLevel(). </font></p>
                 
<pre>public int getManaDivisor(){return 3;}<br>public int getManaDice(){return 1;}<br>public int getManaDie(){return 6;}<br></pre>
                 
<p align="left"><font size="4">These methods determines how much mana a player
    receives when they gain a level in this class. </font></p>
                 
<pre>public int getLevelsPerBonusDamage(){ return 25;}<br></pre>
                 
<p align="left"><font size="4">This score determines how many levels a player
    must make, in this class, before they will gain a bonus point of damage
  to  all damage rolls. </font></p>
                 
<pre>public int getMovementMultiplier(){return 2;}<br></pre>
                 
<p align="left"><font size="4">And lastly for our scores, this method will
    determine how many movement points a player receives when they gain a
level.    The formula is determined by dividing the player's strength score
by 9,  and  multiplying the result by this value. </font></p>
                 
<pre>public int allowedArmorLevel(){return CharClass.ARMOR_CLOTH;}<br></pre>
                 
<p align="left"><font size="4">The CharClass interface defines a method called
    "armorCheck" which returns true if the player is in compliance with armor
    requirements. This method does its work by checking the allowedArmorLevel
    method. This method returns an equate defined in the CharClass interface
   which may specify ANY armor, CLOTH level, armor, LEATHER (or worse) armor,
   or NON-METAL armor. You should check the CharClass interface for any other
   ARMOR_* definitions which may be added from time to time. </font></p>
                 
<pre>public int allowedArmorLevel(){return CharClass.ARMOR_CLOTH;}<br>protected int requiredArmorSourceMinor(){return -1;}<br>protected String armorFailMessage(){return "<s-name> fumble(s) <s-his-her> <skill> due to <s-his-her> armor!";}<br></s-his-her></skill></s-his-her></s-name></pre>
                 
<p align="left"><font size="4">The The StdCharClass will automatically enforce
    armor requirements whenever a class skill is used, provided these methods
    are defined. The allowedArmorLevel() method returns an equate defined
in   the CharClass interface which may specify ANY armor, CLOTH level, armor,
  LEATHER (or worse) armor, METAL-ONLY, or NON-METAL armor. You should check
  the CharClass interface for any other ARMOR_* definitions which may be
added   from time to time. </font></p>
                 
<p align="left"><font size="4">While the armorFailMessage() method is pretty
    self explanatory, the requiredArmorSourceMinor may not be. The later
method     returns the MINOR code of the SOURCE code of the message generating
the   skill  use. Typically this method will either return -1 for non spell
casters,   or  CMMsg.TYP_CAST_SPELL for spell casters. See the Core Topics
for more  information  on what the heck a source code of a message might
be. </font></p>
                 
<pre>public int allowedWeaponLevel(){return CharClass.WEAPONS_THIEFLIKE;}<br><br>private HashSet disallowedWeapons=buildDisallowedWeaponClasses();<br>public HashSet disallowedWeaponClasses(MOB mob){return disallowedWeapons;}<br><br>private HashSet requiredWeaponMaterials=buildRequiredWeaponMaterials();<br>public HashSet requiredWeaponMaterials(){return requiredWeaponMaterials;}<br><br></pre>
                 
<p align="left"><font size="4">The StdCharClass will automatically enforce
    weapon restrictions whenever a weapon attack is made, provided these
methods     are defined. The allowedWeaponLevel() method returns an equate
defined  in   the CharClass interface which may specify ANY weapons, DAGGER
only, THIEF-like   weapons, WOODEN weapons, and several others. You should
check the CharClass   interface for other WEAPONS_* definitions which may
be added from time to   time. </font></p>
                 
<p align="left"><font size="4">The disallowedWeaponClasses(MOB mob) and requiredWeaponMaterials()
    methods return HashSet objects which, due to the method calls in StdCharClass
    seen above, are totally derivative of the value you already put in allowedWeaponLevel().
    In other words, so long as you include the allowedWeaponLevel() method,
  you  should also include those next four methods, exactly as you see them.
  </font></p>
                 
<pre>public int availabilityCode(){return Area.THEME_FANTASY;}<br></pre>
                 
<p align="left"><font size="4">The method availabilityCode defines how players
    can access this race.&nbsp; Possible values for this constant include:
 'Area.THEME_FANTASY'   (makes the class&nbsp;available for players to choose
 when creating fantasy   characters), 'Area.THEME_FANTASY|Area.THEME_SKILLONLYMASK'
 (makes the class   available to spells or Skills, but not for&nbsp;player
 creation), or '0'  (the class is not available to spells or for player creation.)&nbsp;</font></p>
                 
<pre>private static boolean abilitiesLoaded=false;<br>public boolean loaded(){return abilitiesLoaded;}<br>public void setLoaded(boolean truefalse){abilitiesLoaded=truefalse;};<br>	<br>public NormalGuy()<br>{<br>	super();<br>	maxStat[CharStats.STAT_CHARISMA]=10;<br>	if(!loaded())<br>	{<br>		setLoaded(true);<br>		CMLib.abilityMapper().addCharAbilityMapping(ID(),1,"Skill_Write",50,"",true,false,new Vector(),"");<br>		CMLib.abilityMapper().addCharAbilityMapping(ID(),1,"Skill_Recall",0,"",true,false,new Vector(),"");<br>		CMLib.abilityMapper().addCharAbilityMapping(ID(),1,"Skill_Climb",0,"",true,false,new Vector(),"");<br>		CMLib.abilityMapper().addCharAbilityMapping(<br>					ID(),         // class/race to assign the skill to<br>					1,            // level the skill is qualified for<br>					"Skill_Swim", // the java ID of the ability to qualify for<br>					0,            // default profficiency to give after gaining<br>					"",           // any misc parameters to pass to the Skill_Swim skill<br>					false,        // true for the class to gain automaticall, false to qualify<br>					false,        // whether this skill is unlisted for this class<br>					CMParms.parseSemicolons("Skill_Climb;Skill_Write",true), <br>						      //  list of skills required to gain this one           <br>					"-LOCALE +UNDERWATER" <br>						      // mask to apply to class members wanting this skill<br>					);<br>	}<br>}<br></pre>
                 
<p align="left"><font size="4">And now, after a few methods to flag our construction,
    work, we come to our constructer! The Constructer for every class has
a  couple  of important parts. The first is to define any special maximums
for  the primary  attributes. This is done by setting the appropriate value
in  the maxStat[]  array for the class. By default, 18 is the maximum score
for  all primary attributes.</font> </p>
                 
<p> </p>
                 
<p align="left"><font size="4">The second part establishes the qualifying
    and bonus skills for the class. This is done through repeated calls to
 one   of the several&nbsp; &nbsp;&nbsp;&nbsp; CMLib.abilityMapper().addCharAbilityMapping
    methods. The first parameter of the method is the ID() value of the Character
    Class itself, followed by the level at which this class gains or qualifies
    for the skill. Next is the ID() value of the Ability to allow this class
   to qualify for, followed by the default profficiency which this class
displays     in the skill (typically 0). The next parameter are any special
parameters     that affects the way this class uses the skill, followed by
a&nbsp;boolean     which&nbsp;establishes whether the player will receive
this skill automatically     when he or she gains the appropriate level,
or whether they merely qualify     for the skill.&nbsp;&nbsp; The next&nbsp;
parameter, almost always false,     determines whether the skill is "secret"
for this class.&nbsp;&nbsp; Secret     skills are qualified for (or gained),
but do not appear on Qualify lists,     Class information, or Help files.&nbsp;
Secret skills are never taught  by   Guildmasters (MOBTeachers) unless specifically
told to.&nbsp; The next  parameter   is a Vector of Strings, representing&nbsp;
a list of skills which  must be   known by this class before he can learn
the skill in question.&nbsp;   The  last parameter is a String representing
a mask which must be passed  by the  person who wants to gain this skill.<br>
         </font></p>
                 
<pre>public Vector getSecurityGroups(int classLevel)<br>{<br>    if(classLevel&gt;1000)<br>    {<br>		Vector V=new Vector();<br>		V.addElement("ABOVELAW");<br>		V.addElement("LISTADMIN");<br>		return V;<br>    }<br>    else<br>		return new Vector();<br>}<br></pre>
                 
<p align="left"><font size="4">The purpose of this method is to allow you
    to assign CoffeeMud Security Flags or CoffeeMud Security Groups to your
  players  based on their Character Class and Character Class Level.&nbsp;
 This is a  rather obscure feature that is really only meant for special
Character    Classes  you may design for your admins and builders.&nbsp;
Your player  getSecurityGroups()   methods will normally just return an empty
Vector regardless  of classLevel.&nbsp;&nbsp;   In this case, however, we
are demonstrating how a player who gains 1001 levels  in our NormalGuy Class
will become immune  to the CoffeeMud legal system (ABOVELAW  flag) and gain
access to the Archon  LIST command (LISTADMIN flag).&nbsp;&nbsp;  See the
Archon's Guide for more  information on the CoffeeMud security system.</font></p>
                 
<pre>public String statQualifications(){return "Warm body, breathe.";}<br>public boolean qualifiesForThisClass(MOB mob, boolean quiet)<br>{<br>	if(!CMLib.flags().canBreathe(mob))<br>	{<br>		if(!quiet)<br>			mob.tell("You need to be breathing to be a normal guy.");<br>		return false;<br>	}<br>	return super.qualifiesForThisClass(mob,quiet);<br>}<br></pre>
                 
<p align="left"><font size="4">The next method is a display string, for the
    benefit of some of the web macros, which describes in plain english any
  attribute,  or other numeric qualifications to become this class. The qualifiesForThisClass
    method would actually check and enforce the qualifications described
by   statQualifications.  In our example above, there are no stat qualifications,
  only a check to see  if the idiot is still breathing. Also note that a
quiet   boolean exists to  allow qualifications to be checked without sending
any   messages to the player  in question. </font></p>
                 
<pre>public String otherBonuses(){return "Receives a mortgage, but no home.";}<br></pre>
                 
<p align="left"><font size="4">The next method, like statQualifications above,
    is for the benefit of the web macros. It describes any special bonuses
 received   due to being this class. </font></p>
                 
<pre>public Vector outfit(MOB myChar)<br>{<br>	if(outfitChoices==null)<br>	{<br>		outfitChoices=new Vector();<br>		Weapon w=(Weapon)CMClass.getWeapon("a mortgage");<br>		outfitChoices.addElement(w);<br>	}<br>	return outfitChoices;<br>}<br></pre>
                 
<p align="left"><font size="4">The outfit method should return a Vector of
    any Class-Specific Item object equipment they may need. Clothing and
so   forth  is actually covered by Races. </font></p>
                 
<pre>public void grantAbilities(MOB mob, boolean isBorrowedClass)<br>{<br>	super.grantAbilities(mob,isBorrowedClass);<br>	if(mob.isMonster())<br>	{<br>		Vector V=CMLib.abilityMapping().getUpToLevelListings(ID(),<br>			mob.charStats().getClassLevel(ID()),<br>			false,<br>			false);<br>		for(Enumeration a=V.elements();a.hasMoreElements();)<br>		{<br>			Ability A=CMClass.getAbility((String)a.nextElement());<br>			if((A!=null)<br>			&amp;&amp;((A.classificationCode()&amp;Ability.ALL_ACODES)!=Ability.ACODE_COMMON_SKILL)<br>			&amp;&amp;(!CMLib.abilityMapping().getDefaultGain(ID(),true,A.ID())))<br>				giveMobAbility(mob,<br>					       A,<br>					       CMLib.abilityMapping().getDefaultProfficiency(ID(),true,A.ID()),<br>					       CMLib.abilityMapping().getDefaultParm(ID(),true,A.ID()),<br>					       isBorrowedClass);<br>		}<br>	}<br>}<br></pre>
                 
<p align="left"><font size="4">This important method is called whenever a
    player gains a level in this class, or when an NPC mob is being "outfitted"
    with this class via one of the following Behaviors: CombatAbilities,
Fighterness,     Druidness, Bardness, Clericness, Thiefness, Mageness. </font>
</p>
                 
<p align="left"><font size="4">The "grantAbilities" method has the important
    job of making sure that players receive their autogained skills or any
 other   options skills when they level.&nbsp; The StdCharClass version of
 grantAbilities   (called by super.grantAbilities(...);) takes care of any
 autogained skills   up to the player or mobs current level in the class.&nbsp;
 Each char class   which extends this, however, needs to take care of any
skills or abilities   for NPC mobs which are not automatically gained.&nbsp;
This is to make up   for the fact that npc mobs will not be lining up at
your guildmasters to  spend their trains on skills they merely qualify for.&nbsp;
 In the sample  code above, we give the mobs every skill the class qualifies
 for up to the  mobs level in the class, except for any common skills.&nbsp;
 Those would still need to be given by hand to each mob.</font><font
 size="4"> </font></p>
                 
<pre>public boolean okMessage(Environmental myHost, CMMsg msg)<br>{<br>	if(!(myHost instanceof MOB)) return super.okMessage(myHost,msg);<br>	MOB myChar=(MOB)myHost;<br>	if((msg.amITarget(myChar)) <br>	&amp;&amp;(msg.targetMinor()==CMMsg.TYP_DAMAGE) <br>	&amp;&amp;((msg.sourceMinor()==CMMsg.TYP_COLD) <br>		||(msg.sourceMinor()==CMMsg.TYP_WATER))) <br>	{ <br>		int recovery=myChar.charStats().getClassLevel(this); <br>		msg.setValue(msg.value()-recovery); <br>	} <br>	else <br>	if((msg.amITarget(myChar)) <br>	&amp;&amp;(msg.targetMinor()==CMMsg.TYP_DAMAGE) <br>	&amp;&amp;(msg.sourceMinor()==CMMsg.TYP_FIRE)) <br>	{ <br>		int recovery=msg.value(); <br>		msg.setValue(msg.value()+recovery); <br>	} 	<br>	return super.okMessage(myChar,msg);<br>}<br></pre>
                 
<p align="left"><font size="4">And lastly, just as I'm sure you were wondering
    how useful those three Core Topics above would really be, we see them
in   active use. Some classes contain methods such as these to enforce some
of   the benefits for the class. In the okMessage method, whic we discussed
in   the first Core Topic, we see messages messages containing the type of
damage   taken by the player being intercepted. TYP_DAMAGE messages always
have their   damage amounts stored in the .value() method of a message, so
it is these   values which are modified, based on the type of damage taken.</font></p>
                 
<p align="left"><font size="4">And not least, although we won't go into it
    in detail here, there are two other methods which may be of use for the
  advanced  Character Class programmer. They are the level and unLevel methods.
  These  methods are called when a player gains or loses (respectively) a
level  in  the class. If there are any extra skills or bonus scores the player
may  wish  to gain and lose with levels, that would be the place for such
code.  Also,  in some cases (Mages and Clerics come to mind), the gaining
of qualifying    skills may be somewhat complex. In those cases, overriding
the gainAbilities    method may be in order. Check the Mage and Cleric classes
for more information.    </font></p>
                 
<p align="left"><font size="5"><strong><img src="images/dragon.jpg">
         </strong></font><font size="3">&nbsp;</font></p>
                 
<p align="left"><a name="RACES"><font color="green" size="5"><strong>Races:</strong></font></a></p>
                 
<p align="left"><font size="4">A Race, in CoffeeMud, contributes very little
    to functionality, but quite a bit to the role playing and other "soft"
 aspects   of the game..&nbsp;&nbsp; For this reason, everyone is encouraged
 to code   as many races as humanly possible. The more, the better!&nbsp;
Races </font><font size="4"><font size="4">import the same packages mentioned
in the first section of this document under Complete Default Import List
as well as (in this case) com.planet_ink.coffee_mud.Races.StdRace because
our sample class extends it</font></font><font size="4">.</font><font
 size="4"> &nbsp;</font><font size="4">Your custom races need to be listed
 in your coffeemud.ini file under the RACES entry. &nbsp;Aside from making
 custom race classes, you can also extend an existing race class, return
an  identical ID() string, and then list it at the end of the aforementioned
entry in the coffeemud.ini file. &nbsp; </font><font size="4">Now, let's
take a look at a simple one here:</font></p>
                 
<pre><br>public class Grumbler extends com.planet_ink.coffee_mud.Races.StdRace<br>{<br></pre>
                 
<p align="left"><font size="4">Our Grumbler race will define all of the basic
    elements of a filled-out race.&nbsp;</font></p>
                 
<pre>public String ID(){	return "Grumbler"; }<br>public String name(){ return "Grumbler"; }<br>public String racialCategory(){return "Grumbler";}<br>protected static Vector resources=new Vector();<br>public int availabilityCode(){return Area.THEME_FANTASY;}<br></pre>
                 
<p align="left"><font size="4">The first methods return the unique ID of
the Race (which must always match the java/class file name) and the name()
method is the displayable name of the Race.&nbsp; The third method is very
important, as it defines the category into which this race falls.&nbsp; There
is no hard rule to determine when a new category should be created versus
using an old one.&nbsp; Some of the uses of racial categories include the
Ranger Favored Enemy skill, as well as most of the race-based restrictions
on doors and with shopkeepers.&nbsp; In many ways, the racial category is
more important than the name of the race itself, if functionality is considered.&nbsp;
</font></p>
                 
<p align="left"><font size="4">The last method list above, availabilityCode,
    defines how players can access this race.&nbsp; Possible values for this
   constant include: 'Area.THEME_FANTASY' (makes the race&nbsp;available
for    players to choose when creating fantasy characters), 'Area.THEME_FANTASY|Area.THEME_SKILLONLYMASK'
    (makes the race available to spells such as Polymorph or Wish, but not
 for&nbsp;player   creation), or '0' (the race is not available to spells
or for player creation.)&nbsp;</font></p>
                 
<pre>protected int shortestMale(){return 84;}<br>protected int shortestFemale(){return 78;}<br>protected int heightVariance(){return 80;}<br>protected int lightestWeight(){return 2000;}<br>protected int weightVariance(){return 500;}<br></pre>
                 
<p align="left"><font size="4">These methods, as you might have guessed,
establish parameters for the base height and weight of a typical monster
of this type.&nbsp; A random number from 0-heightVariance() will be added
to the shortedMale/shortestFemale value to determine height, while a random
number from 0-weightVariance will be added to lightestWeight to determine
that.</font></p>
                 
<pre>protected long forbiddenWornBits(){return Item.WORN_WIELD|Item.WORN_WAIST<br>				   |Item.WORN_ABOUT_BODY|Item.WORN_FEET<br>				   |Item.WORN_HANDS;}<br></pre>
                 
<p align="left"><font size="4">This method establishes where a creature of
    this type may NOT wear something.&nbsp; In this case, we forbid any wielded
    items, or anything worn around the waist, on hands or feet,&nbsp;or about
    the body.&nbsp; Anywhere else is fine.&nbsp; Return 0 if you do not wish
   any restrictions on wearing.</font></p>
                 
<pre>	private static final int[] parts={0,2,2,1,1,0,0,1,4,4,1,0,1,1,1,2};<br>	public int[] bodyMask(){return parts;}<br></pre>
                 
<p align="left"><font size="4">The bodyMask method defines and returns an
    array of integers which defines the types and number of particular body
  parts  normally retained by the race.&nbsp; Each position in the array
is   defined  by the equates BODY_ in the Race interface.&nbsp; These equates
 are (starting  from 0): <font size="3">BODY_ANTENEA, BODY_EYE, BODY_EAR,
BODY_HEAD, BODY_NECK,  BODY_ARM, BODY_HAND, BODY_TORSO, BODY_LEG, BODY_FOOT,
BODY_NOSE, BODY_GILL,  BODY_MOUTH, BODY_WAIST, BODY_TAIL, BODY_WING</font>.
Remember that these can be found in the Race interface for you to reference.&nbsp;
  In the above example, we find no antenea, 2 eyes, 2 ears, a head, neck,
no  arms or hands, a torso, 4 legs, 4 feet, anose, but&nbsp;no gill, and
then  a mouth, waist, tail, and 2 wings.</font></p>
                 
<pre>	private String[] racialAbilityNames={"Skill_Trip","Fighter_Whomp"};<br>	private int[] racialAbilityLevels={1,3};<br>	private int[] racialAbilityProfficiencies={75,50};<br>	private boolean[] racialAbilityQuals={false,false};<br>	<br>	protected String[] racialAbilityNames(){return null;}<br>	protected int[] racialAbilityLevels(){return null;}<br>	protected int[] racialAbilityProfficiencies(){return null;}<br>	protected boolean[] racialAbilityQuals(){return null;}<br>	<br>	public Vector racialAbilities(MOB mob)<br>	{<br>		Vector V=super.racialAbilities(mob);<br>		return V;<br>	}<br></pre>
                 
<p align="left"><font size="4">Our next section here deals with Racial Abilities,
    which are defined as follows: A racial ability is a skill that has a
command     word, and is not autoinvoked.&nbsp; A racial ability may be qualified
for    or automatically gained.&nbsp; If the&nbsp;skill is qualified for,
then  upon  reaching the designated player level, the player may GAIN the
skill,  and will have a default profficiency as designated.&nbsp; If the
skill is  not qualified for, then it is automatically gained.&nbsp; This
means that  all mobs or players of this race, who have obtained the necessary
player level, will have access to the use of the skill as if they had learned
it, and at the profficiency designated.&nbsp; Racial Abilities are available
to any mob or player of this race, even those affected by Shape Shift, Polymorph,
   or similar skills.</font></p>
                 
<p align="left"><font size="4">The first four methods define these skills.&nbsp;
    The data in all four variables are ordered with relative to each other.&nbsp;
    The racialAbilityNames is a list of the Ability class ID.&nbsp; The racialAbilityLevels
    is the level at which the skill is qualified for or gained.&nbsp; The
racialAbilityProfficiencies    is the profficiency of skills automatically
gained.&nbsp; The racialAbilityQuals    tells whether or not the skill is
automatically gained (false) or is only    qualified for (true).</font></p>
                 
<p align="left"><font size="4">The method above (racialAbilities) will return
    a Vector of Ability objects, with profficiency already set, appropriate
  to  the mob passed in.&nbsp; This vector should consist only of automatically
    gained abilities appropriate to the level of the mob.&nbsp; If the four
  variables  are set properly, the programmer will not need to override the
  method from  StdRace unless there other gender-based or other special qualifications
  for  skills not defined by those four variables.</font></p>
                 
<pre>public Vector outfit(MOB myChar)<br>{<br>	if(outfitChoices==null)<br>	{<br>		outfitChoices=new Vector();<br>		Weapon w=(Weapon)CMClass.getItem("GenPants");<br>		outfitChoices.addElement(w);<br>	}<br>	return outfitChoices;<br>}<br></pre>
                 
<p align="left"><font size="4">The outfit method should return a Vector of
    any Race-Specific Item object equipment they may need. </font></p>
                 
<pre>	private String[] culturalAbilityNames={"Dwarven","Mining"};<br>	private int[] culturalAbilityProfficiencies={100,50};<br>	<br>	public String[] culturalAbilityNames(){return culturalAbilityNames;}<br>	public int[] culturalAbilityProfficiencies(){return culturalAbilityProfficiencies;}<br></pre>
                 
<p align="left"><font size="4">Cultural Abilities are defined as those skills
    which a mob or player of this race would know through upbringing in the
  culture  of that race, such as language.&nbsp; Players Shape Shifted or
Polymorphed    into the race, since they did not grow up in the culture,
would not have   automatic access to these skills per se.&nbsp; These two
methods are defined   similarly to the Racial Abilities above.&nbsp; </font></p>
                 
<pre>public void affectEnvStats(Environmental affected, EnvStats affectableStats)<br>{<br>	super.affectEnvStats(affected,affectableStats);<br>	affectableStats.setSensesMask(affectableStats.sensesMask()<br>					|EnvStats.CAN_SEE_INFRARED);<br>}<br></pre>
                 
<p align="left"><font size="4">This sample of the affectEnvStats method we
    discussed in the Core Topics above makes sure that all creatures of this
   race can see in the infrared spectrum.</font></p>
                 
<pre>public void affectCharStats(MOB affectedMOB, CharStats affectableStats)<br>{<br>	super.affectCharStats(affectedMOB, affectableStats);<br>	affectableStats.setStat(CharStats.STAT_STRENGTH,15);<br>	affectableStats.setStat(CharStats.STAT_DEXTERITY,25);<br>	affectableStats.setStat(CharStats.STAT_INTELLIGENCE,5);<br>}<br></pre>
                 
<p align="left"><font size="4">This sample of the affectCharStats&nbsp;method
    we discussed in the Core Topics above establishes a base strength, dexterity,
    and intelligence for all creatures of this race.&nbsp; As this is the
ONLY    way to modify a MOBs stats short of magical equipment, it should
be used   with care!</font></p>
                 
<pre>	<br>public void startRacing(MOB mob, boolean verifyOnly)<br>{<br>	super.startRacing(mob,verifyOnly);<br>}<br></pre>
                 
<p align="left"><font size="4">startRacing is called whenever a player of
    this race logs on, or a mob of this race is created.&nbsp; If there are
  any  special properties of the mob or player which must be set due to their
  being  this race, this would be the appropriate method in which to do so.&nbsp;
   This method is not called for Polymorph, Shape Shift, or similar changes
  in race, but only for those whose permanent race is this one.</font></p>
                 
<pre>	<br>public Weapon myNaturalWeapon()<br>{<br>	if(naturalWeapon==null)<br>	{<br>		naturalWeapon=CMClass.getWeapon("StdWeapon");<br>		naturalWeapon.setName("huge claws");<br>		naturalWeapon.setWeaponType(Weapon.TYPE_PIERCING);<br>	}<br>	return naturalWeapon;<br>}<br></pre>
                 
<p align="left"><font size="4">This method allows you to create (see item
    creation above) a special weapon to serve the creature whenever they
are    not wielding something.&nbsp; Since our Grumbler cannot wield weapons
anyway,     it is important to give them some big piercing claws.</font></p>
                 
<pre>	  <br>public String healthText(MOB mob) <br>{<br>	double pct=(CMath.div(mob.curState().getHitPoints(),<br>			     mob.maxState().getHitPoints())); <br>	if(pct&lt;.10) <br>		return "^r" + mob.name()+"^ris raging in bloody pain!^N"; <br>	else <br>	if(pct&lt;.20) <br>		return "^r" + mob.name()+"^ris covered in blood.^N"; <br>	else <br>	if(pct&lt;.30) <br>		return "^r" + mob.name() + "^r is bleeding badly from lots of wounds.^N"; <br>	else <br>	if(pct&lt;.50) <br>		return "^y" + mob.name() + "^y has some bloody wounds and gashed scales.^N"; <br>	else <br>	if(pct&lt;.60) <br>		return "^p" + mob.name() + "^p has a few bloody wounds.^N";<br>	else <br>	if(pct&lt;.70) <br>		return "^p" + mob.name() + "^p is cut and bruised heavily.^N";<br>	else <br>	if(pct&lt;.90) <br>		return "^g" + mob.name() + "^g has a few bruises and scratched scales.^N";<br>	else <br>	if(pct&lt;.99)<br>		return "^g" + mob.name() + "^g has a few small bruises.^N";<br>	else<br>		return "^c" + mob.name() + "^c is in perfect health.^N";<br>}<br></pre>
                 
<p align="left"><font size="4">Although the programmer is welcome to skip
    the above method and use the defaults from the StdRace class, this allows
    you to set special health messages for creatures of this type.</font></p>
                 
<pre>public Vector myResources()<br>{<br>	synchronized(resources)<br>	{<br>		if(resources.size()==0)<br>		{<br>		resources.addElement(makeResource("a "+name().toLowerCase()+"<br>				 claw",RawMaterial.RESOURCE_BONE)); <br>		for(int i=0;i&lt;10;i++)<br>			resources.addElement(makeResource("a strip of "<br>				+name().toLowerCase()+" hide",<br>				RawMaterial.RESOURCE_SCALES));<br><br>		for(inti=0;i&lt;10;i++)<br>			resources.addElement(makeResource("a pound of "<br>				 +name().toLowerCase()+" meat",<br>				 RawMaterial.RESOURCE_MEAT));<br><br>		resources.addElement(makeResource("some "<br>			 +name().toLowerCase()+" blood",<br>			 RawMaterial.RESOURCE_BLOOD));<br>		}<br>	}<br>	return resources;<br>}<br></pre>
                 
<p align="left"><font size="4">The above method allows you to  determine
what sorts of materials are gotten from this creature whenever the dead corpse
   is Butchered. &nbsp;<br>
      </font></p>
           
<p align="left"><font size="4">Now, in addition to the methods above which
   are good to include in your custom races, there are also several methods
  which are not normally extended or overridden, but which is may be good
to  do so in special cases. &nbsp;These methods include </font>public void
level(MOB   mob) <font size="4">,which is called whenever a player of that
race gains   a level, </font>public void agingAffects(MOB mob, CharStats
baseStats, CharStats   charStats)<font size="4"> , which is called</font><font
 size="4"> to enforce   how aging effects this race, and </font>public DeadBody
 getCorpseContainer(MOB   mob, Room room);<font size="4">, which is called</font><font
 size="4"> to   create a corpse for members of this race.</font></p>
                 
<p align="left">&nbsp;</p>
                 
<p align="left"><strong><img src="images/chomper.jpg">
         </strong><font size="3">&nbsp;</font></p>
                 
<p align="left"><a name="EXITS"><font color="navy" size="5"><strong>Exits:</strong></font></a></p>
                 
<p align="left"><font size="4">Exits are the connecting points between two
    rooms, and tend to be rather simple.&nbsp; If two rooms, A &amp; B,&nbsp;are
    connected to each other, there are always two exits associated with that
   connection.&nbsp; One from room A to room B, and the other from room B
to   room A.&nbsp; </font></p>
                 
<p align="left"><font size="4">Exits </font><font size="4"><font
 size="4">import the same packages mentioned in the first section of this 
    document under Complete Default Import List as well as (in this case) 
com.planet_ink.coffee_mud.Exits.StdExit    because our sample class extends 
it</font></font><font size="4">.</font><font size="4"> &nbsp;</font><font
 size="4">Here is an example exit:</font></p>
                 
<pre><br>public class SlidingDoor extends com.planet_ink.coffee_mud.Exits.StdExit<br>{<br>	public String ID(){	return "SlidingDoor";}<br>	public SlidingDoor()<br>	{<br>		super();<br>		Ability A=CMClass.getAbility("Prop_ReqHeight"));<br>		A.setMiscText("30");<br>		addNonUninvokableEffect(A);<br>	}<br>	public String name(){return "a sliding door";}<br>	public String displayText(){return "";}<br>	public String closedText(){return "a closed sliding door";}<br>	public String doorName(){return "door";}<br>	public String openName(){return "slide";}<br>	public String closeName(){return "slide";}<br>	public boolean hasADoor(){return true;}<br>	public boolean hasALock(){return false;}<br>	public boolean defaultsLocked(){return false;}<br>	public boolean defaultsClosed(){return true;}<br>	public int openDelayTicks(){return 45;}<br>}<br></pre>
                 
<p align="left"><font size="4">As you can see, exits are very simple.&nbsp;
    A set of variables and parameters are sufficient to establish every function
    of an exit, and these are already well defined in the Archon's Guide.&nbsp;
    This is due primarily to the fact that several Properties and Behaviors
  give  an exit most of its color and complexity.</font></p>
                 
<p align="left"><font size="4">Exits, like all other Environmental objects,
    get to preview and execute messages. They will only tend to listen for
 messages   dealing with OPENING or CLOSING where the exit is the target,
or ENTERING   and LEAVING where the exit is the tool. If a player is going
from room A  to room B. The player message will note that he or she is ENTERING
 the exit  in room A and LEAVING the exit in room B. Although this makes
perfect   sense  to me, it may sound a little backwards from the intuitive
way. Since   Room  objects&nbsp;(Locales) are almost always the target of
ENTER and LEAVE   messages,  exits are subordinated to being the tools of
such messages.</font></p>
                 
<p align="left"><font size="4">Exits will never tick, by and large, unless
    they have a door that defaults closed and the door is opened, or they
gain    some sort of Behavior (such as Emoter).</font></p>
                 
<p align="left"><font size="4"><font size="5"><strong><img
 src="images/scenery.jpg">
         </strong></font><font size="3">&nbsp;</font></font></p>
                 
<p align="left"><font size="4"><a name="ROOMS"><font color="red"
 size="5"><strong>Locales:</strong></font></a></font></p>
                 
<p align="left"><font size="4"><font size="4">Locales are the stuff rooms
    are made of, and so they implement the interface Room.&nbsp;&nbsp; There
   are actually four different general types of locales: the standard room,
  the standard  grid, the "thin" grid, and the standard maze.&nbsp; Each
of   those respectively is a functional  superset of the former respectively.
 Rooms </font></font><font size="4"><font size="4">import the same packages
 mentioned in the first section of this  document under Complete Default
Import  List as well as (in this case) com.planet_ink.coffee_mud.Rooms.StdGrid,</font></font><font
 size="4"><font size="4"> com.planet_ink.coffee_mud.Rooms.StdRoom, or</font></font><font
 size="4"><font size="4"> </font></font><font size="4"><font size="4">com.planet_ink.coffee_mud.Rooms.StdMaze,</font></font><font
 size="4"><font size="4"> because our sample classes extends them</font></font><font
 size="4">.</font></p>
                 
<p align="left"><font size="4">Let's looks at an example of a standard grid
    room, which has much of the functionality we are interested in:</font></p>
                 
<pre>public class RoadGrid extends com.planet_ink.coffee_mud.Locales.StdGrid<br>{<br>	public String ID(){return "RoadGrid";}<br>	public RoadGrid()<br>	{<br>		super();<br>		name="a road";<br>		baseEnvStats.setWeight(1);<br>		recoverEnvStats();<br>	}<br>	public String getChildLocaleID(){return "Road";}<br>	public Vector resourceChoices(){return Road.roomResources;}<br>	public int domainType(){return Room.DOMAIN_OUTDOORS_PLAINS;}<br>	public int domainConditions(){return Room.CONDITION_NORMAL;}<br>}<br></pre>
                 
<p align="left"><font size="4">Here we see the standard RoadGrid.&nbsp; It's
    effects, behaviors, displaytext, description, and (since it is a grid
type)    size in the x and y are all defined by the builder.&nbsp; The features
 (and   they aren't many) which are available to the coder can be seen here.&nbsp;
    We see the base weight being set to "1" here.&nbsp; This is the default
  number  of movement points consumed by crossing this room.&nbsp; For Grids,
  we see  the Locale ID of the child-rooms inside the grid.&nbsp; We also
see  the standard  room settings methods for the domain type (the type of
locale  it is) and the domain conditions (the quality of the weather, or
the air,  wetness, dryness,  etc).&nbsp; </font></p>
                 
<p align="left"><font size="4">The Resource choices for this room are borrowed
    from the Road itself, though this will never be used.&nbsp; Players will
   never actually be inside the Grid room itself, but will always occupy
one    of the child rooms, each of which will take direction from the parent
Grid.&nbsp;     If you wish to define resources, however, be aware that the
resourceChoices     vector returned may not be null, and must only contain
Integer objects  representing   the Resource (see the Items.interfaces.RawMaterial.java
interface)  available  there.&nbsp; Use the  RESOURCE_* static integer values
from RawMaterial  interface.</font></p>
                 
<p align="left"><font size="4"><font size="4">Here are another set of useful
    methods:</font></font></p>
                 
<pre><font size="4"><font size="4"><small>	public String roomTitle() <br>	public String roomDescription() </small></font></font></pre>
                 
<p align="left"><font size="4"><font size="4"><font size="4">These methods&nbsp;return
    the title and description of the room&nbsp;respectively.&nbsp; These
methods     are responsible for making the title and description&nbsp;into
a proper   displayable  format.&nbsp; They draw on the values of the room
object&nbsp;displayText()     and description() methods respectively, then
parse that data&nbsp;for any&nbsp;special    display codes, though often
that data is simply&nbsp;passed through.&nbsp;</font></font></font></p>
                 
<p align="left"><font size="4">The executeMsg, and okMessage methods on rooms
    are also available, as they are in all Environmental objects, for customized
    message handling&nbsp;as described in the Core Topics above.</font></p>
                 
<p align="left"><font size="4">&nbsp;</font></p>
                 
<p align="left"><font size="5"><strong><img src="images/area.jpg">
         </strong></font><font size="3">&nbsp;</font></p>
                 
<p align="left"><a name="AREAS"><font color="gray" size="5"><strong>Areas:</strong></font></a></p>
                 
<p align="left"><font size="4">The Area objects, which represent areas in
    the game, are the most difficult to advise about regarding programming.&nbsp;
    <br>
         </font></p>
                 
<p align="left"><font size="4">However, an attempt must be made.&nbsp; Therefore,
    we will go over some of the methods and features available on the Area
 object,   which might be overridden for some other use. Areas </font><font
 size="4"><font size="4">import the same packages mentioned in the first section
of this document under Complete Default Import List</font></font><font
 size="4">.</font></p>
                 
<pre>public class StdArea implements Area<br>{<br>	public String ID(){	return "StdArea";}<br>	<br>	[...]<br>	<br>	public Climate getClimateObj();<br>	public int climateType();<br>	public void setClimateType(int newClimateType);<br></pre>
                 
<p align="left"><font size="4">Of course, like every Environmental object,
    the Area must define an ID().&nbsp; Notice that the ID() is the same
as   the  name of the class.&nbsp; This is no accident -- this is required!&nbsp;
  The  name, display text, description, and others are all handled by the
builder,    or Properties or behaviors, and aren't pertinant to this discussion
of Areas.</font></p>
                 
<p align="left"><font size="4">The weather, however, is a relative function
    of each area.&nbsp; Each area knows its current weather object (see the
  Climate  interface) as well as the next weather change "in the que".&nbsp;
  These can  be read and set by the methods in the Climate object.&nbsp;
Each   area also  knows it climatic "tendencies", and this also can be set
and read  from the  area itself.&nbsp; Lastly, a method exists on the Climate
object  to force  the area to cycle through its weather, which will force
the "next"   weather  code to become current, and establish a new "next"
weather code.</font></p>
                 
<pre>	public int getTechLevel();<br>	public void setTechLevel(int level);<br></pre>
                 
<p align="left"><font size="4">These will return the technical level allowed
    in the area, whether it be magic, technology, or both.</font></p>
                 
<pre>	public String getArchivePath();<br>	public void setArchivePath(String pathFile);<br></pre>
                 
<p align="left"><font size="4">The Archive name of the area is set and read
    from the area, though it's more properly set by the builder.</font> <br>
         </p>
                 
<pre>	public TimeClock getTimeObj();<br></pre>
                 
<p align="left"><font size="4">Similar to Climate above, each area has a
reference to a TimeClock object which contains information about local time.
Unlike the Climate, however, StdAreas all share the same Time object, meaning
that time is global. However, the object exists here in case you want local
time areas. </font></p>
                 
<pre>	public void toggleMobility(boolean onoff);<br>	public boolean getMobility();<br></pre>
                 
<p align="left"><font size="4">These methods define whether Mobile mobs will
    move around.&nbsp; By toggling mobility off, no mob or player&nbsp;in
the    whole area will move from room to room for any reason, allowing a
good base   state for builders to work from.</font></p>
                 
<pre>	public StringBuffer getAreaStats();<br></pre>
                 
<p align="left"><font size="4">If the data, appearance, or format of the
HELP provided for areas needs to be changed, the getAreaStats() method is
where to generate a new one.</font></p>
                 
<pre>	public Enumeration getMetroMap();<br>	public int metroSize();<br>	public Room getRandomMetroRoom();<br></pre>
                 
<p align="left"><font size="4">These methods provide access to all of the
    rooms in the given area, plus all of the rooms in any child areas, plus
  any  rooms in their children areas and so forth.</font></p>
                 
<pre>	public void fillInAreaRooms();<br>	public void fillInAreaRoom(Room R);<br><br>	public Enumeration getProperMap();<br>	public int properSize();<br>	public Room getRandomProperRoom();<br>	public void clearMetroCache();<br></pre>
                 
<p align="left"><font size="4">The first two methods are called in order
to perform finalizing clean-up or resetting of room structures.&nbsp; The
remaining methods provide access to the set of rooms which are directly a
part of this area. &nbsp;The last method is one which should be called if
any proper rooms are ever added, since it clears and "re-calculates" the
metro rooms list.</font></p>
                 
<pre>	public void addSubOp(String username);<br>	public void delSubOp(String username);<br>	public boolean amISubOp(String username);<br>	public String getSubOpList();<br>	public void setSubOpList(String list);<br>	public Vector getSubOpVectorList();<br></pre>
                 
<p align="left"><font size="4">And lastly, the list of staff (Area Archons
    they are also sometimes called), can be managed from here.&nbsp; Changing
    these methods would modify how staff are handled by Areas.</font></p>
                 
<p align="left">&nbsp;</p>
                 
<p align="left"><strong><font size="5"><img src="images/house.jpg">
         </font><font size="3">&nbsp;</font></strong></p>
                 
<p align="left"><a name="PROPS"><font color="olive" size="5"><strong>Properties:</strong></font></a></p>
                 
<p align="left"><font size="4">Properties are the simplest of the objects
    which implement the Ability interface, and are defined as effects which
  can  be permanently tacked-on to items, mobs, and other Environmental objects.&nbsp;
    Properties are Abilities, but they are never qualified for by classes,
 never   gained as skills, and never wear off or disappear when a mob dies.&nbsp;
   They are always added to a mob, item, room, etc using the Environmental
 interface   method "addNonUninvokableEffect(Ability)" method either inside
 a custom coded  Environmental object, or at run-time to a GenMob, GenItem,
 Room, or similar&nbsp;type  object.</font></p>
                 
<p align="left"><font size="4">Properties and Behaviors are often the basic
    building blocks of the customized GenMob and GenItem in CoffeeMud, and
 differ   from each other in this basic respect: Properties tend to have
a  smaller  memory footprint and&nbsp;tend to react to events affecting their
 hosts rather  than cause their hosts to take proactive actions.&nbsp; Properties
  make heavy  use of the message handlers and stat affecting methods.&nbsp;
  If you have  not read the Core Topics above already, you should do so now.</font></p>
                 
<p align="left"><font size="4">A Custom property may or may not belong to
    any particular package, though it is important that the ID() of the property
    be unique in the system. Properties </font><font size="4"><font
 size="4">import  the same packages mentioned in the first section of this
   document under Complete  Default Import List as well as (in this case)
com.planet_ink.coffee_mud.Properties.Property    because our sample class
extends it</font></font><font size="4">.</font></p>
                 
<p><font size="4">A customized property class must extend the Property class
    implemented in the aforementioned package.&nbsp; This Property class
already     implements the Ability interface, and already has dummy methods
for most    of the Ability interface methods which are unnecessary or are
unused in  a  Property.</font></p>
                 
<p><font size="4">Each property must also have custom "ID()", and "name()"
    methods as shown below.&nbsp; Notice that the ID() is the same as the
name    of the class.&nbsp; This is no accident -- this is required!</font></p>
                 
<pre>public class Prop_AstralSpirit extends com.planet_ink.coffee_mud.Abilities.Properties.Property<br>{<br>   public String ID() { return "Prop_AstralSpirit"; }<br>   public String name(){ return "Astral Spirit";}<br></pre>
                 
<p align="left"><font size="4">Above we see the aforementioned methods defined.&nbsp;
    The Property does not differ from other Abilities, or indeed other Environmental
    objects in this respect.&nbsp; A unique ID(), and name() method must
be   defined  for each new class.</font></p>
                 
<pre>   protected int canAffectCode(){return Ability.CAN_MOBS;}<br>   public String accountForYourself()<br>   { return "an astral spirit";   }<br><br></pre>
                 
<p align="left"><font size="4">Here are two important support methods you
    will also find in Skills and the other more standard Abilities.&nbsp;
The    first method tells what type of objects (Areas, MOBs, Items, Rooms,
or Exits)   can be affected by this property.&nbsp; In this case, this property
 only  affects MOBS.&nbsp; A value like </font><font size="3">Ability.CAN_MOBS|Ability.CAN_ITEMS 
    </font><font size="4">would denote one that affects MOBs or Items.</font></p>
                 
<p align="left"><font size="4">The second method is a string which is returned
    whenever this property appears on an Item which is Identified.&nbsp;
This     string would appear in addition to any secretIdentity defined for
the item.</font></p>
                 
<pre>   /** this method defines how this thing responds<br>    * to environmental changes.  It may handle any<br>    * and every msg listed in the CMMsg class<br>    * from the given Environmental source */<br>   public boolean okMessage(Environmental myHost, CMMsg msg)<br>   {<br>      if((affected==null)||(!(affected instanceof MOB)))<br>         return true;<br>      MOB mob=(MOB)affected;<br><br>      if((msg.amISource(mob))&amp;&amp;(!CMath.bset(msg.sourceMajor(),CMMsg.MASK_ALWAYS)))<br>      {<br>         if((msg.tool()!=null)&amp;&amp;(msg.tool().ID().equalsIgnoreCase("Skill_Revoke")))<br>            return super.okMessage(myHost,msg);<br>         else<br>         if(msg.targetMinor()==CMMsg.TYP_WEAPONATTACK)<br>         {<br>            mob.tell("You are unable to attack in this incorporeal form.");<br>            peaceAt(mob);<br>            return false;<br>         }<br>         else<br>         if((CMath.bset(msg.sourceMajor(),CMMsg.MASK_HANDS))<br>         ||(CMath.bset(msg.sourceMajor(),CMMsg.MASK_MOUTH)))<br>         {<br>            if(CMath.bset(msg.sourceMajor(),CMMsg.MASK_SOUND))<br>               mob.tell("You are unable to make sounds in this incorporeal form.");<br>            else<br>               mob.tell("You are unable to do that this incorporeal form.");<br>            peaceAt(mob);<br>            return false;<br>         }<br>      }<br>      else<br>      if((msg.amITarget(mob))&amp;&amp;(!msg.amISource(mob))<br>         &amp;&amp;(!CMath.bset(msg.targetMajor(),CMMsg.MASK_ALWAYS)))<br>      {<br>         mob.tell(mob.name()+" doesn't seem to be here.");<br>         return false;<br>      }<br>      return true;<br>   }<br><br></pre>
                 
<p align="left"><font size="4">As discussed in the Core Topics above, here
    is an example of an okMessage method.&nbsp; In this case, we intercept
 attack   and other vocal or hand movement messages where the source of the
 action  is the mob whose property this is.&nbsp; We then return false, effectively
   cancelling those messages, after telling the poor bloke why we are doing
  it.&nbsp; The rest of the method prevents any messages from targeting the
  mob with this property.&nbsp; This saves him from being attacked by aggressives,
  or arrested by cityguards -- since technically he isn't even there.</font></p>
                 
<pre>   public void affectEnvStats(Environmental affected, EnvStats affectableStats)<br>   {<br>      super.affectEnvStats(affected,affectableStats);<br>      // when this spell is on a MOBs Affected list,<br>      // it should consistantly put the mob into<br>      // a sleeping state, so that nothing they do<br>      // can get them out of it.<br>      affectableStats.setWeight(0);<br>      affectableStats.setHeight(-1);<br>      affectableStats.setDisposition(affectableStats.disposition()|EnvStats.IS_GOLEM);<br>      affectableStats.setDisposition(affectableStats.disposition()|EnvStats.IS_INVISIBLE);<br>      affectableStats.setDisposition(affectableStats.disposition()|EnvStats.IS_NOT_SEEN);<br>      affectableStats.setSensesMask(affectableStats.sensesMask()|EnvStats.CAN_NOT_SPEAK);<br>   }<br>}<br></pre>
                 
<p><font size="4">Last but not least, here is another example from the Core
    Topics, an affectEnvStats method.&nbsp; This method will always have
the    host mob passed in the "affected" parameter, and a copy of his current
EnvStats    objects in the affectableStats parameter.&nbsp; This method then
sets the    mob as being both invisible, and totally unseen.&nbsp; It makes
him unviewable    to infrared, and prevents him from speaking.&nbsp; The
two methods above   then combine to produce our desired results, an Astral
Spirit.</font></p>
                 
<p>&nbsp;</p>
                 
<p align="left"><strong>&nbsp;</strong><font size="3">&nbsp;<img
 src="images/monk.jpg">
         </font></p>
                 
<p align="left"><a name="SKILLS"><font
 style="background-color: rgb(0,0,0);" color="aqua" size="5"><strong>Introduction 
    to Skill Abilities:</strong></font></a></p>
                 
<p align="left"><font size="4">Abilities are easily the most complicated
and varied of all the objects in CoffeeMud.&nbsp; They encompass everything
from invoked skills and spell, like TRIP or MAGIC MISSILE, to natural abilities,
    like NONDETECTION.&nbsp; A Skill Ability then is an object which implements
    the Ability interface fully, unlike the Property above, which implements
   only certain parts.&nbsp; </font></p>
                 
<p align="left"><font size="4">An Ability is known in the mud as any of the
    following: A Spell, Song, Dance, Skill, Common Skill, Thief Skill, Poison,
    Disease, Prayer, Chant, or Trap.&nbsp; They all implement the Ability
interface,    which in turn extends the Environmental interface discussed
throughout the   rest of this document.&nbsp; Abilities make extensive use
of the okMessage    and executeMsg, tick, and stat affecting methods discussed
above in the  Core  Topics.&nbsp; If you have not read the Core Topics, you
should do so  now.</font></p>
                 
<p align="left"><font size="4">Abilities will all tend to extend the basic
    StdAbility class found in the Abilities package, and sometimes they will
   further extend a class more specific to their type, such as Spell, StdSkill,
   Song, BardSkill, Prayer, FighterSkill, ThiefSkill, Chant, or some other
 basic  types found in the standard CoffeeMud distribution packages.&nbsp;
 </font></p>
                 
<p align="left"><font size="4">Abilities are added to mob objects using the
    addAbility method on MOBs.&nbsp; From there, through casting or by autoInvocation
    (discussed below), they may end up in the effects list of a mob, item,
 room,   area, or exit via the addEffect method.&nbsp; </font></p>
                 
<p><font size="4">A Custom ability may or may not belong to any particular 
    package, though it is important that the </font><font size="4">ID()</font><font
 size="4"> of the ability be unique in  the system.&nbsp; A custom ability&nbsp;</font><font
 size="4"><font size="4">imports the same packages mentioned in the first
   section of this  document under Complete Default Import List as well as
 (in  this case) com.planet_ink.coffee_mud.Abilities.StdAbility  because
our  sample  class extends it</font></font><font size="4">.</font></p>
                 
<p><font size="4">A customized ability class usually extends the&nbsp;StdAbility
    class implemented in the aforementioned package.&nbsp; This StdAbility
 class   already implements the Ability interface, and already has numerous
 support   methods which aid in the creation of custom abilities.</font></p>
                 
<p><font size="4">Each ability must also have custom "ID()" and "name()"
methods as shown below.&nbsp; Notice that the ID() is the same as the name
of the class.&nbsp; This is no accident -- this is required!</font></p>
                 
<pre>public class Skill_Trip extends com.planet_ink.coffee_mud.Abilities.StdAbility<br>{<br>   public String ID() { return "Skill_Trip"; }<br>   public String name(){ return "Trip";}<br></pre>
                 
<p align="left"><font size="4">Above we see the aforementioned methods defined.&nbsp;
    This skill&nbsp;does not differ from other Abilities, or indeed other
Environmental    objects in this respect.&nbsp; A unique ID() and name()
method must be defined   for each new class.</font></p>
                 
<pre>   public String displayText(){ return "(Tripped)";}<br></pre>
                 
<p align="left"><font size="4">The display text on an Ability always refers
    to the&nbsp;text shown in the "You are affected by" section shown by
the    SCORE and AFFECTS commands in the&nbsp;MUD.&nbsp; In this case, someone
 affected   by trip will see (Tripped).&nbsp;&nbsp; If this method does not
 leave any   information for those affected by it, it should return "".</font></p>
                 
<pre>   protected int canAffectCode(){return CAN_MOBS;}<br>   protected int canTargetCode(){return CAN_MOBS;}<br></pre>
                 
<p align="left"><font size="4">These two methods assist the MUDGrinder, and
    the HELP files in classifying the several skills and spells.&nbsp; </font></p>
                 
<p align="left"><font size="4">The first method, canAffectCode(), returns
    what type of objects, if any, this ability class may find itself in the
  effects  list of.&nbsp; Since our Trip skill effects the tripped mob, we
 list mobs.&nbsp;  Other possible values include any combination of CAN_ROOMS,
 CAN_EXITS, CAN_ITEMS,  or CAN_AREAS.&nbsp; If a skill may Effect more than
 one, they can be combined  using the | operator.&nbsp; An example skill
that  affects both mobs and items  might return CAN_MOBS|CAN_ITEMS, for instance.</font></p>
                 
<p align="left"><font size="4">The second method, canTargetCode(), above
tells the system what type of objects can be targeted by this skill.&nbsp;
Some skills will target items (like the Enchant Weapon spell), or rooms (like
the Darkness spell), or exits (like the Knock spell).&nbsp; In a similar
fashion to canAffectCode, this method can return any combination of valid
objects to notify the system of proper targets.</font></p>
                 
<pre>   public int abstractQuality(){return Ability.QUALITY_MALICIOUS;}<br></pre>
                      
<p align="left"><font size="4">This MOST important method tells the system
    quite a bit about the nature of the skill, as well as how mobs with behaviors
    like CombatAbilities should use it.&nbsp; In this case, we return Ability.QUALITY_MALICIOUS,
    which tells the system that the skill is always malicious to others,
and    that it will&nbsp;most likely&nbsp;anger the target.&nbsp; It tells
mobs   to&nbsp;target this skill at enemies in combat</font></p>
           
<p align="left"><font size="4">Other possible values include: </font></p>
         <font size="4"> </font>         
<p align="left">         
<table cellspacing="1" cellpadding="1" width="75%" border="1">
           <tbody>
             <tr>
               <td>Ability.QUALITY_BENEFICIAL_SELF</td>
               <td>always helpful to oneself when used</td>
             </tr>
             <tr>
               <td>Ability.QUALITY_BENEFICIAL_OTHERS</td>
               <td>can be targeted to other people, and is always beneficial
        </td>
             </tr>
             <tr>
               <td>Ability.QUALITY_OK_SELF</td>
               <td>targets oneself, but is only useful in certain circumstances, 
   or it has complicated parameters that mobs won't find useful</td>
             </tr>
             <tr>
               <td>Ability.QUALITY_OK_OTHERS</td>
               <td>targets other people, but is only useful under certain 
circumstances,    or it also has complicated parameters</td>
             </tr>
             <tr>
               <td>Ability.QUALITY_INDIFFERENT</td>
               <td>targets items, or rooms, and is only useful in certain 
circumstances</td>
             </tr>
                                   
  </tbody>         
</table>
         </p>
                 
<p align="left"><font size="4">Only skills marked as  Ability.QUALITY_BENEFICIAL_*
  orAbility.QUALITY_MALICIOUS   will be used in combat or by most behaviors</font><font
 size="4">.</font>       </p>
           
<pre>   public int castingQuality(MOB invoker, Environmental target){return super.castingQuality(invoker,target);}<br></pre>
                  
<p align="left"><font size="4">This second most important method is similar 
   to the abstractQuality() method above, but it tells the system what the 
 quality  of the skills or spell is if it is specifically used by the given 
 invoker  against the given target at this given time. &nbsp;If your skill 
 is only useful in water or against elves, it might be good to check to see 
 if the invoker is in water or the target is an elf before returning a value. 
 &nbsp;The same kinds of values may be returned from this method as are returned 
 by abstractQuality, except for QUALITY_OK_OTHERS and Ability.QUALITY_OK_SELF,
  which are meaningless  in this context.</font></p>
                 
<pre>   public boolean isAutoInvoked(){return false;} </pre>
                 
<p align="left"><font size="4">All skills are either autoInvoking, or they
    must be invoked by a player or mob.&nbsp; The value returned by this
method     determines which sort this ability is.&nbsp; If it is autoinvoking,
it  will   not have an invoke( method as described below, nor will it have
trigger   strings,  nor will it return anything other than "" from it's displayText()
  method.&nbsp;  An example of an autoInvoking ability would be Blind Fighting
  or Two Weapon  Fighting.&nbsp; In our case, however, Trip is not autoinvoking,
  but requires  a player to invoke it.</font></p>
                 
<pre>   private static final String[] triggerStrings = {"TRIP"};<br>   public String[] triggerStrings(){return triggerStrings;}<br>   public double castingTime(){return 0.25;} <br>   public double combatCastingTime(){return 1.0;} <br></pre>
                 
<p align="left"><font size="4">For skills which are not autoinvoking, like
    this one, we must define an array of strings which constitute the command
    words to use this skill.&nbsp; Each entry in the array must be only one
  word.&nbsp;  If more than one skill is found with the same trigger words
 (such as the spells, which all share the trigger word "CAST"), then the
name  of the specific ability will be the required next parameter.&nbsp;
Trip, however, has a unique trigger word, which is defined by this method.</font></p>
                 
<p align="left"><font size="4">Skills can also define how many actions they
    take to execute when the caster or user of the skill is in combat, or
not    in combat.&nbsp; The next two methods define this.&nbsp; A value of
0 means    that the skill or spell is always instantaneous.&nbsp; A higher
value means    that the skill requires a full action to perform. &nbsp;Typical
players  have 1 action per tick (4 second period) to use.</font></p>
                 
<pre>   public int classificationCode(){return Ability.ACODE_SKILL;}<br></pre>
                 
<p align="left"><font size="4">This important method defines which category
    an ability falls into.&nbsp; Possible values include: SKILL, PRAYER,
SONG,     TRAP, SPELL, THIEF_SKILL, LANGUAGE, CHANT, COMMON_SKILL, DISEASE,
or POISON.&nbsp;     </font></p>
                 
<pre>   public long flags(){return Ability.FLAG_MOVING;}<br></pre>
                 
<p align="left"><font size="4">This method returns a value consisting of
one or more flags, separated by | symbols in the same way that canAffectCode
does above.&nbsp; Each flag has a specific meaning and imparts information
to the engine about the ability.&nbsp; Possible values, which may be used
alone or together in any combination, include:</font></p>
                 
<p align="left">         
<table cellspacing="1" cellpadding="1" width="75%" border="1">
           <tbody>
             <tr>
               <td>FLAG_BINDING</td>
               <td>Binds and or limits movement and the use of hands.</td>
             </tr>
             <tr>
               <td>FLAG_MOVING</td>
               <td>Changes the position of the target or affected one.</td>
             </tr>
             <tr>
               <td>FLAG_TRANSPORTING</td>
               <td>Changes the room of the target, requires that the performer
   of  the skill be present.</td>
             </tr>
             <tr>
               <td>FLAG_WEATHERAFFECTING</td>
               <td>Changes the weather.</td>
             </tr>
             <tr>
               <td>FLAG_SUMMONING</td>
               <td>Changes the room of the target, where the performer of 
the   skill  is not present.&nbsp; May also bring new creatures into existence.</td>
             </tr>
             <tr>
               <td>FLAG_CHARMING</td>
               <td>Charms the target.</td>
             </tr>
             <tr>
               <td>FLAG_TRACKING</td>
               <td>Results in the target tracking something.</td>
             </tr>
             <tr>
               <td>FLAG_HEATING</td>
               <td>Makes the target hot.</td>
             </tr>
             <tr>
               <td>FLAG_BURNING</td>
               <td>Makes the target on fire.</td>
             </tr>
             <tr>
               <td>FLAG_HOLY</td>
               <td>Means that the skill is GOOD aligned, unless FLAG_UNHOLY 
 is  also  set, in which case it makes the skill NEUTRAL.</td>
             </tr>
             <tr>
               <td>FLAG_UNHOLY</td>
               <td>Means that the skill is EVIL aligned, unless FLAG_UNHOLY 
 is  also  set, in which case it makes the skill NEUTRAL.</td>
             </tr>
             <tr>
               <td>FLAG_PARALYZING</td>
               <td>Makes the target or affected one unable to move their
muscles.</td>
             </tr>
                                   
  </tbody>         
</table>
         </p>
                 
<p align="left">&nbsp;</p>
                 
<pre>   public void affectEnvStats(Environmental affected, EnvStats affectableStats)<br>   {<br>      super.affectEnvStats(affected,affectableStats);<br>      if(!doneTicking)<br>         affectableStats.setDisposition(affectableStats.disposition()|EnvStats.IS_SITTING);<br>   }<br></pre>
                 
<p align="left"><font size="4">This is an example of the affectEnvStats method
    described in the Core Topics.&nbsp; In the case of our Trip skill, it
forces    the affected target into a sitting position.</font></p>
                 
<pre>   public boolean okMessage(Environmental myHost, CMMsg msg)<br>   {<br>      if((affected==null)||(!(affected instanceof MOB)))<br>         return true;<br><br>      MOB mob=(MOB)affected;<br>      if((doneTicking)&amp;&amp;(msg.amISource(mob)))<br>         unInvoke();<br>      else<br>      if(msg.amISource(mob)&amp;&amp;(msg.sourceMinor()==CMMsg.TYP_STAND))<br>         return false;<br>      return true;<br>   }<br></pre>
                 
<p align="left"><font size="4">This is an example of the okMessage method
    described in the Core Topics.&nbsp; In this case, it intercepts messages
   where the affected mob is trying to stand and cancels the message, without
   comment, by returning false.</font></p>
                 
<pre>   public void unInvoke()<br>   {<br>      if((affected==null)||(!(affected instanceof MOB)))<br>         return;<br>      MOB mob=(MOB)affected;<br>      if(canBeUninvoked())<br>         doneTicking=true;<br>      super.unInvoke();<br>      if(!mob.amDead())<br>      {<br>         if(mob.location()!=null)<br>         {<br>            CMMsg msg=CMClass.getMsg(mob,null,CMMsg.MSG_NOISYMOVEMENT,"&lt;S-NAME&gt; regain(s) &lt;S-HIS-HER&gt; feet.");<br>            if(mob.location().okMessage(mob,msg))<br>            {<br>               mob.location().send(mob,msg);<br>               CMLib.commands().postStand(mob,true);<br>            }<br>         }<br>         else<br>            mob.tell("You regain your feet.");<br>      }<br>   }<br></pre>
                 
<p align="left"><font size="4">All standard abilities include an unInvoke()
    method, which is called when the Effect caused by the ability is dispelled,
    or the duration of the ability expires.&nbsp; The super.unInvoke() method,
    which is located in StdAbility.java, actually does the work of removing
  the  Effect from the affected object (stored in the variable affected),
and  then  setting affected to null.&nbsp; In this particular unInvoke()
method,  we also see the code trying to force the mob back to his feet.</font></p>
                 
<pre>   public boolean preInvoke(MOB mob, Vector commands, Environmental givenTarget, <br>				boolean auto, int asLevel, int secondsElapsed, double actionsRemaining)<br>   { return true;}<br></pre>
                 
<p align="left"><font size="4">The preInvoke method is an optional method
    that normally just returns true.&nbsp; Unless you have reason to do so,
  you  do not need to override the standard preInvoke method in StdAbility.java.&nbsp;
    The preInvoke method must return true before the invoke method (below)
 is   executed.&nbsp; The difference between the two is that the preInvoke
 method   is called at the moment the skill command words are entered, even
 if the  skill is coded, via the castingTime() or combatCastingTime() methods,
 to invoke at some later time.&nbsp; If your skill does invoke at a later
time, it is generally useful to use the preInvoke method to scan the commands
Vector,   which contains the command parameter strings minus any trigger
words, for   errors.&nbsp; You may also give the user a message that their
skill will  invoke later on.&nbsp; The preInvoke method will continue to
be called, at  1 second intervals, until the player is able to invoke the
command.<br>
         </font></p>
                 
<pre>   public boolean invoke(MOB mob, Vector commands, Environmental givenTarget, boolean auto, int asLevel)<br>   {<br></pre>
                 
<p align="left"><font size="4">If an ability is not autoinvoked, it will
always have a functional invoke method.&nbsp; This invoke method includes
the following parameters: the mob invoking the ability and&nbsp;a vector
of command parameter strings (which does not include any trigger words).&nbsp;
The givenTarget parameter, which is null on normal ability invokations, will
have the value of a target to the skill if one is available.&nbsp; Calls
to the invoke method where the givenTarget is not null are typically from
potions, wands, traps, or other automatic invocations.&nbsp; Which brings
us to the last parameter, auto.&nbsp; Auto is false on normal invocations
of the skill, and true whenever the skill should always invoke no matter
what.&nbsp; Setting auto to true not only changes the output string for the
skill, but overrides profficiency checks as well.</font></p>
                 
<pre>      MOB target=this.getTarget(mob,commands,givenTarget);<br>      if(target==null) return false;<br></pre>
                 
<p align="left"><font size="4">Our first step in Trip is to get our target.&nbsp;
    There are several getTarget methods built into StdAbility for determining
    a target object based on the command parameters passed in, as well as
the    abstractQuality() value for the ability.&nbsp; The StdAbility method
call    to getTarget is smart enough to know that if a target name is not
specified    by givenTarget, and also one is not specified in the commands
Vector passed    in, that it should choose whoever the mob is fighting, since
the ability   isAbility.QUALITY_MALICIOUS.&nbsp; Non-malicious skills would
not follow  this reasoning,   but would choose the caster himself as default.</font></p>
                 
<p align="left"><font size="4">All of the several getTarget methods will
generate their own error messages to the user if a target is not specified,
or found, or cannot be determined.&nbsp; For this reason, we need only to
check to see if a target has been returned.&nbsp; If not, we can return false
from invoke(), telling the system that the ability failed to invoke.</font></p>
                 
<pre>      if((CMLib.flags().isSitting(target)||CMLib.flags().isSleeping(target)))<br>      {<br>         mob.tell(target,null,null,"&lt;S-NAME&gt; is already on the floor!");<br>         return false;<br>      }<br><br>      if((!CMLib.flags().aliveAwakeMobile(mob,true)||(CMLib.flags().isSitting(mob))))<br>      {<br>         mob.tell("You need to stand up!");<br>         return false;<br>      }<br>      if(mob.isInCombat()&amp;&amp;(mob.rangeToTarget()&gt;0))<br>      {<br>         mob.tell("You are too far away to trip!");<br>         return false;<br>      }<br>      if(target.riding()!=null)<br>      {<br>         mob.tell("You can't trip someone "+target.riding().stateString(target)+" "+target.riding().name()+"!");<br>         return false;<br>      }<br>      if(CMLib.flags().isFlying(target))<br>      {<br>         mob.tell(target.name()+" is flying and can't be tripped!");<br>         return false;<br>      }<br></pre>
                 
<p align="left"><font size="4">Here are numerous checks to see if the invoking
    mob is able to trip, and the target is able to be tripped.</font></p>
                 
<pre>      if(!super.invoke(mob,commands,givenTarget,auto))<br>         return false;<br></pre>
                 
<p align="left"><font size="4">The invoke() method back up in StdAbility
is called now.&nbsp; This method will check mana requirements, and subtract
mana if necessary.&nbsp; It should be called AFTER all other preliminary
checks have been made.</font></p>
                 
<pre>      int levelDiff=target.envStats().level()-mob.envStats().level();<br>      if(levelDiff&gt;0)<br>         levelDiff=levelDiff*5;<br>      else<br>         levelDiff=0;<br>      int adjustment=(-levelDiff)+(-(35+((int)Math.round((new Integer(target.charStats().getStat(CharStats.STAT_DEXTERITY)).doubleValue()-9.0)*3.0))));<br>      boolean success=profficiencyCheck(mob,adjustment,auto);<br></pre>
                 
<p align="left"><font size="4">The profficiency check method called at the
    end here will determine of the user of the skill has passed their profficiency
    check.&nbsp; The first parameter of this method is the invoking mob,
followed     by either a positive (or helpful) adjustment, or a negative
(not helpful)     adjustment.&nbsp; The second parameter is the auto flag
mentioned above,    to allow overrides of the normal profficiency.&nbsp;
In the case of Trip,    we calculate an adjustment based both on level and
the dexterity of the  target.&nbsp;   We store whether or not the profficiency
check failed or passed into the  variable success.</font></p>
                 
<pre>      success=success&amp;&amp;(target.charStats().getBodyPart(Race.BODY_LEG)&gt;0);<br>      if(success)<br>      {<br>         CMMsg msg=CMClass.getMsg(mob,target,this,CMMsg.MSK_MALICIOUS_MOVE|CMMsg.TYP_JUSTICE|(auto?CMMsg.MASK_ALWAYS:0),auto?"&lt;T-NAME&gt; trip(s)!":"^F&lt;S-NAME&gt; trip(s) &lt;T-NAMESELF&gt;!^?");<br>         if(mob.location().okMessage(mob,msg))<br>         {<br>            mob.location().send(mob,msg);<br>            int durationTicks=(msg.value()&gt;0)?1:2;<br>            maliciousAffect(mob,target,asLevel,durationTicks,-1);<br>            target.tell("You hit the floor!");<br>         }<br>      }<br>      else<br>         return maliciousFizzle(mob,target,"&lt;S-NAME&gt; attempt(s) to trip &lt;T-NAMESELF&gt;, but fail(s).");<br>      return success;<br>   }<br>}<br></pre>
                 
<p align="left"><font size="4">The rest of the invoke() method actually does
    the work of sending the trip message and&nbsp;affecting the target if
necessary,&nbsp;or    sending the "fizzle" message if the profficiency check
failed (success was   false). </font></p>
                 
<p align="left"><font size="4">Of special note are some of the other StdAbility
    method calls in this section of code.&nbsp; You'll notice that the message
    constructed (as per the Core Topics&nbsp;discussion in a previous section)
    in this case uses a TYP_JUSTICE message (meaning an attack on dignity),
  with  the malicious and movement flags set.&nbsp; If this message gets
sent,&nbsp;a     call to maliciousAffect is made. The first parameter is
the invoker, and    the second parameter is the one its being invoked upon.&nbsp;
The third  parameter   is the level of the affect, or 0 for default values.
The forth  parameter  is the duration of the Effect in ticks, which you can
see is dependent  in  this case upon whether the message came back with a
value()&gt;0 (meaning    the saving throw was made).&nbsp; If the forth parameter
is 0, then the  default   duration formula will be used.&nbsp; All other
positive values,  such as in  this case, denote a number of ticks of duration.&nbsp;
The last  parameter,   normally -1, asks maliciousAffect to give the target
one more  saving throw,   against any of the valid saving throw type messages,
such  as TYP_FIRE, TYP_ACID,   TYP_GAS, etc.&nbsp; The value of -1 means
not to  make any further saving  throw attempts before affecting the target.</font></p>
                 
<p align="left"><font size="4">If this skill had not been malicious, we could
    have made a call to the beneficialAffect method instead.&nbsp; That method
    has the same parameters as maliciousAffect, though it lacks the final
parameter    for a further saving throw, since beneficial affects require
no saving throw.</font></p>
                 
<p align="left"><font size="4">Now, if the success variable had been false,
    then we made a call to the maliciousFizzle method.&nbsp; In addition
to   a  display in the room, this method will make sure the target knows
that  the  invoking mob was trying to do something bad to him or her, so
that the  target  will get angry and start fighting.&nbsp; Had this not been
a malicious  ability,  we would have made calls instead to either the beneficialWordsFizzle
 method,  or the beneficialVisualFizzle method, depending upon whether the
 skill is  verbal or somantic based.&nbsp; Most spells are verbal based,
for  instance,  while most skills are somantic.</font></p>
                 
<p align="left"><font size="4">Finally, we return the results of the success
    variable from the invoke() method, to let the system know whether or
not    the ability succeeded.&nbsp; If it did, the target will now be affected
 by  this ability, and will have to stay on the ground for a few ticks while
 the  source mob pounds on him or her.</font></p>
                 
<p align="left">&nbsp;</p>
                 
<p align="left"><strong><img src="images/fireball.jpg">
         &nbsp;</strong><font size="3">&nbsp;</font></p>
                 
<p align="left"><a name="SPELLS"><font style="background-color: black;"
 color="yellow" size="5"><strong>Spells, Prayers, and Chants:</strong></font></a></p>
                 
<p align="left"><font size="4">Spells, Prayers, and Chants are all special
    forms of Abilities.&nbsp; For this reason, it is required that you go
back    and read the previous section on Skill Abilities before proceeding.&nbsp;
    You will also be required to poke through the Core Topics elsewhere in
 this   document as well.</font></p>
                 
<p align="left"><font size="4"><strong>Spells</strong></font></p>
                 
<p align="left"><font size="4">Spells will follow all the rules mentioned
    above in the Skill Abilities section, with a few differences:</font></p>
                 
<pre>public class Spell_ResistFire extends com.planet_ink.coffee_mud.Abilities.Spells.Spell<br>{<br>   public String ID() { return "Spell_ResistFire"; }<br>   public String name(){return "Resist Fire";}<br>   public String displayText(){return "(Resist Fire)";}<br>   public int abstractQuality(){ return Ability.QUALITY_BENEFICIAL_OTHERS;}<br>   protected int canAffectCode(){return CAN_MOBS;}<br>   public int classificationCode(){return Ability.ACODE_SPELL|Ability.DOMAIN_ABJURATION;}<br><br></pre>
                 
<p align="left"><font size="4">The first difference you will notice above
    is that spells extend the base class Spell.java found in the Abilities/Spells
    directory instead of StdAbility.&nbsp; Spell.java also extends StdAbility
    as well.&nbsp; The second difference is in the classificationCode() method.&nbsp;
    You will notice that the domain of the spell is also specified.&nbsp;
In   addition to the normal classification code of Ability.ACODE_SPELL, the
domain  may  be added using the | symbol.&nbsp; Possible domains include:
</font></p>
                 
<p align="left">         
<table cellspacing="1" cellpadding="1" width="75%" border="1">
           <tbody>
             <tr>
               <td>DOMAIN_DIVINATION</td>
               <td>Spells that grant knowledge.</td>
             </tr>
             <tr>
               <td>DOMAIN_ABJURATION</td>
               <td>Spells that protect.</td>
             </tr>
             <tr>
               <td>DOMAIN_ILLUSION</td>
               <td>Spells that fool the senses.</td>
             </tr>
             <tr>
               <td>DOMAIN_EVOCATION</td>
               <td>Spells that bring forth the elements.</td>
             </tr>
             <tr>
               <td>DOMAIN_ALTERATION</td>
               <td>Spells that change things.</td>
             </tr>
             <tr>
               <td>DOMAIN_TRANSMUTATION</td>
               <td>Spells that change people.</td>
             </tr>
             <tr>
               <td>DOMAIN_ENCHANTMENT</td>
               <td>Spells that enchant items or the mind.</td>
             </tr>
             <tr>
               <td>DOMAIN_CONJURATION</td>
               <td>Spells that transport people or items.</td>
             </tr>
                                   
  </tbody>         
</table>
         </p>
                 
<p align="left">&nbsp;</p>
                 
<pre>   public boolean invoke(MOB mob, Vector commands, Environmental givenTarget, boolean auto, int asLevel)<br>   {<br>      MOB target=getTarget(mob,commands,givenTarget);<br>      if(target==null) return false;<br><br>      if(!super.invoke(mob,commands,givenTarget,auto))<br>         return false;<br><br>      boolean success=profficiencyCheck(mob,0,auto);<br>      if(success)<br>      {<br>         CMMsg msg=CMClass.getMsg(mob,target,this,affectType(auto),auto?"&lt;T-NAME&gt; feel(s) cooly protected.":"^S&lt;S-NAME&gt; invoke(s) a cool field of protection around &lt;T-NAMESELF&gt;.^?");<br>         if(mob.location().okMessage(mob,msg))<br>         {<br>            mob.location().send(mob,msg);<br>            beneficialAffect(mob,target,asLevel, 0);<br>         }<br>      }<br>      else<br>         beneficialWordsFizzle(mob,target,"&lt;S-NAME&gt; attempt(s) to invoke fire protection, but fail(s).");<br><br>      return success;<br>   }<br>}<br></pre>
                 
<p align="left"><font size="4">The Invoke() method above follows the one
in Skill_Abilities very closely.&nbsp; You will see that no adjustment is
made to the profficiency check, and that, since this is not aAbility.QUALITY_MALICIOUS
  ability,   calls are made to beneficialAffect and beneficialWordsFizzle
instead  of maliciousAffect  and maliciousFizzle.&nbsp; The main difference
to notice  here, however, is  the line constructing the evoking message.&nbsp;
You will  notice that where  the message code should be specified, a method
call to  affectType(, which  is a method located in Spell.java, is made.&nbsp;
 This  call will automatically  construct the proper message type for a spell,
 taking  into accountAbility.QUALITY_MALICIOUSness,  and whether the auto
flag is set.&nbsp; You will also notice that different  message strings are
constructed depending upon whether the auto flag is set.</font></p>
                 
<p align="left"><font size="4"><strong>Prayers</strong></font></p>
                 
<p align="left"><font size="4">Prayers&nbsp;will follow all the rules mentioned
    above in the Skill Abilities section, with a few differences:</font></p>
                 
<pre>public class Prayer_Anger extends com.planet_ink.coffee_mud.Abilities.Prayers.Prayer<br>{<br>   public String ID() { return "Prayer_Anger"; }<br>   public String name(){ return "Anger";}<br>   public int abstractQuality(){ return Ability.QUALITY_MALICIOUS;}<br>   public long flags(){return Ability.FLAG_UNHOLY;}<br><br>   public boolean invoke(MOB mob, Vector commands, Environmental givenTarget, boolean auto, int asLevel)<br>   {<br>      if(!super.invoke(mob,commands,givenTarget,auto))<br>         return false;<br><br>      boolean success=profficiencyCheck(mob,0,auto);<br><br>      boolean someoneIsFighting=false;<br>      for(int i=0;i&lt;mob.location().numInhabitants();i++)<br>      {<br>         MOB inhab=mob.location().fetchInhabitant(i);<br>         if((inhab!=null)&amp;&amp;(inhab.isInCombat()))<br>            someoneIsFighting=true;<br>      }<br><br>      if((success)&amp;&amp;(!someoneIsFighting)&amp;&amp;(mob.location().numInhabitants()&gt;3))<br>      {<br>         // it worked, so build a copy of this ability,<br>         // and add it to the effects list of the<br>         // affected MOB.  Then tell everyone else<br>         // what happened.<br>         CMMsg msg=CMClass.getMsg(mob,null,this,affectType(auto),auto?"A feeling of anger descends":"^S&lt;S-NAME&gt; rage(s) for anger.^?");<br>         if(mob.location().okMessage(mob,msg))<br>         {<br>            mob.location().send(mob,msg);</pre>
                 
<pre>[.......]<br>}<br></pre>
                 
<p align="left"><font size="4">The first difference you may notice between
    this and the Skill Ability discussed in the previous section is that
this     skill extends the Prayer.java class instead of StdAbility.&nbsp;
Prayer.java     will make sure that the classificationCode() method returns
the proper  value.&nbsp;&nbsp;   </font></p>
                 
<p align="left"><font size="4">You should also take note of the flags() method.&nbsp;
    All Prayers must return a value from flags() where either the FLAG_UNHOLY
    is set (meaning the Prayer is EVIL aligned), FLAG_HOLY is set (meaning
 the   Prayer is GOOD aligned), or BOTH are set, in which case the Prayer
is NEUTRAL.</font></p>
                 
<p align="left"><font size="4">The last special note is down in the message
    construction in the invoke() method.&nbsp; <font size="4">The Invoke()
 method   above follows the one in Skill_Abilities very closely.&nbsp; You
 will see   that no adjustment is made to the profficiency check, for instance.&nbsp;
    The main difference to notice here, however, is the line constructing
the    evoking message.&nbsp; You will notice that where the message code
should    be specified, a method call to affectType(, which is a method located
in   Prayer.java, is made.&nbsp; This call will automatically construct the
proper   message type for a prayer, taking into accountAbility.QUALITY_MALICIOUSness,
  and whether  the auto flag is set.&nbsp; You will also notice that different
  message strings  are constructed depending upon whether the auto flag is
 set.</font></font></p>
                 
<p align="left"><font size="4"><strong>Chants</strong></font></p>
                 
<p align="left"><font size="4">Chants will follow all the rules mentioned
    above in the Skill Abilities section, with a few differences:</font></p>
                 
<pre>public class Chant_AlterTime extends com.planet_ink.coffee_mud.Abilities.Druid.Chant<br>{<br>   public String ID() { return "Chant_AlterTime"; }<br>   public String name(){ return "Alter Time";}<br>   public String displayText(){return "";}<br>   public int overrideMana(){return 100;}<br>   public int abstractQuality(){return Ability.QUALITY_INDIFFERENT;}<br>   protected int canAffectCode(){return 0;}<br>   protected int canTargetCode(){return 0;}<br><br>   public boolean invoke(MOB mob, Vector commands, Environmental givenTarget, boolean auto, int asLevel)<br>   {<br>      if(!super.invoke(mob,commands,givenTarget,auto))<br>         return false;<br><br>      boolean success=profficiencyCheck(mob,0,auto);<br>      if(success)<br>      {<br>         // it worked, so build a copy of this ability,<br>         // and add it to the effects list of the<br>         // affected MOB.  Then tell everyone else<br>         // what happened.<br>         CMMsg msg=CMClass.getMsg(mob,null,this,affectType(auto),auto?"":"^S&lt;S-NAME&gt; chant(s), and reality seems to start blurring.^?");<br>         if(mob.location().okMessage(mob,msg))<br>         {<br>            mob.location().send(mob,msg);<br>            int x=CMath.s_int(text());<br>            while(x==0)   x=CMLib.dice().roll(1,3,-2);<br>            if(x&gt;0)<br>               mob.location().showHappens(CMMsg.MSG_OK_VISUAL,"Time moves forwards!");<br>            else<br>               mob.location().showHappens(CMMsg.MSG_OK_VISUAL,"Time moves backwards!");<br>            if(CMLib.map().numAreas()&gt;0) CMLib.map().getFirstArea().tickTock(x);<br>         }<br>      }<br>      else<br>         return beneficialWordsFizzle(mob,null,"&lt;S-NAME&gt; chant(s), but the magic fades");<br><br><br>      // return whether it worked<br>      return success;<br>   }<br>}</pre>
         <font size="4">  </font>       
<p align="left"><font size="4"><font size="4">The first difference you may 
   notice between this and the Skill Ability discussed in the previous section 
   is that this skill extends the Chant.java class instead of StdAbility.&nbsp; 
   Chant.java will make sure that the classificationCode() method returns 
the   proper value.&nbsp;&nbsp; </font></font></p>
        <font size="4">  </font>       
<p align="left"><font size="4"><font size="4">You should also take note that 
   the overrideMana() method is actually returning a value here of 100.&nbsp; 
   This method allows your ability to always cost the same amount of mana, 
 regardless  of the invokers level.&nbsp; This method may be used in any ability,
 not just chants.&nbsp; Also, this is not a method that is normally found
in chants.&nbsp;  This particular chant, being deamed to be especially powerful,
 happens to  return a value for it.&nbsp; Normally this method would not
be  found.</font></font></p>
        <font size="4">  </font>       
<p align="left"><font size="4"><font size="4">The last special note is down 
   in the message construction in the invoke() method.&nbsp; <font
 size="4">The  Invoke() method above follows the one in Skill_Abilities very 
  closely.&nbsp;  You will see that no adjustment is made to the profficiency 
  check, for instance.&nbsp;  The main difference to notice here, however, 
 is the line constructing the  evoking message.&nbsp; You will notice that 
 where the message code should  be specified, a method call to affectType(, 
 which is a method located in Chant.java, is made.&nbsp; This call will automatically 
  construct the proper message type for a chant, taking into accountAbility.QUALITY_MALICIOUSness, 
  and whether the auto flag is set.&nbsp; You will also notice that different 
  message strings are constructed depending upon whether the auto flag is 
set.</font></font></font></p>
        <font size="4"> </font>         
<p align="left">&nbsp;</p>
                 
<p align="left"><img src="images/elvis.jpg">
         </p>
                 
<p align="left"><a name="SONGS"><font color="lime" size="5"><strong>Songs:</strong></font></a></p>
                 
<p align="left"><font size="4">Although Songs also follow the Skill Abilities
   rules above, they are the most unique of skills. &nbsp;More than any other
   skill, they rely very heavily on basic functionality provide by their
appropriate    superclasses. &nbsp;For your sanity, I recommend that ALL
of your coded  songs  extend either com.planet_ink.coffee_mud.Abilities.Songs.Song,
</font><font size="4">com.planet_ink.coffee_mud.Abilities.Songs.Dance</font><font
 size="4">, or com.planet_ink.coffee_mud.Abilities.Songs.Play. &nbsp;This
   is because those classes provide very important basic functionality unique
   to songs, and save you as the coder from having to worry about coding
that    unique functionality yourself. &nbsp;<br>
      </font></p>
           
<p align="left"><font size="4">By unique functionality, I am referring to
   the way songs behave when invoked in particular. &nbsp;They are always
invoked   upon groups, and always require the invoker to remain in the room
for the   song to remain in effect.</font><br>
      </p>
           
<p align="left"><tt>public class Song_Protection extends com.planet_ink.coffee_mud.Abilities.Songs.Song<br>
      {<br>
      &nbsp;&nbsp;&nbsp; public String ID() { return "Song_Protection"; }<br>
      &nbsp;&nbsp;&nbsp; public String name(){ return "Protection";}<br>
      </tt></p>
           
<p align="left"><font size="4">Like the skill abilities above, ID() and name()
   are implemented. &nbsp;The name() will get intermingled into the invocation
   text, so name your songs carefully, so they sound right when invoked!</font><br>
      <tt><br>
      &nbsp;&nbsp;&nbsp; public int abstractQuality(){ return Ability.QUALITY_BENEFICIAL_OTHERS;}</tt></p>
           
<p align="left"><font size="4">This method, discussed above for skill abilities,
   is absolutely vital for Songs, as it tells the Song superclass whether
to   invoke the song upon all your enemies, or upon all your group members.
&nbsp;Make   sure you implement this method!</font><br>
      </p>
           
<p align="left"><tt><br>
      &nbsp;&nbsp;&nbsp; public void affectEnvStats(Environmental affected, 
 EnvStats  affectableStats)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; super.affectEnvStats(affected,affectableStats);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(invoker==null) return;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; affectableStats.setAttackAdjustment(affectableStats.attackAdjustment()-5);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      </tt></p>
           
<p align="left"><font size="4">This particular song uses affectEnvStats to
   lower the attack rating of everyone that hears the song. &nbsp;Although
 this  is not a malicious song, it is the price of using it.</font><br>
      </p>
           
<p align="left"><tt><br>
      &nbsp;&nbsp;&nbsp; public void affectCharStats(MOB affected, CharStats
  affectableStats)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; super.affectCharStats(affected,affectableStats);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(invoker==null) return;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; affectableStats.setStat(CharStats.STAT_DEXTERITY,affectableStats.getStat(CharStats.STAT_DEXTERITY)-1);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; affectableStats.setStat(CharStats.STAT_SAVE_ACID,affectableStats.getStat(CharStats.STAT_SAVE_ACID)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; +(invoker.charStats().getStat(CharStats.STAT_CHARISMA)*4));<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; affectableStats.setStat(CharStats.STAT_SAVE_COLD,affectableStats.getStat(CharStats.STAT_SAVE_COLD)</tt><tt><br>
       &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </tt><tt>+(invoker.charStats().getStat(CharStats.STAT_CHARISMA)*4));<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; affectableStats.setStat(CharStats.STAT_SAVE_ELECTRIC,affectableStats.getStat(CharStats.STAT_SAVE_ELECTRIC)</tt><tt><br>
       &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </tt><tt>+(invoker.charStats().getStat(CharStats.STAT_CHARISMA)*4));<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; affectableStats.setStat(CharStats.STAT_SAVE_FIRE,affectableStats.getStat(CharStats.STAT_SAVE_FIRE)</tt><tt><br>
       &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </tt><tt>+(invoker.charStats().getStat(CharStats.STAT_CHARISMA)*4));<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; affectableStats.setStat(CharStats.STAT_SAVE_GAS,affectableStats.getStat(CharStats.STAT_SAVE_GAS)</tt><tt><br>
       &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </tt><tt>+(invoker.charStats().getStat(CharStats.STAT_CHARISMA)*4));<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      </tt><font size="4">The most important thing our sample song does is
 improve   the saving throws of everyone who hears it. &nbsp;The affectCharStats
 method   makes that happen by modifying the appropriate saving throws in
affectableStats.<br>
      <br>
      </font></p>
                 
<p align="left"><font size="5"><strong><img src="images/fun.jpg">
         </strong></font><font size="3">&nbsp;</font> </p>
                 
<p align="left"><a name="COMMON"><font color="maroon" size="5"><strong>Common 
    Skills:</strong></font></a></p>
                 
<p align="left"><font size="4">There are actually 3 unique kinds of common
   skills. &nbsp;One type is simply a normal skill, just like the ones shown
   above. &nbsp;Another type is the gathering skill, which is used to collect
   resources, and extends com.planet_ink.coffee_mud.Abilities.Common.GatheringSkill.
   &nbsp;The last type is the crafting skill, which extends com.planet_ink.coffee_mud.Abilities.Common.CraftingSkill.
   &nbsp;In general, common skills have this in common: they invoke immediately,
   but take a long time to complete. &nbsp;They give messages of progress
to   the user, and they immediately unInvoke themselves if the user leaves
the   room, enters combat, or some other cancelling condition arises.<br>
      </font></p>
           
<p align="left"><font size="4">Let's look at a Gathering skill. &nbsp;Although
   Crafting skills are much more involved, especially in the way they select
   the items they create, and in the way they fill-in the variables for what
   they are creating, you will find them remarkably similar to gathering
skills.</font></p>
           
<p align="left"><tt>public class Fishing extends com.planet_ink.coffee_mud.Abilities.Common.GatheringSkill<br>
      {<br>
      &nbsp;&nbsp;&nbsp; public String ID() { return "Fishing"; }<br>
      &nbsp;&nbsp;&nbsp; public String name(){ return "Fishing";}</tt></p>
           
<p align="left"><font size="4">If you've read the Skill Abilities section
   above, you will recognize these methods and their importance. &nbsp;As
always,   the ID() must match the class name, while the name() can be whatever
you  want to call the skill.</font></p>
           
<p align="left"><tt>&nbsp;&nbsp;&nbsp; private static final String[] triggerStrings
   = {"FISH"};<br>
      &nbsp;&nbsp;&nbsp; public String[] triggerStrings(){return triggerStrings;}</tt></p>
           
<p align="left"><font size="4">And again, like a normal skill, the common
   skills create and return their invocation words (or "trigger strings"
as   they are called in skills).</font></p>
           
<p align="left"><tt>&nbsp;&nbsp;&nbsp; public long flags(){return FLAG_GATHERING;}<br>
      &nbsp;&nbsp;&nbsp; public String supportedResourceString(){return "FLESH";}<br>
      <br>
      </tt></p>
           
<p align="left"><font size="4">The flags() method you will also recognize
   from the Skill Abilities section. &nbsp;However, we've provided the system
   at large with a flag to let it know that this skill is for gathering resources,
   and not for crafting. &nbsp;<br>
      </font></p>
           
<p align="left"><font size="4">The supportedResourceString() is a great supplementary
   method that is unique to Common Skills. &nbsp;It's purpose is to inform
 the  system what kinds of MATERIALS and RESOURCES are utilized by this skill.
  &nbsp;Fishing is for catching fish, so we'll notify the system that we
deal   in meat (flesh). &nbsp;Appropriate strings to return from this method
are   listed in com.planet_ink.coffee_mud.Items.interfaces.RawMaterial.java.
&nbsp;If   there is more than one resource or material type, they are separated
with   the pipe | character.<br>
      </font></p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; protected Item found=null;<br>
      &nbsp;&nbsp;&nbsp; protected String foundShortName="";</tt></p>
           
<p align="left"><font size="4">Almost all the common skills create the item
   that they will generate in the invoke method, store it in the skill, and
  then provide it when the skill is unInvoked. &nbsp;For this reason, we'll
  need some variables to store the object we will create, and a string for
 its name.</font></p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; public Fishing()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; super();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; displayText="You are fishing...";<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; verb="fishing";<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      </tt></p>
           
<p align="left"><font size="4">Our constructor sets the variable "verb",
which is part of the CommonSkill superclass. &nbsp;It is used when constructing
   sentences which let the user and others around them know what they are
doing.   &nbsp;displayText serves the same purpose described by the Skill
Abilities   section above.</font></p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; public boolean tick(Tickable ticking,
   int tickID)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if((affected!=null)&amp;&amp;(affected
   instanceof MOB)&amp;&amp;(tickID==Tickable.TICKID_MOB))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; MOB mob=(MOB)affected;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(tickUp==6)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   if(found!=null)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; commonTell(mob,"You got a tug on the line!");<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   else<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; StringBuffer str=new StringBuffer("Nothing is biting
 around  here.\n\r");<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; commonTell(mob,str.toString());<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; unInvoke();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   }<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return super.tick(ticking,tickID);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      </tt></p>
           
<p align="left"><font size="4">Although our common skill super classes do
   most of the hard work of maintaining the task being performed, you will
 still  find that they are often extended by individual common skills in
other  to  give more appropriate messages to the user. &nbsp;If you don't
know what   a tick method is fore, read the Core Topic on the subject first.
&nbsp;In   this case, before calling the superclasses tick method and letting
it do  most of our work, we take a moment to check the tickUp integer maintained
 by CommonSkill.java. &nbsp;That variable is incremented every 4 seconds
after  the skill is invoked. &nbsp;in this case, after 24 seconds (6*4),
we let the user know whether or not an item was generated by the invoke method.
&nbsp;If an an item was invoked, we tell them they have hooked a fish. &nbsp;If
an item was not generated, we tell them that nothing is biting and immediately
 unInvoke() the skill. &nbsp;<br>
      </font></p>
           
<p align="left"><font size="4">The commonTell method is another feature unique
   to common skills. &nbsp;Since common skills are often found on hireling
 mobs,  we wanted a special method which would tell players who invoke the
 skill about the progress of our task, even if it is a follower that is actually
  DOING the task. &nbsp;For instance, commonTell would tell a player who
is   fishing "You got a tug on the line!". &nbsp;However, commonTell would
force   an NPC follower of a player to SAY "I got a tug on the line!". &nbsp;<br>
      </font></p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; public void unInvoke()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(canBeUninvoked())<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if((affected!=null)&amp;&amp;(affected
   instanceof MOB))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   MOB mob=(MOB)affected;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   if((found!=null)&amp;&amp;(!aborted)&amp;&amp;(!helping))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; int amount=CMLib.dice().roll(1,5,0)*(abilityCode());<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; String s="s";<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; if(amount==1) s="";<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; mob.location().show(mob,null,CMMsg.MSG_NOISYMOVEMENT,"&lt;S-NAME&gt;
   manage(s) to catch "+amount+" pound"+s+" of "+foundShortName+".");<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; for(int i=0;i&lt;amount;i++)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Item newFound=(Item)found.copyOf();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; mob.location().addItemRefuse(newFound,Item.REFUSE_PLAYER_DROP);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if((mob.riding()!=null)&amp;&amp;(mob.riding()
   instanceof Container))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; newFound.setContainer((Container)mob.riding());<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; CMLib.commands().postGet(mob,null,newFound,true);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; super.unInvoke();<br>
      &nbsp;&nbsp;&nbsp; }</tt></p>
           
<p align="left"><font size="4">As mentioned above, the unInvoke() method
is where the final work is done. &nbsp;So long as the skill has not been
aborted (the aborted variable), or the skill was invoked only to help ANOTHER
player (the helping variable), we go ahead and create several copies of our
target item, put them in the room using addItemRefuse, and force the player
to get them into their inventory (if they can).</font></p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; public boolean invoke(MOB mob, Vector
   commands, Environmental givenTarget, boolean auto, int asLevel)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bundling=false;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if((!auto)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &amp;&amp;(commands.size()&gt;0)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &amp;&amp;(((String)commands.firstElement()).equalsIgnoreCase("bundle")))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
bundling=true;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(super.invoke(mob,commands,givenTarget,auto,asLevel))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   return super.bundle(mob,commands);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      </tt></p>
           
<p align="left"><font size="4">The invoke method is where common skills do
   99% of their work, namely determining what the user wants to do and whether
   they have the resources and are in the right place to do it, and then
actually    generating the target item and filling it out. &nbsp;Then the
invoke method    actually places the filled-out common skill on the player
as an "effect",    allowing it to receive "tick" calls until it completes.<br>
      </font></p>
           
<p align="left"><font size="4">In this case, right off the bat we check to
   see if the user is trying to use the Fishing skill to bundle up a pile
of   fish. &nbsp;If so, we call a superclass helper method to do the bundling
  for us. &nbsp;The bundle method which will happily use the supportedResourceString
   method above to determine what the player is allowed to bundle.<br>
      </font></p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int foundFish=-1;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; boolean maybeFish=false;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(mob.location()!=null)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for(int i=0;i&lt;RawMaterial.FISHES.length;i++)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   if(mob.location().myResource()==RawMaterial.FISHES[i])<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; foundFish=RawMaterial.FISHES[i];<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; maybeFish=true;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   else<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   if((mob.location().resourceChoices()!=null)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &amp;&amp;(mob.location().resourceChoices().contains(new Integer(RawMaterial.FISHES[i]))))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; maybeFish=true;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      </tt></p>
           
<p align="left"><font size="4">Our next step is to initialize a variable
for the com.planet_ink.coffee_mud.Items.interfaces.RawMaterial.java (resource)
   code which will represent the type of fish we have caught here. &nbsp;We
  also set a variable saying whether or not ANY fish are even POSSIBLY available
   here.</font></p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(!maybeFish)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; commonTell(mob,"The
   fishing doesn't look too good around here.");<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      </tt></p>
           
<p align="left"><font size="4">If maybeFish is false, we are in a location
   where no fish are even possibly available (such as a Desert room). &nbsp;</font></p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; verb="fishing";<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; found=null;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; playSound="fishreel.wav";<br>
      </tt></p>
           
<p align="left"><font size="4">Otherwise, we re-initialize the "verb" and
   "found" variables we mentioned above, and set a CommonSkill string called
   "playSound" which will be used to give our skill a little sound effect
while   it is working.</font></p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(!super.invoke(mob,commands,givenTarget,auto,asLevel))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false;<br>
      </tt></p>
           
<p align="left"><font size="4">Next we call the GatherSkill superclass invoke
   method. &nbsp;It is important to note that several qualifying checks are
  made in that method, such as whether the player is able to perform the
skill.   &nbsp;It also subtracts the necessary mana or movement points for
using the  skill.</font></p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if((profficiencyCheck(mob,0,auto))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &amp;&amp;(foundFish&gt;0))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; found=(Item)CMLib.utensils().makeResource(foundFish,mob.location().domainType(),false);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; foundShortName="nothing";<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(found!=null)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   foundShortName=RawMaterial.RESOURCE_DESCS[found.material()&amp;RawMaterial.RESOURCE_MASK].toLowerCase();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      </tt></p>
           
<p align="left"><font size="4">Now we check to see if two important conditions
   have occurred; the first being whether the player has passed his or her
 profficiency  check, and the second being whether the foundFish variable
was assigned. &nbsp;Remember that the foundFish variable represents the material
 &amp; resource code for the type of fish we will catch. &nbsp;If both of
those are true, we make use of a very useful method in the utensils() library
called makeResource to generate our item for us. &nbsp;We also properly set
the name of what we have caught based on the material type of the foundFish.</font></p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int duration=35-mob.envStats().level();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(duration&lt;10) duration=10;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; CMMsg msg=CMClass.getMsg(mob,found,this,CMMsg.MSG_NOISYMOVEMENT,"&lt;S-NAME&gt;
   start(s) fishing.");<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(mob.location().okMessage(mob,msg))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; mob.location().send(mob,msg);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; found=(Item)msg.target();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; beneficialAffect(mob,mob,asLevel,duration);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      </tt></p>
           
<p align="left"><font size="4">Our last step is to calculate the amount of
   time (duration) that it will take to catch the fish, create a coffeemud
 message  to declare the start of our finishing adventure, and send the message
 out.  &nbsp;After doing so, notice that we re-set the found variable to
msg.target().    &nbsp;This may seem strange, since, in the getMsg method,
we already declared    found to be our message target. &nbsp;So isn't that
like saying that A=A?    &nbsp;Actually no! &nbsp;Remember that the okMessage
method may preview  or  *modify* a message. &nbsp;Re-setting the found variable
to msg.target()  is  done to support code which may have modified our target
to something else.<br>
      </font></p>
           
<p align="left"><font size="4">Now we'll take a look at a proper crafting
   skill. &nbsp;They are more complicated than gathering skills, but you'll
  be able to apply almost all you learned by reviewing the gathering skill
 to build a good picture of the way crafting skills work. &nbsp;The first
difference is that the crafting skills extend com.planet_ink.coffee_mud.Abilities.Common.CraftingSkill.
   &nbsp;Many of them also implement the com.planet_ink.coffee_mud.Abilities.interfaces.ItemCrafter
   interface, which allows them to provide items to other parts of coffeemud
   instantly!<br>
      </font></p>
           
<p align="left"><font size="4"><br>
      </font><tt>public class GlassBlowing extends CraftingSkill implements 
 ItemCraftor<br>
      {<br>
      &nbsp;&nbsp;&nbsp; public String ID() { return "GlassBlowing"; }<br>
      &nbsp;&nbsp;&nbsp; public String name(){ return "Glass Blowing";}<br>
      </tt></p>
           
<p align="left"><font size="4">If you've read the Skill Abilities section 
   above, you will recognize these methods and their importance. &nbsp;As 
always,   the ID() must match the class name, while the name() can be whatever 
you  want to call the skill.</font></p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; private static final String[] triggerStrings
   = {"GLASSBLOW","GLASSBLOWING"};<br>
      &nbsp;&nbsp;&nbsp; public String[] triggerStrings(){return triggerStrings;}<br>
      </tt></p>
           
<p align="left"><font size="4">And again, like a normal skill, the common 
   skills create and return their invocation words (or "trigger strings" as
  they are called in skills).</font></p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; public String supportedResourceString(){return
   "GLASS|SAND";}<br>
      <br>
      </tt></p>
           
<p align="left"><font size="4">The supportedResourceString() is a great supplementary 
   method that is unique to Common Skills. &nbsp;It's purpose is to inform 
 the system what kinds of MATERIALS and RESOURCES are utilized by this skill.
   &nbsp;GlassBlowing is for turning sand into glass, so we'll notify the
system   that we deal in sand and glass resources. &nbsp;Appropriate strings
to return   from this method are listed in com.planet_ink.coffee_mud.Items.interfaces.RawMaterial.java. 
   &nbsp;If there is more than one resource or material type, they are separated 
   with the pipe | character.<br>
       </font></p>
              
<p align="left"><tt>&nbsp;&nbsp;&nbsp; protected static final int RCP_FINALNAME=0;<br>
      &nbsp;&nbsp;&nbsp; protected static final int RCP_LEVEL=1;<br>
      &nbsp;&nbsp;&nbsp; protected static final int RCP_TICKS=2;<br>
      &nbsp;&nbsp;&nbsp; protected static final int RCP_WOOD=3;<br>
      &nbsp;&nbsp;&nbsp; protected static final int RCP_VALUE=4;<br>
      &nbsp;&nbsp;&nbsp; protected static final int RCP_CLASSTYPE=5;<br>
      &nbsp;&nbsp;&nbsp; protected static final int RCP_MISCTYPE=6;<br>
      &nbsp;&nbsp;&nbsp; protected static final int RCP_CAPACITY=7;<br>
      &nbsp;&nbsp;&nbsp; protected static final int RCP_SPELL=8;</tt></p>
           
<p align="left"><font size="4">This list is at the core of the crafting skills
   &nbsp;It represents the name and function of each column of the crafting
  skill's text file. Later on, we will use these constants to index into
a  Vector that represents the particular row from the crafting skill's text
file that the player is building.</font> <br>
      </p>
           
<p align="left"><tt>&nbsp;&nbsp;&nbsp; protected Item building=null;<br>
      &nbsp;&nbsp;&nbsp; protected Item fire=null;<br>
      &nbsp;&nbsp;&nbsp; protected boolean messedUp=false;<br>
      <br>
      </tt></p>
           
<p align="left"><font size="4">As in the gathering skill, we need to set
up our global variables to remember the object we are crafting, since it
will be constructed below in our invoke method, but not sent out into the
world until the unInvoke method. &nbsp;We also need a reference to the fire
object we are using, so we can watch and see if it goes out.</font><br>
       </p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; public boolean tick(Tickable ticking,
   int tickID)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if((affected!=null)&amp;&amp;(affected
   instanceof MOB)&amp;&amp;(tickID==Tickable.TICKID_MOB))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; MOB mob=(MOB)affected;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if((building==null)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ||(fire==null)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ||(!CMLib.flags().isOnFire(fire))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ||(!mob.location().isContent(fire))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ||(mob.isMine(fire)))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   messedUp=true;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   unInvoke();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return super.tick(ticking,tickID);<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      </tt></p>
           
<p align="left"><font size="4">Unlike the gathering skill, we will let the
  superclass tick method do all the talking to the player. &nbsp;The only
job  being done here is to make sure the fire didn't go out. &nbsp;If it
did, we declare the project messed up, and immediately unInvoke it.</font><br>
       </p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; protected Vector loadRecipes(){return
   super.loadRecipes("glassblowing.txt");}<br>
      <br>
      </tt></p>
           
<p align="left"><font size="4">Overriding the loadRecipes() method is absolutely
  necessary for any crafting skill, as it specifies the recipes list. &nbsp;A
  recipes list is a comma-delimited file where each row is linefeed delimited.
  &nbsp;Each columns meaning is defined by the constants above. &nbsp;The
loadRecipes(String)  method will automatically look in $coffeemud-install-path/resources/skills
  for the file specified.</font><br>
       </p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; public void unInvoke()<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(canBeUninvoked())<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if((affected!=null)&amp;&amp;(affected
   instanceof MOB))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   MOB mob=(MOB)affected;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   if((building!=null)&amp;&amp;(!aborted))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; if(messedUp)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; commonTell(mob,CMStrings.capitalizeAndLower(building.name())+"
   explodes!");<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; mob.location().addItemRefuse(building,Item.REFUSE_PLAYER_DROP);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   building=null;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; super.unInvoke();<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      </tt></p>
           
<p align="left"><font size="4">Just like in the gathering skill, the unInvoke
  method is where we actually give our product to the world. &nbsp;Its been
  saved in the 'building' variable reference, so its just a matter of checking
  whether everything went ok and adding it to the room if things did. &nbsp;Since
  common skills work by adding themselves as affects on the player/mobs performing
  the skill, we need only check the StdAbility.affected reference variable
 to find our craftor.</font><br>
       </p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; public boolean invoke(MOB mob, Vector
   commands, Environmental givenTarget, boolean auto, int asLevel)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int autoGenerate=0;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if((auto)&amp;&amp;(givenTarget==this)&amp;&amp;(commands.size()&gt;0)&amp;&amp;(commands.firstElement()
   instanceof Integer))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; autoGenerate=((Integer)commands.firstElement()).intValue();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; commands.removeElementAt(0);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; givenTarget=null;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      </tt></p>
           
<p align="left"><font size="4">Crafting skills are all outfitted with the
  ability to allow the rest of the system to use the skill class as an automatic
  item generator. &nbsp;By convention, this is done by sending in a commands
  vector (which is normally the parameter strings entered by a user) with
the  first element as an Integer object instead. &nbsp;This object then represents
  the material out of which the item should be made, and maps back to one
of  the RawMaterial.RESOURCE_* constants.</font><br>
       </p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; randomRecipeFix(mob,addRecipes(mob,loadRecipes()),commands,autoGenerate);<br>
      </tt></p>
           
<p align="left"><font size="4">This complex line does the most important
work related to the autoGenerate flag we set above, and also to handle the
case where mobs are initiating this skill on their own. Embedded are three
method calls: one to get a vector of vectors representing the skill row matrix
(loadRecipes()), another to append to this vector any recipe Items in the
mobs inventory (addRecipes(..)), and lastly, to randomly select a recipe
based on the autoGenerate flag or if the invoker is an NPC (randomRecipeFix()).
RandomRecipeFix can handle things like modifying the parameter list (commands)
so that it has the name of the random recipe selected.</font><br>
       </p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(commands.size()==0)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; commonTell(mob,"Make
   what? Enter \"glassblow list\" for a list.");<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if((!auto)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp;(commands.size()&gt;0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp;(((String)commands.firstElement()).equalsIgnoreCase("bundle")))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
bundling=true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if(super.invoke(mob,commands,givenTarget,auto,asLevel))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
   return super.bundle(mob,commands);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return    false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      </tt></p>
           
<p align="left"><font size="4">Now we can finally start dealing the the parameter
  list typed by the player, or generated by the system. &nbsp;The parameter
  list (minus the command invoking word) is in the "commands" vector as a
set  of strings. &nbsp;The first thing we do is check the parameters to see
if  they want to generate a bundle of raw resources. &nbsp;If they do, we
call  a superclass helper method to do so and exit -- this is identical to
the way it was done in the gathering skill above.</font><br>
       </p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector recipes=addRecipes(mob,loadRecipes());<br>
      </tt></p>
           
<p align="left"><font size="4">We're going to need that final recipes list
  so we can search for the one the player entered into the command line.
&nbsp;Therefore   we call loadRecipes() to get the list from our text file,
and then addRecipes   to tack on any Recipe Items in the mobs inventory.
&nbsp;What comes back  is our vector of vectors, representing the rows and
columns in the text file.   &nbsp;Each vector in the 'recipes' vector can
be index by the RCP_* constants   above. </font><br>
       </p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; String str=(String)commands.elementAt(0);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; String startStr=null;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bundling=false;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int completion=4;<br>
      </tt></p>
           
<p align="left"><font size="4">Next we initialize a few important variables,
  such as setting a variable for the first word in the parameters (str),
setting   a default completion ticks (4), and initializing a bundling flag
to false.   &nbsp;Even if the player did not explicitly use the word bundle
in the parameters,   they may still have selected a bundle item from the
recipes list, so we need  that flag to notify the rest of the code of that
fact.</font><br>
       </p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(str.equalsIgnoreCase("list"))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; StringBuffer 
 buf=new  StringBuffer(CMStrings.padRight("Item",16)+" Lvl Sand required\n\r");<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for(int r=0;r&lt;recipes.size();r++)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   Vector V=(Vector)recipes.elementAt(r);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   if(V.size()&gt;0)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; String item=replacePercent((String)V.elementAt(RCP_FINALNAME),"");<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; int level=CMath.s_int((String)V.elementAt(RCP_LEVEL));<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; int wood=CMath.s_int((String)V.elementAt(RCP_WOOD));<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; if(level&lt;=mob.envStats().level())<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; buf.append(CMStrings.padRight(item,16)+"
   "+CMStrings.padRight(""+level,3)+" "+wood+"\n\r");<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; commonTell(mob,buf.toString());<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      </tt></p>
           
<p align="left"><font size="4">If the player entered "list" as the first
word in the parameters, we display the recipes to them. &nbsp;</font><br>
       </p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fire=getRequiredFire(mob,autoGenerate);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(fire==null) return false;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; building=null;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; messedUp=false;<br>
      </tt></p>
           
<p align="left"><font size="4">Now we know we are definitely building something,
  so we can initialize some more variables, such as the global messedUp flag
  and the global building reference item. &nbsp;The global fire reference
item  is also set here by calling a superclass helper method getRequiredFore(..)
  which also has the benefit of giving the user an error message if it fails
  to find a fire to use. &nbsp;The autoGenerate flag is sent in to tell the
  method to skip the check if we are simply using the invoke method to automatically
  generate an item.</font><br>
       </p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int amount=-1;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if((commands.size()&gt;1)&amp;&amp;(CMath.isNumber((String)commands.lastElement())))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; amount=CMath.s_int((String)commands.lastElement());<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; commands.removeElementAt(commands.size()-1);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      </tt></p>
           
<p align="left"><font size="4">Our next step is to check the parameters list
  to see if the player is specifying how much raw material they want to use
  in the construction of this item. The recipe list mentions the minimum
amount   of material, but the user is allowed to specify more if they like.
We'll  save this override amount and confirm its validity later.</font> 
<br>
       </p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; String recipeName=CMParms.combine(commands,0);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector foundRecipe=null;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector matches=matchingRecipeNames(recipes,recipeName,true);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; for(int r=0;r&lt;matches.size();r++)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Vector V=(Vector)matches.elementAt(r);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(V.size()&gt;0)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   int level=CMath.s_int((String)V.elementAt(RCP_LEVEL));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
   if((autoGenerate&gt;0)||(level&lt;=mob.envStats().level()))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; foundRecipe=V;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; break;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      </tt></p>
           
<p align="left"><font size="4">Now we can actually get to the important part
  of making sure that the recipe name entered by the players into the command
  line is actually a valid recipe. &nbsp;We do that by combining the remaining
  strings on the command line into a single variable "recipeName", and then
  calling a superclass helper method called "matchingRecipeNames" to generate
  a subset of the master recipe list which matches that name. &nbsp;Once
we   have this list of matching recipes, we can select the winner based on
level   (unless we are performing an auto-generation, in which case level
doesn't   matter). Our winning recipe is stored in a single vector of strings
called   foundRecipe, which we can index by the RCP_* constants.</font> &nbsp;<br>
       </p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(foundRecipe==null)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; commonTell(mob,"You
   don't know how to make a '"+recipeName+"'.&nbsp; Try \"glassblow list\"
 for  a list.");<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      </tt></p>
           
<p align="left"><font size="4">Of course, if no recipe matched, or none met
  the level requirements, our matched row vector will be null, in which case
  we error out.</font><br>
       </p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int woodRequired=CMath.s_int((String)foundRecipe.elementAt(RCP_WOOD));<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(amount&gt;woodRequired) woodRequired=amount;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; String misctype=(String)foundRecipe.elementAt(RCP_MISCTYPE);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bundling=misctype.equalsIgnoreCase("BUNDLE");<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int[] pm={RawMaterial.RESOURCE_SAND,RawMaterial.RESOURCE_CRYSTAL,RawMaterial.RESOURCE_GLASS};<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int[][] data=fetchFoundResourceData(mob,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; woodRequired,"sand",pm,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 0,null,null,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
   bundling,<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; autoGenerate);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(data==null) return false;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; woodRequired=data[0][FOUND_AMT];<br>
      </tt></p>
           
<p align="left"><font size="4">However, if we did find a matching row, its
  time to start pulling information out of that row and start using it. &nbsp;The
  first thing we check is the minimum required raw materials (woodRequired)
  which can be modified by a larger "amount" variable by the player if they
  entered one. &nbsp;We also draw out the general modifier string "misctype",
  which can be used to specify parameters on the item being generated. &nbsp;For
  instance, is the misctype column says "bundle", we know that we are bundling
  raw resources and can set our bundling flag to true.<br>
    </font></p>
       
<p align="left"><font size="4">The next step is a bit more complicated. &nbsp;The
  pm array is constructed of RawMaterial.RESOURCE_* constants which represent
  those material or resource types valid for making the items in this common
  skill. &nbsp;Next we call the powerful superclass method fetchFoundResourceData
  which will return to us the amount and specific type of valid resources
found,  and give an error if none are found. &nbsp;Of course it doesn't really
matter  with the autoGenerate flag, so it will take that into account as
well. &nbsp;</font><font size="4">&nbsp;The returned array "data"</font><font
 size="4"> has two dimensions,  0 for the primary resource, and 1 for a secondary
resource if applicable (its not applicable here). &nbsp;Each dimension can
be dereferenced using superclass FOUND_* constants. &nbsp;For instance, we
can get a final "woodRequired" value from the data integer array.<br>
    </font></p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(!super.invoke(mob,commands,givenTarget,auto,asLevel))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false;<br>
      </tt></p>
           
<p align="left"><font size="4">Just like for gathering skills, the superclass
  invoke method is called to take care of mana consumption, and to make sure
  the person trying to do the crafting is not asleep or dead.</font><br>
       </p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int lostValue=destroyResources(mob.location(),woodRequired,data[0][FOUND_CODE],0,null,autoGenerate);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; building=CMClass.getItem((String)foundRecipe.elementAt(RCP_CLASSTYPE));<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(building==null)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; commonTell(mob,"There's
   no such thing as a "+foundRecipe.elementAt(RCP_CLASSTYPE)+"!!!");<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return false;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      </tt></p>
           
<p align="left"><font size="4">Our next step is to call another superclass
  method "destroyResources" which will remove the resources from the room
which  are used to construct the item. After that, we can actually initialize
the  building item reference so we can begin to fill it out. &nbsp;The building
  variable will remain referenced only by the common skill class until the
 unInvoke method is called, when it will be given to the craftor.</font>
&nbsp;<br>
       </p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; completion=CMath.s_int((String)foundRecipe.elementAt(RCP_TICKS))
   - ((mob.envStats().level() <br>
    &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
 &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
 - CMath.s_int((String)foundRecipe.elementAt(RCP_LEVEL)))*2);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; String itemName= replacePercent((String)foundRecipe.elementAt(RCP_FINALNAME),
   <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; RawMaterial.RESOURCE_DESCS[(data[0][FOUND_CODE]&amp;RawMaterial.RESOURCE_MASK)]).toLowerCase();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(bundling)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; itemName="a
 "+woodRequired+"#   "+itemName;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; itemName=CMStrings.startWithAorAn(itemName);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; building.setName(itemName);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; startStr="&lt;S-NAME&gt; start(s) 
  blowing "+building.name()+".";<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; displayText="You are blowing
"+building.name();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; verb="blowing "+building.name();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; playSound="fire.wav";<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; building.setDisplayText(itemName+"
   is here");<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; building.setDescription(itemName+".
   ");<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; building.baseEnvStats().setWeight(woodRequired);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; building.setBaseValue(CMath.s_int((String)foundRecipe.elementAt(RCP_VALUE)));<br>
      <br>
      </tt></p>
           
<p align="left"><font size="4">Now that we have a reference to the item object
  we are building, we can start filling in some fields, such as its name,
display  text, weight, and base value, usually from columns in our recipe
text file.  &nbsp;We can also derive the final completion variable, representing
the number of ticks it will take to complete the item.</font><br>
       </p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(data[0][FOUND_CODE]==RawMaterial.RESOURCE_SAND)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; building.setMaterial(RawMaterial.RESOURCE_GLASS);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; building.setMaterial(data[0][FOUND_CODE]);<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; building.baseEnvStats().setLevel(CMath.s_int((String)foundRecipe.elementAt(RCP_LEVEL)));<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; building.setSecretIdentity("This
  is  the work of "+mob.Name()+".");<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int capacity=CMath.s_int((String)foundRecipe.elementAt(RCP_CAPACITY));<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; String spell=(foundRecipe.size()&gt;RCP_SPELL)?((String)foundRecipe.elementAt(RCP_SPELL)).trim():"";<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; addSpells(building,spell);<br>
      </tt></p>
           
<p align="left"><font size="4">Continueing with our mission of filling out
  the building object, we set the material type, level, and secret identity.
  &nbsp;We also add any properties to it that are listed in the recipe text
  file by calling the superclass helper method addSpells(). There is also
a  column in the recipe file for the capacity of the item if it is a container.</font>
  &nbsp;<br>
       </p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(building instanceof
   Container)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(capacity&gt;0)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   ((Container)building).setCapacity(capacity+woodRequired);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(misctype.equalsIgnoreCase("LID"))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   ((Container)building).setLidsNLocks(true,false,false,false);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(misctype.equalsIgnoreCase("LOCK"))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   ((Container)building).setLidsNLocks(true,false,true,false);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   ((Container)building).setKeyName(new Double(Math.random()).toString());<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
((Container)building).setContainTypes(Container.CONTAIN_ANYTHING);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      </tt></p>
           
<p align="left"><font size="4">If, in fact, the item we are building is a
  container, we'll set the capacity of the container, and use our general
purpose  "misctype" column from the table to determine whether a lit or lock
needs  to be made.</font><br>
       </p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(building instanceof
   Drink)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(CMLib.flags().isGettable(building))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   ((Drink)building).setLiquidRemaining(0);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   ((Drink)building).setLiquidHeld(capacity*50);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   ((Drink)building).setThirstQuenched(250);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   if((capacity*50)&lt;250)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; ((Drink)building).setThirstQuenched(capacity*50);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(bundling) building.setBaseValue(lostValue);<br>
      </tt></p>
           
<p align="left"><font size="4">If the item is a Drinkable, then we have a
  few more fields to fill out, based on the capacity column. &nbsp;The last
  line makes sure that the gold value of the item reflects the sum of the
materials  used, in case we are bundling.</font><br>
       </p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; building.recoverEnvStats();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; building.text();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; building.recoverEnvStats();<br>
      <br>
      <br>
      </tt></p>
           
<p align="left"><font size="4">The filling out of the item is complete, so
  we call recoverEnvStats(), populate the miscText field if the item is Generic,
  and then recover the env stats again in case that changed anything.</font><br>
       </p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; messedUp=!profficiencyCheck(mob,0,auto);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(completion&lt;4) completion=4;<br>
      <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(bundling)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; messedUp=false;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; completion=1;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; verb="bundling 
  "+RawMaterial.RESOURCE_DESCS[building.material()&amp;RawMaterial.RESOURCE_MASK].toLowerCase();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; startStr="&lt;S-NAME&gt;
   start(s) "+verb+".";<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; displayText="You
   are "+verb;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      </tt></p>
           
<p align="left"><font size="4">Now we can set our messedUp flag based on
a profficiency check, and change our common skill player-message strings
based on whether we are bundling.</font><br>
       </p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(autoGenerate&gt;0)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; commands.addElement(building);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      <br>
      </tt></p>
           
<p align="left"><font size="4">If the invoke method was called simply to
generate the item, we are done -- we can add the item to the commands vector
(where it will be expected), and return.</font><br>
       </p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; CMMsg msg=CMClass.getMsg(mob,building,this,CMMsg.MSG_NOISYMOVEMENT,startStr);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(mob.location().okMessage(mob,msg))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; mob.location().send(mob,msg);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; building=(Item)msg.target();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; beneficialAffect(mob,mob,asLevel,completion);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(bundling)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; messedUp=false;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; aborted=false;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; unInvoke();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }</tt>  </p>
                     
<p align="left"><font size="4">Last but not least, we do exactly what we
did in our gathering skill, namely generate a message for this event, and
add the common skill as an effect to the invoker of it. &nbsp;The completion
time is used to determine how long it will take to generate the item.</font><br>
       </p>
                  
<p><img src="images/prayer.jpg">
         </p>
                 
<p align="left"><a name="POISON"><font color="maroon" size="5"><strong>Poisons:</strong></font></a></p>
                 
<pre>public class Poison_BeeSting extends com.planet_ink.coffee_mud.Abilities.Poisons.Poison<br>{<br>	public String ID() { return "Poison_BeeSting"; }<br>	public String name(){ return "Bee Sting";}<br></pre>
                 
<p align="left"><font size="4">The Poison base class in the Poisons package
    provides a tidy template upon which your more common, mundane poisons
can    be based. The first three methods are those required by any Environmental
    class. The fact that none of the other preliminary methods normally found
    in skill abilities are present is a testimony to the homogeneous nature
  of  Poisons.</font></p>
                 
<pre>	private static final String[] triggerStrings = {"POISONSTING"};<br>	public String[] triggerStrings(){return triggerStrings;}<br></pre>
                 
<p align="left"><font size="4">Poisons have the feature of having their own
    trigger commands, meaning they can be added as attack abilities to monsters
    (like a Bee in this case).</font></p>
                 
<pre>	protected String POISON_DONE(){return "The stinging poison runs its course.";}<br>	protected String POISON_START(){return "^G&lt;S-NAME&gt; turn(s) green.^?";}<br>	protected String POISON_CAST(){return "^F&lt;S-NAME&gt; sting(s) &lt;T-NAMESELF&gt;!^?";}<br>	protected String POISON_FAIL(){return "&lt;S-NAME&gt; attempt(s) to sting &lt;T-NAMESELF&gt;, but fail(s).";}<br></pre>
                 
<p align="left"><font size="4">In this set of methods, strings are defined
    for the invocation of the poison, all the way through its recovery string.</font></p>
                 
<pre>	protected int POISON_TICKS(){return 10;} // 0 means no adjustment!<br></pre>
                 
<p align="left"><font size="4">Poisons can have a variable duration dependent
    upon level (by returning 0) or can have a set duration on the poisoned
 creature.</font></p>
                 
<pre>	protected int POISON_DELAY(){return 2;}<br>	protected int POISON_DAMAGE(){return (invoker!=null)?2:0;}<br>	protected String POISON_AFFECT(){return "&lt;S-NAME&gt; cringe(s) from the poisonous itch.";}<br></pre>
                 
<p align="left"><font size="4">Poisons can also be set to cause the poisoned
    creature to emote on a reguar basis, and to take damage as well. Here
you    can see three methods being used to designate how often the emote/damage
   cycle occurs (in ticks) as well as the amount of damage, and the text
of   the emote.</font></p>
                 
<pre>	public void affectCharStats(MOB affected, CharStats affectableStats)<br>	{<br>		affectableStats.setStat(CharStats.STAT_CONSTITUTION,affectableStats.getStat(CharStats.STAT_CONSTITUTION)-1);<br>		affectableStats.setStat(CharStats.STAT_STRENGTH,affectableStats.getStat(CharStats.STAT_STRENGTH)-1);<br>		if(affectableStats.getStat(CharStats.STAT_CONSTITUTION)&lt;=0)<br>			affectableStats.setStat(CharStats.STAT_CONSTITUTION,1);<br>		if(affectableStats.getStat(CharStats.STAT_STRENGTH)&lt;=0)<br>			affectableStats.setStat(CharStats.STAT_STRENGTH,1);<br>	}<br>}<br></pre>
                 
<p align="left"><font size="4">And lastly, as described under the Core Topic
    on state affects, we have the code which lowers the poisoned creatures
 constitution   and strength while the poison is in effect. We even have
a  few lines to make  sure the values don't fall below 0.</font></p>
                 
<p><img src="images/disease.jpg">
         </p>
                 
<p align="left"><a name="DISEASE"><font color="maroon" size="5"><strong>Diseases:</strong></font></a></p>
                 
<p align="left"><font size="4">Like Poison, the Disease base class in the
    Diseasess package provides a tidy template upon which your more common,
  mundane  diseases can be based.</font></p>
                 
<pre>public class Disease_Cold extends com.planet_ink.coffee_mud.Abilities.Diseases.Disease<br>{<br>	public String ID() { return "Disease_Cold"; }<br>	public String name(){ return "Cold";}<br>	public String displayText(){ return "(Cold Virus)";}<br>	protected int canAffectCode(){return CAN_MOBS;}<br>	protected int canTargetCode(){return CAN_MOBS;}<br>	public int abstractQuality(){return Ability.QUALITY_MALICIOUS;}<br>	public boolean putInCommandlist(){return false;}<br></pre>
                 
<p align="left"><font size="4">The Disease base class provides many important
    base services that allows CoffeeMud to interact properly with your disease.
    For this reason, making a disease that extends the Disease base class
is   highly recommended. In the first half dozen methods, we see the important
   values of a standard skill being defined. See the introduction to Skill
 Abilities   if you need more details on these methods.</font></p>
                 
<pre>	protected String DISEASE_DONE(){return "Your cold clears up.";}<br>	protected String DISEASE_START(){return "^G&lt;S-NAME&gt; come(s) down with a cold.^?";}<br></pre>
                 
<p align="left"><font size="4">In this set of methods, strings are defined
    for the invocation of the disease as well as its recovery string.</font></p>
                 
<pre>	protected int DISEASE_TICKS(){return 24;}<br></pre>
                 
<p align="left"><font size="4">Diseases can have a variable duration dependent
    upon level (by returning 0) or can have a set duration on the diseased
 creature.</font></p>
                 
<pre>	protected int DISEASE_DELAY(){return 5;}<br>	protected String DISEASE_AFFECT(){return "&lt;S-NAME&gt; sneeze(s). AAAAAAAAAAAAAACHOOO!!!!";}<br></pre>
                 
<p align="left"><font size="4">Diseases can also be set to cause the poisoned
    creature to emote on a reguar basis. Here you can see a pair of methods
  being  used to designate how often the emote/damage cycle occurs (in ticks)
  as well  as the text of the emote. Any damage or other consequences of
the   disease  are defined later.</font></p>
                 
<pre>	public int abilityCode(){return DiseaseAffect.SPREAD_CONSUMPTION|DiseaseAffect.SPREAD_PROXIMITY|DiseaseAffect.SPREAD_CONTACT|DiseaseAffect.SPREAD_STD;}<br></pre>
                 
<p align="left"><font size="4">This important method is used to define how
    the disease is spread. Some aspects of disease catching must be coded
by   the programmer of the disease. Some aspects are handled by the engine,
while   most are handled by the Disease base class. This method is used to
coordinate   the efforts on behalf of the disease by the CoffeeMud engine
as a whole.  Different bit values are defined by the DiseaseAffect interface.</font></p>
                 
<pre>	public boolean tick(Tickable ticking, int tickID)<br>	{<br>		if(!super.tick(ticking,tickID))	return false;<br>		if(affected==null) return false;<br>		if(!(affected instanceof MOB)) return true;<br><br>		MOB mob=(MOB)affected;<br>		MOB diseaser=invoker;<br>		if(diseaser==null) diseaser=mob;<br></pre>
                 
<p align="left"><font size="4">If a disease does anything during its delay
    cycle (defined above by DISEASE_DELAY()), then the programmer must implement
    a tick method to take care of this functionality. These first few lines
  of  the method are error and state checking, as well as defining some useful
   variables, such as who caused the disease (diseaser), and who has the
disease    (mob)</font></p>
                 
<pre>		<br>		if((getTickDownRemaining()==1)<br>		&amp;&amp;(CMLib.dice().rollPercentage()&gt;mob.charStats().getSave(CharStats.STAT_SAVE_COLD))<br>		&amp;&amp;(CMLib.dice().rollPercentage()&lt;25-mob.charStats().getStat(CharStats.STAT_CONSTITUTION))<br>		&amp;&amp;(!mob.amDead())<br>		&amp;&amp;(!mob.isMonster()))<br>		{<br>			mob.delEffect(this);<br>			Ability A=CMClass.getAbility("Disease_Pneumonia");<br>			A.invoke(diseaser,mob,true);<br>		}<br></pre>
                 
<p align="left"><font size="4">One of the things we have decided to do in
    the disease Cold is to make it so that, if the creature does not cure
the    disease before it expires naturally, they will almost certainly catch
Pneumonia.    By checking getTickDownRemaining, we check out counter which
runs downwards    from DISEASE_TICKS() to 0. At a value of 1, we make a saving
throw check   for the creature with the cold, and potentially give them another
disease   to enjoy when the Cold expires 1 tick later.</font></p>
                 
<pre>		else<br>		if((!mob.amDead())&amp;&amp;((--diseaseTick)&lt;=0))<br>		{<br>			diseaseTick=DISEASE_DELAY();<br>			mob.location().show(mob,null,CMMsg.MSG_NOISE,DISEASE_AFFECT());<br>			if(mob.curState().getHitPoints()&gt;((2*diseaser.envStats().level())+1))<br>			{<br>				int damage=CMLib.dice().roll(2,diseaser.envStats().level(),1);<br>				CMLib.combat().postDamage(diseaser,mob,this,damage,CMMsg.MASK_ALWAYS|CMMsg.TYP_DISEASE,-1,null);<br>			}<br>			catchIt(mob);<br>			return true;<br>		}<br>		return true;<br>	}<br></pre>
                 
<p align="left"><font size="4">The last thing we do in this method is, every
    DISEASE_DELAY ticks, we emote our DISEASE_AFFECT string, and then allow
  the  creature to take a few points of disease damage by calling the MUDFight.postDamage
    method. After this, we also call the catchIt(MOB mob) method up in the
 Disease   base class. This important method spreads the disease among those
 in the  same room as the creature, thereby handling any diseases spread
by  proximity  as defined in abilityCode() above.</font></p>
                 
<pre>	public void affectCharStats(MOB affected, CharStats affectableStats)<br>	{<br>		if(affected==null) return;<br>		affectableStats.setStat(CharStats.STAT_CONSTITUTION,affectableStats.getStat(CharStats.STAT_CONSTITUTION)-2);<br>		affectableStats.setStat(CharStats.STAT_STRENGTH,affectableStats.getStat(CharStats.STAT_STRENGTH)-3);<br>		if(affectableStats.getStat(CharStats.STAT_CONSTITUTION)&lt;=0)<br>			affectableStats.setStat(CharStats.STAT_CONSTITUTION,1);<br>		if(affectableStats.getStat(CharStats.STAT_STRENGTH)&lt;=0)<br>			affectableStats.setStat(CharStats.STAT_STRENGTH,1);<br>	}<br>}<br></pre>
                 
<p align="left"><font size="4">And lastly, as described under the Core Topic
    on state affects, we have the code which lowers the diseased creatures
 constitution   and strength while the disease is in effect. We even have
a few lines to  make sure the values don't fall below 0.</font></p>
                 
<p><img src="images/traps.jpg">
         </p>
                 
<p align="left"><a name="TRAPS"><font color="maroon" size="5"><strong>Traps:</strong></font></a></p>
                 
<p align="left"><font size="4">Traps and Bombs are so similar, that the differences
   are not worth mentioning. &nbsp;However, although they are classified
as   skill abilities, they are different from normal Skill Abilities mentioned
  above in that they rely very heavily on their superclass bases, which are
  com.planet_ink.coffee_mud.Abilities.Traps.StdTrap, and </font><font
 size="4"> com.planet_ink.coffee_mud.Abilities.Traps.StdBomb respectively.
  &nbsp;Making a proper and compliant trap is helped considerably by following
  that advice. &nbsp;Otherwise, so long as your trap implements the com.planet_ink.coffee_mud.Abilities.interfaces.Trap
  interface, it will be ok.</font><br>
      </p>
           
<p align="left"><tt>public class Trap_ElectricShock extends com.planet_ink.coffee_mud.Abilities.Traps.StdTrap<br>
      {<br>
      &nbsp;&nbsp;&nbsp; public String ID() { return "Trap_ElectricShock";
 }<br>
      &nbsp;&nbsp;&nbsp; public String name(){ return "electric shock";}</tt></p>
           
<p align="left"><font size="4">If you've read the Skill Abilities section 
   above, you will recognize these methods and their importance. &nbsp;As 
always,   the ID() must match the class name, while the name() can be whatever 
you  want to call the skill.</font><br>
      </p>
           
<p align="left"><tt>&nbsp;&nbsp;&nbsp; protected int canAffectCode(){return
   Ability.CAN_ITEMS|Ability.CAN_EXITS;}<br>
      &nbsp;&nbsp;&nbsp; protected int canTargetCode(){return 0;}</tt></p>
           
<p align="left"><font size="4">It is very important, even more so than normal
   skills, to make sure that your StdAbility canAffectCode() method returns
  a proper value. &nbsp;Some traps can be placed on rooms (floors), and some
  on items, and others on exits. &nbsp;Make sure your method informs StdAbility
   what your trap will do.</font><br>
      </p>
           
<p align="left"><tt>&nbsp;&nbsp;&nbsp; protected int trapLevel(){return 19;}<br>
      </tt></p>
           
<p align="left"><font size="4">The trapLevel() is the class level of your
   trap. &nbsp;In general, a player needs this many levels in their trap-laying
   class before they can create this trap.</font><br>
       </p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; public String requiresToSet(){return
   "10 pounds of metal";}</tt></p>
           
<p align="left"><font size="4">This is another trap-specific method which
   is used by the Set Traps skill to inform the user of what kinds of extra-materials
   are required by the user before they can lay this particular trap. &nbsp;It
   will be inforced below in the canSetTrap and setTrap methods.</font> 
<br>
       </p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; public Trap setTrap(MOB mob, Environmental
   E, int classLevel, int qualifyingClassLevel)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(E==null) return null;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(mob!=null)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Item I=findMostOfMaterial(mob.location(),RawMaterial.MATERIAL_METAL);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(I!=null)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   super.destroyResources(mob.location(),I.material(),10);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return super.setTrap(mob,E,classLevel,qualifyingClassLevel);<br>
      &nbsp;&nbsp;&nbsp; }</tt></p>
           
<p align="left"><font size="4">This method is used to actually set the trap,
   well before the trap is sprung. &nbsp;Springing is handles by the StdTrap
   superclass system, and is based on what is returned by the canAffectCode()
   method. &nbsp;The setTrap method received the mob/player setting the trap,
   the item onto which the trap is being set (E -- I know, very descriptive;
   sue me), the classLevel of the player in their trap laying class, and
at   what level they first qualified for this trap. &nbsp;In this particular
method,   we use some helper methods from StdTrap to find all of the metal
in the room,  and then use another StdTrap superclass method to remove the
found metal from the room. &nbsp;findMostOfMaterial will look for any raw
material Metals in the room, and return an example Item representing the
specific type (bronze,  iron, gold) of metal that is most numerous in the
room. &nbsp;The &nbsp;destroyResources  method then will remove 10 of those
from the room.</font><br>
       </p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; public boolean canSetTrapOn(MOB mob,
   Environmental E)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(!super.canSetTrapOn(mob,E))
 <br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; return false;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(mob!=null)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Item I=findMostOfMaterial(mob.location(),RawMaterial.MATERIAL_METAL);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if((I==null)<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ||(super.findNumberOfResource(mob.location(),I.material())&lt;10))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   mob.tell("You'll need to set down at least 10 pounds of metal first.");<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   return false;<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      </tt></p>
           
<p align="left"><font size="4">This method is called before the setTrap method
   to determine whether the given player/mob is allowed or able to set the
 trap  on the given object (E). &nbsp;Just as we did in setTrap above, we
use findMostOfMaterial  to determine what the most numerous metal resource
on the room is, &nbsp;then  call another StdTrap superclass method, findNumberOfResaource,
 to make sure  there is enough of this particular metal resource to do the
 job. &nbsp;If  not, we inform the user and return false from the method.
&nbsp;If everything  is fine, we return true. &nbsp;Notice that we were careful
to call the superclass  version of this method -- it does important things
for us also, so it should  definitely be called!</font><br>
       </p>
             
<p align="left"><tt>&nbsp;&nbsp;&nbsp; public void spring(MOB target)<br>
      &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if((target!=invoker())&amp;&amp;(target.location()!=null))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if((!invoker().mayIFight(target))||(CMLib.dice().rollPercentage()&lt;=target.charStats().getSave(CharStats.STAT_SAVE_TRAPS)))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   target.location().show(target,null,null,CMMsg.MASK_ALWAYS|CMMsg.MSG_NOISE,"&lt;S-NAME&gt;
   avoid(s) setting off a shocking trap!");<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(target.location().show(target,target,this,CMMsg.MASK_ALWAYS|CMMsg.MSG_NOISE,"&lt;S-NAME&gt;
   set(s) off an shocking trap!"))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   super.spring(target);<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   CMLib.combat().postDamage(invoker(), target, null, CMLib.dice().roll(trapLevel(),8,1),
   CMMsg.MASK_ALWAYS|CMMsg.TYP_ELECTRIC, Weapon.TYPE_STRIKING, "The shock
 &lt;DAMAGE&gt;  &lt;T-NAME&gt;!"+CMProps.msp("shock.wav",30));<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   if((canBeUninvoked())&amp;&amp;(affected instanceof Item))<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
   &nbsp;&nbsp;&nbsp; disable();<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }</tt><br>
      </p>
           
<p align="left"><font size="4">The spring method is where the action is at.
   &nbsp;If the code in StdTrap determines that the trap has been sprung,
then   this method will be called with only one parameter, namely the mob
who sprung   it. &nbsp;After making sure we aren't springing the trap on
the thief who   set it, we make sure that the thief who set the trap is not
breaking PK rules  by hurting the player. &nbsp;We do this using the invoker()
method from StdAbility,  which will return a reference to the thief MOB who
set the trap. &nbsp;We  also give the poor bloke who sprung the trap a saving
 throw. &nbsp;If both  checks fail, we let the room know that the trap has
 gone off. &nbsp;Notice  that it is inside this condition that we call super.spring().
 &nbsp;This is because, normally, the spring method is only supposed to hurt
 people. &nbsp;Since we have lots of conditions by which the mob can get
out  of being hurt, we need to wrap our call to super.spring(...). &nbsp;Anyway,
 since the trap has gone off, we make a library call to the combat() engine's
 postDamage method. &nbsp;That method has lots of very complicated parameters,
 so you'll have to read up on the Library section for more information on
it, but suffice  to say that it posts the damage message that takes hit points
 away from the  player. &nbsp;Lastly, if the trap is allowed to be uninvoked,
 we call the  special StdTrap disable() method, which makes the trap unviable
 FOREVER. &nbsp;It effectively destroys the trap.<br>
      <br>
      </font></p>
                 
<p><img src="images/language.jpg">
         </p>
                 
<p align="left"><a name="LANGS"><font color="maroon" size="5"><strong>Languages:</strong></font></a></p>
                 
<p align="left"><font size="4">Of all skills, you will find that Languages
    are the easiest to code. Although they fall into the category of Ability,
    and are a far derivative of StdAbility, you will need very little of
that     extended knowledge if you follow the K.I.S.S. principle and use
the simple     template provided by the Language base class in the Languages
package.</font></p>
                 
<pre>public class Elvish extends com.planet_ink.coffee_mud.Abilities.Languages.Language<br>{<br>	public String ID() { return "Elvish"; }<br>	public String name(){ return "Elvish";}<br>	<br></pre>
                 
<p align="left"><font size="4">Like all Abilities, the Language requires
an ID which is the same as its class name, and a readable name. In the case
of Elvish, they are identical. </font></p>
                 
<pre>	private static boolean mapped=false;<br>	public Elvish()<br>	{<br>		super();<br>		if(!mapped){mapped=true;<br>					CMAble.addCharAbilityMapping("All",1,ID(),false);}<br>	}<br></pre>
                 
<p align="left"><font size="4">The constructor of this language is worth
noting. Under the section on Character Classes, we learned how to make classes
qualify for skills. Languages, like Common Skills, are available to ALL classes.
For this reason, we save ourselves the trouble by having the language declare
    its qualifications itself by accessing the same CMAble method we saw
up   in  Character Class creation. </font></p>
                 
<pre>	public static Vector wordLists=null;<br>	public Vector translationVector()<br>	{<br>		if(wordLists==null)<br>		{<br>			String[] one={"a","e","i","o","&aacute;","&eacute;","&iacute;","&oacute;"};<br>			String[] two={"os","vi","ne","vo","li","eh","no","ai","by","et","ce","un","il"};<br>			String[] three={"&aacute;na","cil","sar","tan","hel","loa","sir","hep","yur","nol","hol","qua","&eacute;th"};<br>			String[] four={"s&eacute;ya","qual","quel","lara","uqua","sana","yava","masse","yanna","quettaparma","manna","manan","merme","carma","harno","harne","varno","essar","saira","cilta","veuma","norta","turme","saita"};<br>			String[] five={"cuiva","cuina","nonwa","imire","nauta","cilta","entuc","norta","latin","l&ograve;tea","veuya","veuro","apama","hampa","nurta","firta","saira","holle","herwa","uquen","arcoa","calte","cemma","hanta","tanen"};<br>			String[] six={"mahtale","porisalque","hairie","tararan","ambarwa","latina","ol&ograve;tie","amawil","apacen","yavinqua","apalume","linquilea","menelwa","alassea","nurmea","parmasse","ceniril","heldasse","imirin","earina","calatengew","lapselunga","rianna","eneques"};<br>			wordLists=new Vector();<br>			wordLists.addElement(one);<br>			wordLists.addElement(two);<br>			wordLists.addElement(three);<br>			wordLists.addElement(four);<br>			wordLists.addElement(five);<br>			wordLists.addElement(six);<br>		}<br>		return wordLists;<br>	}<br></pre>
                 
<p align="left"><font size="4">The first, often only, and certainly most
important Language method is translationVector(), which returns a Vector
object containing a set of String arrays. Each String array is designated
by the size of the Common language words which will be used by the array
for translation. That is to say, whenever a Common word of three letters
is being translated into Elvish, the String array three will have a word
randomnly chosen from it. </font></p>
                 
<p><font size="4">The words which are placed into these string arrays is
arbitrary, and may actually contain as many or few letters as you like. Keeping
the number of letters close or the same as the Common word equivalent provides
    a certain symmetry, however, and makes it fun for the players who don't
  speak  a language to try and guess what is being said by counting letters.
  </font></p>
         <font size="4"> </font>         
<pre><font size="4"><small>	private static final Hashtable hashwords=new Hashtable();<br>	public Hashtable translationHash()<br>	{<br>		if((hashwords!=null)&amp;&amp;(hashwords.size()&gt;0)) <br>			return hashwords;<br>		hashwords.put("ABANDON","avarta");<br>		hashwords.put("ABLE","pol");<br>		hashwords.put("ACCOMMODATE","camta");<br>		hashwords.put("ACT","car");<br>		...<br>		hashwords.put("WRONG","raic&euml;");<br>		hashwords.put("YES","y&eacute;");<br>		hashwords.put("YESTERDAY","tellaur&euml;");<br>		return hashwords;<br>		}<br>	}</small><br></font></pre>
         <font size="4"> </font>         
<p align="left"><font size="4"><font size="4">The last Language method is 
    translationHash(). This method is entirely optional and may be left out 
  of a language definition. In fact, it usually IS left out. However, when 
 it is not, it provides a hashtable which can be used to translate exact english
   matches back to the fantasy language. The First word in each hashtable
 entry   is the English word (and it MUST MUST MUST be in UPPERCASE) as the
 key, and  the translation word as the entry value. Correct casing is taken
 care of by the Language base class.</font></font></p>
         <font size="4"> </font> <font size="4"> </font> <br>
        <br>
       <br>
      <br>
     <br>
     <br>
  <br>
 <br>
</body>
</html>
